diff --git a/.gitignore b/.gitignore
index b2913b82ae..f775c9f252 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,9 +9,29 @@ cmake_targets/nas_sim_tools/build/
 log/
 lte_build_oai/
 targets/bin/
+core
+*.lseq
+*.lcheck
+*.out
+
+# object files
+*.o
+*.obj
+*.orig
 
 # vscode
 .vscode
+.vscode/launch.json
+
+# python virtual env
+.env
+.venv
+env/
+venv/
+ENV/
+env.bak/
+venv.bak/
+
 
 # Tags for vim/global
 GPATH
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000000..bb69e69ac6
--- /dev/null
+++ b/Makefile
@@ -0,0 +1 @@
+include ../Makefile
diff --git a/ci-scripts/conf_files/mono.enb.band7.tm1.50PRB.usrpb210.conf b/ci-scripts/conf_files/mono.enb.band7.tm1.50PRB.usrpb210.conf
new file mode 100644
index 0000000000..59e837e078
--- /dev/null
+++ b/ci-scripts/conf_files/mono.enb.band7.tm1.50PRB.usrpb210.conf
@@ -0,0 +1,240 @@
+Active_eNBs = ( "eNB-Eurecom-LTEBox");
+# Asn1_verbosity, choice in: none, info, annoying
+Asn1_verbosity = "none";
+
+eNBs =
+(
+ {
+    ////////// Identification parameters:
+    eNB_ID    =  0xe00;
+
+    cell_type =  "CELL_MACRO_ENB";
+
+    eNB_name  =  "eNB-Eurecom-LTEBox";
+
+    // Tracking area code, 0x0000 and 0xfffe are reserved values
+    tracking_area_code = 1;
+    plmn_list = ( { mcc = 208; mnc = 92; mnc_length = 2; } );
+
+    tr_s_preference     = "local_mac"
+
+    ////////// Physical parameters:
+
+    component_carriers = (
+      {
+      node_function             = "3GPP_eNODEB";
+      node_timing               = "synch_to_ext_device";
+      node_synch_ref            = 0;
+      frame_type					      = "FDD";
+      tdd_config 					      = 3;
+      tdd_config_s            			      = 0;
+      prefix_type             			      = "NORMAL";
+      eutra_band              			      = 7;
+      downlink_frequency      			      = 2680000000L;
+      uplink_frequency_offset 			      = -120000000;
+      Nid_cell					      = 0;
+      N_RB_DL                 			      = 50;
+      Nid_cell_mbsfn          			      = 0;
+      nb_antenna_ports                                = 1;
+      nb_antennas_tx          			      = 1;
+      nb_antennas_rx          			      = 1;
+      tx_gain                                            = 90;
+      rx_gain                                            = 125;
+      pbch_repetition                                 = "FALSE";
+      prach_root              			      = 0;
+      prach_config_index      			      = 0;
+      prach_high_speed        			      = "DISABLE";
+      prach_zero_correlation  			      = 1;
+      prach_freq_offset       			      = 2;
+      pucch_delta_shift       			      = 1;
+      pucch_nRB_CQI           			      = 0;
+      pucch_nCS_AN            			      = 0;
+      pucch_n1_AN             			      = 0;
+      pdsch_referenceSignalPower 			      = -27;
+      pdsch_p_b                  			      = 0;
+      pusch_n_SB                 			      = 1;
+      pusch_enable64QAM          			      = "DISABLE";
+      pusch_hoppingMode                                  = "interSubFrame";
+      pusch_hoppingOffset                                = 0;
+      pusch_groupHoppingEnabled  			      = "ENABLE";
+      pusch_groupAssignment      			      = 0;
+      pusch_sequenceHoppingEnabled		   	      = "DISABLE";
+      pusch_nDMRS1                                       = 1;
+      phich_duration                                     = "NORMAL";
+      phich_resource                                     = "ONESIXTH";
+      srs_enable                                         = "DISABLE";
+      /*  srs_BandwidthConfig                                =;
+      srs_SubframeConfig                                 =;
+      srs_ackNackST                                      =;
+      srs_MaxUpPts                                       =;*/
+
+      pusch_p0_Nominal                                   = -96;
+      pusch_alpha                                        = "AL1";
+      pucch_p0_Nominal                                   = -104;
+      msg3_delta_Preamble                                = 6;
+      pucch_deltaF_Format1                               = "deltaF2";
+      pucch_deltaF_Format1b                              = "deltaF3";
+      pucch_deltaF_Format2                               = "deltaF0";
+      pucch_deltaF_Format2a                              = "deltaF0";
+      pucch_deltaF_Format2b		    	      = "deltaF0";
+
+      rach_numberOfRA_Preambles                          = 64;
+      rach_preamblesGroupAConfig                         = "DISABLE";
+      /*
+      rach_sizeOfRA_PreamblesGroupA                      = ;
+      rach_messageSizeGroupA                             = ;
+      rach_messagePowerOffsetGroupB                      = ;
+      */
+      rach_powerRampingStep                              = 4;
+      rach_preambleInitialReceivedTargetPower            = -108;
+      rach_preambleTransMax                              = 10;
+      rach_raResponseWindowSize                          = 10;
+      rach_macContentionResolutionTimer                  = 48;
+      rach_maxHARQ_Msg3Tx                                = 4;
+
+      pcch_default_PagingCycle                           = 128;
+      pcch_nB                                            = "oneT";
+      bcch_modificationPeriodCoeff			      = 2;
+      ue_TimersAndConstants_t300			      = 1000;
+      ue_TimersAndConstants_t301			      = 1000;
+      ue_TimersAndConstants_t310			      = 1000;
+      ue_TimersAndConstants_t311			      = 10000;
+      ue_TimersAndConstants_n310			      = 20;
+      ue_TimersAndConstants_n311			      = 1;
+      ue_TransmissionMode                                    = 1;
+
+
+      }
+    );
+
+
+    srb1_parameters :
+    {
+        # timer_poll_retransmit = (ms) [5, 10, 15, 20,... 250, 300, 350, ... 500]
+        timer_poll_retransmit    = 80;
+
+        # timer_reordering = (ms) [0,5, ... 100, 110, 120, ... ,200]
+        timer_reordering         = 35;
+
+        # timer_reordering = (ms) [0,5, ... 250, 300, 350, ... ,500]
+        timer_status_prohibit    = 0;
+
+        # poll_pdu = [4, 8, 16, 32 , 64, 128, 256, infinity(>10000)]
+        poll_pdu                 =  4;
+
+        # poll_byte = (kB) [25,50,75,100,125,250,375,500,750,1000,1250,1500,2000,3000,infinity(>10000)]
+        poll_byte                =  99999;
+
+        # max_retx_threshold = [1, 2, 3, 4 , 6, 8, 16, 32]
+        max_retx_threshold       =  4;
+    }
+
+    # ------- SCTP definitions
+    SCTP :
+    {
+        # Number of streams to use in input/output
+        SCTP_INSTREAMS  = 2;
+        SCTP_OUTSTREAMS = 2;
+    };
+
+
+    ////////// MME parameters:
+    mme_ip_address      = ( { ipv4       = "10.193.4.249";
+                              ipv6       = "";
+                              active     = "yes";
+                              preference = "ipv4";
+                            }
+                          );
+
+    enable_measurement_reports = "no";
+
+    ///X2
+    enable_x2 = "no";
+    t_reloc_prep      = 1000;      /* unit: millisecond */
+    tx2_reloc_overall = 2000;      /* unit: millisecond */
+
+    NETWORK_INTERFACES :
+    {
+        ENB_INTERFACE_NAME_FOR_S1_MME            = "eth1";
+        ENB_IPV4_ADDRESS_FOR_S1_MME              = "10.193.4.248";
+        ENB_INTERFACE_NAME_FOR_S1U               = "eth1";
+        ENB_IPV4_ADDRESS_FOR_S1U                 = "10.193.4.248";
+        ENB_PORT_FOR_S1U                         = 2152; # Spec 2152
+        ENB_IPV4_ADDRESS_FOR_X2C                 = "10.193.4.248";
+        ENB_PORT_FOR_X2C                         = 36422; # Spec 36422
+    };
+  }
+);
+
+MACRLCs = (
+	{
+	num_cc = 1;
+	tr_s_preference = "local_L1";
+	tr_n_preference = "local_RRC";
+	phy_test_mode = 0;
+  puSch10xSnr     =  160;
+  puCch10xSnr     =  160;
+  #scheduler_mode = "fairRR";
+  #scheduler_mode = "default";
+}
+);
+
+L1s = (
+    	{
+	num_cc = 1;
+	tr_n_preference = "local_mac";
+        }  
+);
+
+RUs = (
+    {		  
+       local_rf       = "yes"
+         nb_tx          = 1
+         nb_rx          = 1
+         att_tx         = 0
+         att_rx         = 0;
+         bands          = [7];
+         max_pdschReferenceSignalPower = -27;
+         max_rxgain                    = 120;
+         eNB_instances  = [0];
+
+    }
+);  
+
+THREAD_STRUCT = (
+  {
+    #three config for level of parallelism "PARALLEL_SINGLE_THREAD", "PARALLEL_RU_L1_SPLIT", or "PARALLEL_RU_L1_TRX_SPLIT"
+    parallel_config    = "PARALLEL_SINGLE_THREAD";
+    #two option for worker "WORKER_DISABLE" or "WORKER_ENABLE"
+    worker_config      = "WORKER_DISABLE";
+  }
+);
+
+NETWORK_CONTROLLER :
+{
+    FLEXRAN_ENABLED        = "no";
+    FLEXRAN_INTERFACE_NAME = "lo";
+    FLEXRAN_IPV4_ADDRESS   = "127.0.0.1";
+    FLEXRAN_PORT           = 2210;
+    FLEXRAN_CACHE          = "/mnt/oai_agent_cache";
+    FLEXRAN_AWAIT_RECONF   = "no";
+};
+
+     log_config :
+     {
+       global_log_level                      ="warn";
+       global_log_verbosity                  ="high";
+       hw_log_level                          ="warn";
+       hw_log_verbosity                      ="high";
+       phy_log_level                         ="warn";
+       phy_log_verbosity                     ="high";
+       mac_log_level                         ="warn";
+       mac_log_verbosity                     ="high";
+       rlc_log_level                         ="warn";
+       rlc_log_verbosity                     ="high";
+       pdcp_log_level                        ="warn";
+       pdcp_log_verbosity                    ="high";
+       rrc_log_level                         ="warn";
+       rrc_log_verbosity                     ="high";
+    };
+
diff --git a/ci-scripts/conf_files/mono.enb.band7.tm1.50PRB.usrpx310.conf b/ci-scripts/conf_files/mono.enb.band7.tm1.50PRB.usrpx310.conf
new file mode 100644
index 0000000000..97cc0bac3a
--- /dev/null
+++ b/ci-scripts/conf_files/mono.enb.band7.tm1.50PRB.usrpx310.conf
@@ -0,0 +1,238 @@
+Active_eNBs = ( "eNB-Eurecom-LTEBox");
+# Asn1_verbosity, choice in: none, info, annoying
+Asn1_verbosity = "none";
+
+eNBs =
+(
+ {
+    ////////// Identification parameters:
+    eNB_ID    =  0xe00;
+
+    cell_type =  "CELL_MACRO_ENB";
+
+    eNB_name  =  "eNB-Eurecom-LTEBox";
+
+    // Tracking area code, 0x0000 and 0xfffe are reserved values
+    tracking_area_code = 1;
+    plmn_list = ( { mcc = 208; mnc = 92; mnc_length = 2; } );
+
+    tr_s_preference     = "local_mac"
+
+    ////////// Physical parameters:
+
+    component_carriers = (
+      {
+      node_function             = "3GPP_eNODEB";
+      node_timing               = "synch_to_ext_device";
+      node_synch_ref            = 0;
+      frame_type					      = "FDD";
+      tdd_config 					      = 3;
+      tdd_config_s            			      = 0;
+      prefix_type             			      = "NORMAL";
+      eutra_band              			      = 7;
+      downlink_frequency      			      = 2680000000L;
+      uplink_frequency_offset 			      = -120000000;
+      Nid_cell					      = 0;
+      N_RB_DL                 			      = 50;
+      Nid_cell_mbsfn          			      = 0;
+      nb_antenna_ports                                = 1;
+      nb_antennas_tx          			      = 1;
+      nb_antennas_rx          			      = 1;
+      tx_gain                                            = 90;
+      rx_gain                                            = 125;
+      pbch_repetition                                 = "FALSE";
+      prach_root              			      = 0;
+      prach_config_index      			      = 0;
+      prach_high_speed        			      = "DISABLE";
+      prach_zero_correlation  			      = 1;
+      prach_freq_offset       			      = 2;
+      pucch_delta_shift       			      = 1;
+      pucch_nRB_CQI           			      = 0;
+      pucch_nCS_AN            			      = 0;
+      pucch_n1_AN             			      = 0;
+      pdsch_referenceSignalPower 			      = -27;
+      pdsch_p_b                  			      = 0;
+      pusch_n_SB                 			      = 1;
+      pusch_enable64QAM          			      = "DISABLE";
+      pusch_hoppingMode                                  = "interSubFrame";
+      pusch_hoppingOffset                                = 0;
+      pusch_groupHoppingEnabled  			      = "ENABLE";
+      pusch_groupAssignment      			      = 0;
+      pusch_sequenceHoppingEnabled		   	      = "DISABLE";
+      pusch_nDMRS1                                       = 1;
+      phich_duration                                     = "NORMAL";
+      phich_resource                                     = "ONESIXTH";
+      srs_enable                                         = "DISABLE";
+      /*  srs_BandwidthConfig                                =;
+      srs_SubframeConfig                                 =;
+      srs_ackNackST                                      =;
+      srs_MaxUpPts                                       =;*/
+
+      pusch_p0_Nominal                                   = -96;
+      pusch_alpha                                        = "AL1";
+      pucch_p0_Nominal                                   = -104;
+      msg3_delta_Preamble                                = 6;
+      pucch_deltaF_Format1                               = "deltaF2";
+      pucch_deltaF_Format1b                              = "deltaF3";
+      pucch_deltaF_Format2                               = "deltaF0";
+      pucch_deltaF_Format2a                              = "deltaF0";
+      pucch_deltaF_Format2b		    	      = "deltaF0";
+
+      rach_numberOfRA_Preambles                          = 64;
+      rach_preamblesGroupAConfig                         = "DISABLE";
+      /*
+      rach_sizeOfRA_PreamblesGroupA                      = ;
+      rach_messageSizeGroupA                             = ;
+      rach_messagePowerOffsetGroupB                      = ;
+      */
+      rach_powerRampingStep                              = 4;
+      rach_preambleInitialReceivedTargetPower            = -108;
+      rach_preambleTransMax                              = 10;
+      rach_raResponseWindowSize                          = 10;
+      rach_macContentionResolutionTimer                  = 48;
+      rach_maxHARQ_Msg3Tx                                = 4;
+
+      pcch_default_PagingCycle                           = 128;
+      pcch_nB                                            = "oneT";
+      bcch_modificationPeriodCoeff			      = 2;
+      ue_TimersAndConstants_t300			      = 1000;
+      ue_TimersAndConstants_t301			      = 1000;
+      ue_TimersAndConstants_t310			      = 1000;
+      ue_TimersAndConstants_t311			      = 10000;
+      ue_TimersAndConstants_n310			      = 20;
+      ue_TimersAndConstants_n311			      = 1;
+      ue_TransmissionMode                                    = 1;
+
+
+      }
+    );
+
+
+    srb1_parameters :
+    {
+        # timer_poll_retransmit = (ms) [5, 10, 15, 20,... 250, 300, 350, ... 500]
+        timer_poll_retransmit    = 80;
+
+        # timer_reordering = (ms) [0,5, ... 100, 110, 120, ... ,200]
+        timer_reordering         = 35;
+
+        # timer_reordering = (ms) [0,5, ... 250, 300, 350, ... ,500]
+        timer_status_prohibit    = 0;
+
+        # poll_pdu = [4, 8, 16, 32 , 64, 128, 256, infinity(>10000)]
+        poll_pdu                 =  4;
+
+        # poll_byte = (kB) [25,50,75,100,125,250,375,500,750,1000,1250,1500,2000,3000,infinity(>10000)]
+        poll_byte                =  99999;
+
+        # max_retx_threshold = [1, 2, 3, 4 , 6, 8, 16, 32]
+        max_retx_threshold       =  4;
+    }
+
+    # ------- SCTP definitions
+    SCTP :
+    {
+        # Number of streams to use in input/output
+        SCTP_INSTREAMS  = 2;
+        SCTP_OUTSTREAMS = 2;
+    };
+
+
+    ////////// MME parameters:
+    mme_ip_address      = ( { ipv4       = "10.193.4.249";
+                              ipv6       = "";
+                              active     = "yes";
+                              preference = "ipv4";
+                            }
+                          );
+
+    enable_measurement_reports = "no";
+
+    ///X2
+    enable_x2 = "no";
+    t_reloc_prep      = 1000;      /* unit: millisecond */
+    tx2_reloc_overall = 2000;      /* unit: millisecond */
+
+    NETWORK_INTERFACES :
+    {
+        ENB_INTERFACE_NAME_FOR_S1_MME            = "eth1";
+        ENB_IPV4_ADDRESS_FOR_S1_MME              = "10.193.4.248";
+        ENB_INTERFACE_NAME_FOR_S1U               = "eth1";
+        ENB_IPV4_ADDRESS_FOR_S1U                 = "10.193.4.248";
+        ENB_PORT_FOR_S1U                         = 2152; # Spec 2152
+        ENB_IPV4_ADDRESS_FOR_X2C                 = "10.193.4.248";
+        ENB_PORT_FOR_X2C                         = 36422; # Spec 36422
+    };
+  }
+);
+
+MACRLCs = (
+	{
+	num_cc = 1;
+	tr_s_preference = "local_L1";
+	tr_n_preference = "local_RRC";
+	phy_test_mode = 0;
+        puSch10xSnr     =  160;
+        puCch10xSnr     =  160;
+        }  
+);
+
+L1s = (
+    	{
+	num_cc = 1;
+	tr_n_preference = "local_mac";
+        }  
+);
+
+RUs = (
+    {		  
+       local_rf       = "yes"
+         nb_tx          = 1
+         nb_rx          = 1
+         att_tx         = 0
+         att_rx         = 0;
+         bands          = [7];
+         max_pdschReferenceSignalPower = -27;
+         max_rxgain                    = 116;
+         eNB_instances  = [0];
+       sdr_addrs      = "type=x300";
+    }
+);  
+
+THREAD_STRUCT = (
+  {
+    #three config for level of parallelism "PARALLEL_SINGLE_THREAD", "PARALLEL_RU_L1_SPLIT", or "PARALLEL_RU_L1_TRX_SPLIT"
+    parallel_config    = "PARALLEL_SINGLE_THREAD";
+    #two option for worker "WORKER_DISABLE" or "WORKER_ENABLE"
+    worker_config      = "WORKER_DISABLE";
+  }
+);
+
+NETWORK_CONTROLLER :
+{
+    FLEXRAN_ENABLED        = "no";
+    FLEXRAN_INTERFACE_NAME = "lo";
+    FLEXRAN_IPV4_ADDRESS   = "127.0.0.1";
+    FLEXRAN_PORT           = 2210;
+    FLEXRAN_CACHE          = "/mnt/oai_agent_cache";
+    FLEXRAN_AWAIT_RECONF   = "no";
+};
+
+     log_config :
+     {
+       global_log_level                      ="warn";
+       global_log_verbosity                  ="high";
+       hw_log_level                          ="warn";
+       hw_log_verbosity                      ="high";
+       phy_log_level                         ="warn";
+       phy_log_verbosity                     ="high";
+       mac_log_level                         ="warn";
+       mac_log_verbosity                     ="high";
+       rlc_log_level                         ="warn";
+       rlc_log_verbosity                     ="high";
+       pdcp_log_level                        ="warn";
+       pdcp_log_verbosity                    ="high";
+       rrc_log_level                         ="warn";
+       rrc_log_verbosity                     ="high";
+    };
+
diff --git a/cmake_targets/CMakeLists.txt b/cmake_targets/CMakeLists.txt
index 669f776461..87c1164291 100644
--- a/cmake_targets/CMakeLists.txt
+++ b/cmake_targets/CMakeLists.txt
@@ -317,7 +317,8 @@ add_boolean_option(DEBUG_PDCP_PAYLOAD  False "print PDCP PDU to stdout")  # if t
 add_boolean_option(DEBUG_MAC_INTERFACE False "print MAC-RLC PDU exchange to stdout") # if true, make sure that global and PDCP log levels are trace
 add_boolean_option(TRACE_RLC_PAYLOAD   False "print RLC PDU to stdout") # if true, make sure that global and PDCP log levels are trace
 add_boolean_option(PRINT_STATS         False "This adds the possibility to see the status")
-add_boolean_option(T_TRACER            True  "Activate the T tracer, a debugging/monitoring framework" )
+add_boolean_option(T_TRACER            False  "Activate the T tracer, a debugging/monitoring framework" )
+add_boolean_option(LATSEQ              False "Active Latency Sequence tools")
 add_boolean_option(UE_AUTOTEST_TRACE   False "Activate UE autotest specific logs")
 add_boolean_option(UE_DEBUG_TRACE      False "Activate UE debug trace")
 add_boolean_option(UE_TIMING_TRACE     False "Activate UE timing trace")
@@ -1180,6 +1181,7 @@ add_library(UTIL
   ${OPENAIR2_DIR}/UTIL/LISTS/list2.c
   ${OPENAIR_DIR}/common/utils/LOG/log.c
   ${OPENAIR_DIR}/common/utils/LOG/vcd_signal_dumper.c
+  ${OPENAIR_DIR}/common/utils/LATSEQ/latseq.c
   ${OPENAIR2_DIR}/UTIL/MATH/oml.c
   ${OPENAIR2_DIR}/UTIL/OPT/probe.c
   ${OPENAIR_DIR}/common/utils/threadPool/thread-pool.c
@@ -1694,6 +1696,7 @@ set(PHY_MEX_UE
   ${OPENAIR1_DIR}/PHY/TOOLS/signal_energy.c
   ${OPENAIR1_DIR}/PHY/LTE_ESTIMATION/lte_ue_measurements.c
   ${OPENAIR_DIR}/common/utils/LOG/log.c
+  ${OPENAIR_DIR}/common/utils/LATSEQ/latseq.c
   ${OPENAIR_DIR}/common/utils/T/T.c
   ${OPENAIR_DIR}/common/utils/T/local_tracer.c
   )
diff --git a/cmake_targets/build_oai b/cmake_targets/build_oai
index 5cafb95cba..9fa2e15aa3 100755
--- a/cmake_targets/build_oai
+++ b/cmake_targets/build_oai
@@ -392,6 +392,10 @@ function main() {
             CMAKE_CMD="$CMAKE_CMD -DT_TRACER=False"
             echo_info "Disabling the T tracer"
             shift 1;;
+       --enable-latseq)
+            CMAKE_CMD="$CMAKE_CMD -DLATSEQ=True"
+            echo info "Enabling Latency Sequence measures"
+            shift 1;;
        --disable-hardware-dependency)
             echo_info "Disabling hardware dependency for compiling software"
             DISABLE_HARDWARE_DEPENDENCY="True"
diff --git a/cmake_targets/tools/build_helper b/cmake_targets/tools/build_helper
index 179e2de428..22104ae6f9 100755
--- a/cmake_targets/tools/build_helper
+++ b/cmake_targets/tools/build_helper
@@ -216,6 +216,7 @@ compilations() {
     if [ "$MAKE_CMD" != "" ]; then
        $MAKE_CMD $2
     else 
+
     if [ "$VERBOSE_COMPILE" == "1" ]; then
        $COV_SCAN_PREFIX make -j`nproc` $2 VERBOSE=$VERBOSE_COMPILE
     else
diff --git a/common/utils/LATSEQ/README b/common/utils/LATSEQ/README
new file mode 100644
index 0000000000..a3d4f844f6
--- /dev/null
+++ b/common/utils/LATSEQ/README
@@ -0,0 +1,264 @@
+# LATency SEQuence analysis extension for OpenAirInterface
+
+A tool for internal latency analysis in Base Station.
+Code licenced under BSD-3. See more on https://github.com/Orange-OpenSource/LatSeq
+Author : Flavien Ronteix--Jacquet (Orange Innovation), Alexandre Ferrieux (Orange Innovation)
+Email : flavien.ronteixjacquet@orange.com, alexandre.ferrieux@orange.com
+## Installation
+
+- Put LatSeq extension source code in OAI code (https://gitlab.eurecom.fr/oai/openairinterface5g). We recommend to put it in the path common/utils/LATSEQ.
+- In cmake_targets/CMakeLists.txt put `add_boolean_option(LATSEQ True "Active Latency Sequence tools")`. Also add Latseq to compiled source `set(UTIL_SRC... ${OPENAIR_DIR}/common/utils/LATSEQ/latseq.c`
+- Put test/ in targets/TEST/LATSEQ/
+- Verify installation of LatSeq with `make` in targets/TEST/LATSEQ
+
+## Usage
+
+0) Add init_latseq(appname) and close_latseq() in main Base Station thread at the start and end.
+1) Add a new LatSeq measure point in the code with
+#include "common/utils/LATSEQ/latseq.h"
+#if LATSEQ
+LATSEQ_P("D pdcp--rlc", "pdcp%d.rlc%d", 0, 1);  
+#endif
+
+where first argument is the direction, the second the observed segment and the third argument is a string of data_identifier
+1) Compile OAI code with cmake option LATSEQ at True
+2) Run scanario for Uplink and Downlink
+3) Process lseq traces to yield data do statistics with LatSeq tools
+
+More in docs/Latseq.pdf
+
+## LatSeq measurement module
+
+For now, latseq is designed to be the more independant as possible : Means that it does not use oai LOG system (not register by logInit()) and the flag "LATSEQ" disable all lines related to latseq in the code (using #ifdef). In a second time, it could be conceivable to integrate more deeply latseq into oai code.
+
+latseq_t, global structure for latseq embodied the latseq logging info. log_buffer is a circular buffer with 2 head index, i_write_head and i_read_head. this buffer of latseq_element_t is designed to bo mutex-less.
+
+LATSEQ_P macro calls log_measure(). The idea is to have a low-footprint at logging explains why log_measure() should do a minimal amount of operations.
+
+latseq_log_to_file() is the function run in the logger thread. It writes log_elements in the log file.
+
+LATSEQ_P with direction of D (Downlink) or U (Uplink) observed the passage of a data.
+LATSEQ_P with direction of I (Information) observed a scalar property at a point of code. e.g. buffer occupancy.
+
+**We assume that**:
+- All the point and latseq module run on the same machine (to don't have to synchronize clock of different machines)
+- Clock give by asm rdtsc is same for all the CPU cores (constant_tsc enabled)
+
+
+## TOOLS
+
+Get scripts on https://github.com/Orange-OpenSource/LatSeq/tools
+
+- rdtsctots : convert rdtsc timestamp to unix timestamp value
+- latseq_logs : convert lseq log file into useful json file for statistics and visualization
+- filter_Is.awk : filter contextual informations
+- lseqj2any : generate waterfall to format gp or svg
+
+- latseq_checker : verify constitency of Latseq points before compiling
+- latseq_filter : filter output of latseq_logs
+- latseq_stats : perform statistic
+
+### latseq_checker
+Checker to verify that points LATSEQ_P points are consistent.
+Verify the number of argument, the emptiness, format...
+
+ex. ./latseq_checker.sh /home/oai/
+
+### rdtsctots
+convert rdtsc value to unix timestamp value
+
+ex. `./rdtsctots.py trace_raw.lseq > trace.lseq`
+
+### latseq_logs
+Proceeds LatSeq logs.
+A *.lseq is required.
+By default, builds the latseq_log object.
+- Reads lseq file given in raw_input
+- Cleans raw_input to inputs.
+- Builds points structure and paths possible.
+- Saves object related to the *.lseq files to a *.plk (pickle)
+
+**Arguments**:
+- "-h" : help
+- "-C" : cleans pickle file associated to the log file and rebuild
+- "-l" : required lseq file of fingerprints
+- "-i" : request cleaned input measurements in the case of command line script
+- "-r" returns the paths present in the log file as json.
+```
+{
+    "D": [
+        ["ip", "pdcp.in",...],
+        ...
+    ],
+    "U": ...
+}
+``̀
+
+- "-p" returns points structure as json.
+Becareful, if journeys has not been rebuilt, then you do not have "duration" attibute which is used for statistics.
+```
+{
+    "layer1.point": {
+        "next": [layer2.point2,...],
+        "count": 5,
+        "dir": [0],
+        "duration": {
+            "journeys uid": 0.0115,
+            ...
+        }
+    }
+}
+{
+    ...
+}
+```
+
+- "-j" returns journeys structure as json.
+	- Rebuilds journeys with rebuild_packets_journey method
+	- Builds out_journeys
+```
+{
+    "uid": 52,
+    "dir": 0,
+    "glob": {
+        "rnti": "54614",...
+    },
+    "set": [[1542, 1592409314.253678, "rlc.rx.am--pdcp.rx"],[...],...],  # set of pointer to input entry
+    "set_ids": {
+        "drb": "1",...
+    },
+    "path": 0,  # path according to direction and paths obtainable by -p
+    "completed": true,
+    "ts_in": 123.456,
+    "ts_out": 789.012
+}
+{
+    ...
+}
+```
+
+- "-m" returns metadata of information as list
+```
+20200423_143226.191801  rlc.am.txbuf    occ1:drb1
+20200423_143226.191802  rlc.am.txbuf    occ2:drb1
+...
+20200423_143226.192000  rlc.um.txbuf    occ15:drb2
+```
+
+- "-o" returns a latseq journey file line by line. redirects output to a file to have a *.lseqj for waterfall generation
+```
+#funcId ip pdcp.in pdcp.tx rlc.tx.um rlc.seg.um mac.mux mac.txreq phy.out.proc phy.in.proc mac.demux rlc.rx.um rlc.unseg.um pdcp.rx 
+20200423_143226.191801 D (len64)        ip--pdcp.in.gtp uid0.rnti54614.drb1.gsn12
+20200423_143226.191802 D (len64)        pdcp.in--pdcp.tx        uid0.rnti54614.drb1.gsn12.psn10
+20200423_143226.191803 D (len66)        pdcp.tx--rlc.tx.um      uid0.rnti54614.drb1.psn10.lcid3.rsdu0
+```
+
+Requested json are printed in stdout line by line
+Errors, Warnings, Informations are printed in stderr
+
+Example of usage:
+./latseq_logs.py -l ~/latseq.23042020.lseq 2>/dev/null
+./latseq_logs.py -j -l ~/latseq.23042020.lseq 2>/dev/null
+./latseq_logs.py -p -l ~/latseq.23042020.lseq 2>/dev/null
+./latseq_logs.py -o -l ~/latseq.23042020.lseq > 23042020.lseqj 2>/dev/null
+
+### latseq_filter
+Applies a filter to a json stream.
+It uses jq filters.
+Help website to design jq filter : https://jqplay.org/
+
+Takes a file with a filter or a filter as string in argument.
+
+Example of usage:
+./latseq_filter.sh journeys_downlinks_gsn.lfilter
+cat journeys_downlinks_gsn.lfilter
+> select(.["dir"] == 0 and .["set_ids"]["gsn"] == "18")
+
+### latseq_stats
+Performs statistics from json. Report json or print in stdout.
+
+By default, reads on stdin. "-l" *.lseq will try to open a *.json associated.
+By default, returns a json report on stdout.
+
+Arguments:
+- "-f" enables to choose format "json", "csv",...
+- "-P" prints statistics formated by the latseq_stats module.
+- "-sj" returns statistics on journeys
+`̀``
+{
+    "D": {
+        "size": 34,
+        "min": 0.19598,
+        "max": 1.187086,
+        "mean": 0.788976,
+        "stdev": 0.153623,
+        "quantiles": [0.694859, 0.699043, 0.834942, 0.838041, 0.955701]
+}
+`̀``
+
+- "-sjpp" returns the shares of delay introduced by each point for each journeys by path.
+```
+{
+  "U02": {  # Uplinks, path 0, point 2
+    "size": 4,
+    "min": 0,
+    "max": 0.7273,
+    "mean": 0.36239999999999994,
+    "stdev": 0.2915949673776967,
+    "quantiles": [
+      0.025005000000000003,
+      0.125025,
+      0.36114999999999997,
+      0.598525,
+      0.7015449999999999
+    ]
+  }
+}
+```
+
+- "-sp" returns statistics on points
+```
+{
+    "pdcp.rx": {
+        "dir": "U",
+        "size": 4,
+        "min": 0.01,
+        "max": 0.02,
+        "mean": 0.015,
+        "stdev": 0.005,
+        "quantiles": [0.012,...]  # 5%, 25%, 50%, 75%, 95%
+    },
+    ...
+}
+`̀``
+
+- "-djd" returns data journeys' duration
+`̀``
+{
+    "00": {  # first decimal indicates uplink/downlink followed by the journey unique id
+        "ts": 1587645146.191801,
+        "durations": 0.19598  # in ms
+    },
+    ...
+}
+`̀``
+
+Example of usage of the full toolchain for LatSeq Analysis Module
+./latseq_logs.py -l ~/latseq.simple.lseq -j 2>/dev/null | ./latseq_filter.sh journeys_downlinks_gsn.lfilt | ./latseq_stats.py -sj --print
+
+### lseqj2any
+
+generate waterfall
+
+cat uplink_burst.30102020_203233.lseqj | lseqj2any gp > uplink_burst.gp
+
+## TEST_LATSEQ
+in targets/TEST/LATSEQ test_latseq test different part of latseq module
+- "h" : help menu
+- "i" : test init and close latseq
+- "a" : test init, capture 2 fingerprints and close
+- "t" : same test as "a" but with 2 concurrent threads
+- "m" : test measurement time to capture 1000000 fingerprints
+- "n" : test measurement time to capture 1000 fingerprints with 1,2,3,5,10 data identifiers
+- "w" : test writer speed for a simplified data collector
+
diff --git a/common/utils/LATSEQ/latseq.c b/common/utils/LATSEQ/latseq.c
new file mode 100644
index 0000000000..2addf7a018
--- /dev/null
+++ b/common/utils/LATSEQ/latseq.c
@@ -0,0 +1,284 @@
+/*
+ * Software Name : LatSeq
+ * Version: 1.0
+ * SPDX-FileCopyrightText: Copyright (c) 2020-2021 Orange Labs
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * This software is distributed under the BSD 3-clause,
+ * the text of which is available at https://opensource.org/licenses/BSD-3-Clause
+ * or see the "license.txt" file for more details.
+ *
+ * Author: Flavien Ronteix--Jacquet
+ * Software description: LatSeq measurement part core
+ */
+
+#define _GNU_SOURCE // required for pthread_setname_np()
+#include "latseq.h"
+
+/*--- GLOBALS and EXTERNS ----------------------------------------------------*/
+
+latseq_t g_latseq;
+__thread latseq_thread_data_t tls_latseq = {
+  .th_latseq_id = 0
+}; // need to be a thread local storage variable.
+pthread_t logger_thread;
+pthread_t fflusher_thread;
+//double cpuf; //cpu frequency in MHz -> usec. Should be initialized in main.c
+extern volatile int oai_exit; //oai is ended. Close latseq
+
+/*--- UTILS FUNCTIONS --------------------------------------------------------*/
+
+uint64_t get_cpu_freq_cycles(void)
+{
+  uint64_t ts = l_rdtsc();
+  sleep(1);
+  return (l_rdtsc() - ts);
+}
+
+/*--- MAIN THREAD FUNCTIONS --------------------------------------------------*/
+
+int init_latseq(const char * appname, uint64_t cpufreq)
+{ 
+  // init members
+  g_latseq.is_running = 0;
+  //synchronise time and rdtsc
+  struct timespec ts;
+  clock_gettime(CLOCK_REALTIME, &ts);
+  g_latseq.time_zero = (uint64_t)ts.tv_sec * 1000000000LL + (uint64_t)ts.tv_nsec;
+  g_latseq.rdtsc_zero = l_rdtsc(); //check at compile time that constant_tsc is enabled in /proc/cpuinfo
+  if (cpufreq == 0) {
+    g_latseq.cpu_freq = get_cpu_freq_cycles();
+  } else {
+    g_latseq.cpu_freq = cpufreq;
+  }
+
+  // Open traces
+  char time_string[16];
+  strftime(time_string, sizeof (time_string), "%d%m%Y_%H%M%S", localtime(&ts.tv_sec));
+  g_latseq.filelog_name = (char *)malloc(LATSEQ_MAX_STR_SIZE);
+  sprintf(g_latseq.filelog_name, "%s.%s.lseq", appname, time_string);
+  //open logfile
+  g_latseq.outstream = fopen(g_latseq.filelog_name, "w");
+  if (g_latseq.outstream == NULL) {
+    g_latseq.is_running = 0;
+    printf("[LATSEQ] Error at opening log file\n");
+    return -1;
+  }
+  //write header
+  char hdr[] = "# LatSeq packet fingerprints\n# By Alexandre Ferrieux and Flavien Ronteix Jacquet\n# timestamp\tU/D\tsrc--dest\tlen:ctxtId:localId\n";
+  size_t ret = fwrite(hdr, sizeof(char), sizeof(hdr) - 1, g_latseq.outstream);
+  if (ret < 0) {
+    printf("[LATSEQ] Error at opening log file\n");
+    g_latseq.is_running = 0;
+    return -1;
+  }
+  fprintf(g_latseq.outstream, "%ld S rdtsc--gettimeofday %ld.%09ld\n", g_latseq.rdtsc_zero, ts.tv_sec, ts.tv_nsec);
+  fflush(g_latseq.outstream);
+  
+  // init registry
+  g_latseq.local_log_buffers.read_ith_thread = 0;
+  g_latseq.local_log_buffers.nb_th = 0;
+  memset(&g_latseq.local_log_buffers.i_read_heads, 0, MAX_NB_THREAD * sizeof(unsigned int));
+  
+  // init stat
+  g_latseq.stats.entry_counter = 0;
+  g_latseq.stats.bytes_counter = 0;
+
+  // init latseq_thread_t
+  tls_latseq.th_latseq_id = 0;
+  
+  // init logger thread
+  g_latseq.is_running = 1;
+  
+  return init_logger_latseq();
+}
+
+int init_logger_latseq(void)
+{
+  // init thread to write buffer to file
+  if(pthread_create(&logger_thread, NULL, (void *) &latseq_log_to_file, NULL) > 0) {
+    printf("[LATSEQ] Error at starting data collector\n");
+    g_latseq.is_running = 0;
+    return -1;
+  }
+  // init thread to flush into file
+  pthread_create(&fflusher_thread, NULL, (void *) &fflush_latseq_periodically, NULL);
+
+  return g_latseq.is_running;
+}
+
+void latseq_print_stats(void)
+{
+  printf("[LATSEQ] === stats ===\n");
+  printf("[LATSEQ] number of entry in log : %d\n", g_latseq.stats.entry_counter);
+  //printf("[LATSEQ] heads positions : %d (Write) : %d (Read)\n", g_latseq.i_write_head, g_latseq.i_read_head);
+}
+
+int close_latseq(void)
+{
+  g_latseq.is_running = 0;
+  //Wait logger finish to write data
+  pthread_join(logger_thread, NULL);
+  //At this point, data_ids and points should be freed by the logger thread
+  free((char*) g_latseq.filelog_name);
+  if (fclose(g_latseq.outstream)){
+    fprintf(stderr, "[LATSEQ] error on closing %s\n", g_latseq.filelog_name);
+    exit(EXIT_FAILURE);
+  }
+  return 1;
+}
+
+/*--- INSTRUMENTED THREAD FUNCTIONS ------------------------------------------*/
+
+int init_thread_for_latseq(void)
+{
+
+  //Init tls_latseq for local thread
+  tls_latseq.i_write_head = 0; //local thread tls_latseq
+  //memset(tls_latseq.log_buffer, 0, sizeof(tls_latseq.log_buffer));
+
+  //Register thread in the registry
+  latseq_registry_t * reg = &g_latseq.local_log_buffers;
+  //Check if space left in registry
+  if (reg->nb_th >= MAX_NB_THREAD) {
+    g_latseq.is_running = 0;
+    fprintf(g_latseq.outstream, "Max instrumented thread MAX_NB_THREAD reached\n");
+    return -1;
+  }
+  reg->tls[reg->nb_th] = &tls_latseq;
+  reg->i_read_heads[reg->nb_th] = 0;
+
+  //Give id to the thread
+  reg->nb_th++;
+  tls_latseq.th_latseq_id = reg->nb_th;
+  return 0;
+  //TODO : No destroy function ? What happens when thread is stopped and data had not been written in the log file ?
+}
+
+/*--- DATA COLLECTOR THREAD FUNCTIONS ----------------------------------------*/
+
+static int write_latseq_entry(void)
+{
+  //reference to latseq_thread_data
+  latseq_thread_data_t * th = g_latseq.local_log_buffers.tls[g_latseq.local_log_buffers.read_ith_thread];
+  //read_head for this thread_data
+  unsigned int * i_read_head = &g_latseq.local_log_buffers.i_read_heads[g_latseq.local_log_buffers.read_ith_thread];
+  //reference to element to write
+  latseq_element_t * e = &th->log_buffer[(*i_read_head)%RING_BUFFER_SIZE];
+
+  char * tmps;
+  //Convert latseq_element to a string
+  tmps = calloc(LATSEQ_MAX_STR_SIZE, sizeof(char));
+  //Write the data identifier, e.g. do the vsprintf() here and not at measure()
+  //We put the first NB_DATA_IDENTIFIERS elements of array, even there are no NB_DATA_IDENTIFIERS element to write. sprintf will get the firsts...
+  sprintf(
+    tmps,
+    e->format, 
+    e->data_id[0],
+    e->data_id[1],
+    e->data_id[2],
+    e->data_id[3],
+    e->data_id[4],
+    e->data_id[5],
+    e->data_id[6],
+    e->data_id[7],
+    e->data_id[8],
+    e->data_id[9]);
+
+  // Write into file
+  int ret = fprintf(g_latseq.outstream, "%ld %s %s\n",
+    e->ts,
+    e->point,
+    tmps);
+
+  if (ret < 0) {
+    g_latseq.is_running = 0;
+    fclose(g_latseq.outstream);
+    fprintf(stderr, "[LATSEQ] output log file cannot be written\n");
+    exit(EXIT_FAILURE);
+  }
+#ifdef LATSEQ_DEBUG
+  fprintf(g_latseq.outstream, "# debug %ld.%06ld : log an entry (len %d) for %s\n", etv.tv_sec, etv.tv_usec, ret, e->point);
+  fprintf(g_latseq.outstream, "# info %ld.%06ld : buffer occupancy (%d / %d) for thread which embedded %s\n",etv.tv_sec, etv.tv_usec, OCCUPANCY((*(&th->i_write_head)%RING_BUFFER_SIZE), ((*i_read_head)%RING_BUFFER_SIZE)), RING_BUFFER_SIZE, e->point);
+#endif
+
+  free(tmps);
+  // cleanup buffer element
+  e->ts = 0;
+  memset(e->data_id, 0, (sizeof(uint32_t) * e->len_id));
+  e->len_id = 0;
+  
+  //Update read_head for the current read_ith_thread
+  //Update g_latseq.local_log_buffers.i_read_heads[g_latseq.local_log_buffers.read_ith_thread] head position
+  (*i_read_head)++;
+
+  return ret;
+}
+
+void latseq_log_to_file(void)
+{
+  // pthread config
+  pthread_t thId = pthread_self();
+  //set name
+  pthread_setname_np(thId, "latseq_log_to_file");
+  //set priority
+  int prio_for_policy = 10;
+  pthread_setschedprio(thId, prio_for_policy);
+
+  latseq_registry_t * reg = &g_latseq.local_log_buffers;
+  int items_to_read = 0;
+
+  while (!oai_exit) { // run until oai is stopped
+    if (!g_latseq.is_running) { break; } //running flag is at 0, not running
+    //If no thread registered, continue and wait
+    if (reg->nb_th == 0) { usleep(1000); continue; }
+    //Select a thread to read with read_ith_thread. 
+    // Using RR for now, WRR in near future according to occupancy
+    if (reg->read_ith_thread + 1 >= reg->nb_th) {
+      reg->read_ith_thread = 0;
+    } else {
+      reg->read_ith_thread++;
+    }
+
+    //If max occupancy reached for a local buffer
+    if (reg->tls[reg->read_ith_thread]->i_write_head < reg->i_read_heads[reg->read_ith_thread]) {
+      fprintf(g_latseq.outstream, "# Error\tring buffer of thread (%d) reach max occupancy of %d\n", reg->read_ith_thread, RING_BUFFER_SIZE);
+    }
+
+    items_to_read = CHUNK_SIZE_ITEMS;
+    // Write by chunk
+    while (reg->tls[reg->read_ith_thread]->i_write_head > reg->i_read_heads[reg->read_ith_thread] && items_to_read > 0 ) {
+      //printf("[debug] th %d : (%d)w (%d)r : (%d)items_to_read\n", reg->read_ith_thread, reg->tls[reg->read_ith_thread]->i_write_head, reg->i_read_heads[reg->read_ith_thread], items_to_read);
+      items_to_read--;
+      //Write pointed entry into log file
+      g_latseq.stats.bytes_counter += (uint32_t)write_latseq_entry();
+      g_latseq.stats.entry_counter++;
+    }
+    usleep(1);
+  } // while(!oai_exit)
+
+  //Write all remaining data
+  for (uint8_t i = 0; i < reg->nb_th; i++) {
+    reg->read_ith_thread = i;
+    while (reg->tls[reg->read_ith_thread]->i_write_head > reg->i_read_heads[reg->read_ith_thread])
+    {
+      g_latseq.stats.bytes_counter += (uint32_t)write_latseq_entry();
+      g_latseq.stats.entry_counter++;
+    }
+  }
+  //close_latseq(); // function to close latseq properly
+  //exit thread
+  pthread_exit(NULL);
+}
+
+void fflush_latseq_periodically(void)
+{
+  struct timespec ts;
+  while(1){
+    sleep(1);
+    fflush(g_latseq.outstream);
+    clock_gettime(CLOCK_REALTIME, &ts);
+    fprintf(g_latseq.outstream, "%ld S rdtsc--gettimeofday %ld.%09ld\n", l_rdtsc(), ts.tv_sec, ts.tv_nsec);
+  }
+  pthread_exit(NULL);
+}
diff --git a/common/utils/LATSEQ/latseq.h b/common/utils/LATSEQ/latseq.h
new file mode 100644
index 0000000000..e34f954ef2
--- /dev/null
+++ b/common/utils/LATSEQ/latseq.h
@@ -0,0 +1,409 @@
+/*
+ * Software Name : LatSeq
+ * Version: 1.0
+ * SPDX-FileCopyrightText: Copyright (c) 2020-2021 Orange Labs
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * This software is distributed under the BSD 3-clause,
+ * the text of which is available at https://opensource.org/licenses/BSD-3-Clause
+ * or see the "license.txt" file for more details.
+ *
+ * Author: Flavien Ronteix--Jacquet
+ * Software description: LatSeq measurement part core
+ */
+
+#ifndef __LATSEQ_H__
+#define __LATSEQ_H__
+
+/*--- INCLUDES ---------------------------------------------------------------*/
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <assert.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <time.h>
+#include <stdint.h>
+#ifndef __STDC_FORMAT_MACROS
+  #define __STDC_FORMAT_MACROS
+#endif
+#include <inttypes.h>
+#ifndef _GNU_SOURCE
+  #define _GNU_SOURCE
+#endif
+#include <pthread.h>
+#include <utils.h>
+
+/*--- DEFINE -----------------------------------------------------------------*/
+
+#define RING_BUFFER_SIZE    1024 // Number of fingerprints in Ring Buffer
+#define NB_DATA_IDENTIFIERS 10  // to update according to distinct data identifier used in point
+#define LATSEQ_MAX_STR_SIZE 128 // Length for filelog_name AND latseq fingerprint string size
+#define CHUNK_SIZE_ITEMS    16  // Size of chunk of ring buffer to read at data collector. 1 correspoding to full RR, RING_BUFFER_SIZE read all buffer by passage
+#define MAX_NB_THREAD       32  // Maximum number of instrumented threads expected
+
+/*--- MACRO ------------------------------------------------------------------*/
+#define LATSEQ_P3(p, f, i1) do {log_measure1(p, f, (uint32_t)i1); } while(0)
+#define LATSEQ_P4(p, f, i1, i2) do {log_measure2(p, f, (uint32_t)i1, (uint32_t)i2); } while(0)
+#define LATSEQ_P5(p, f, i1, i2, i3) do {log_measure3(p, f, (uint32_t)i1, (uint32_t)i2, (uint32_t)i3); } while(0)
+#define LATSEQ_P6(p, f, i1, i2, i3, i4) do {log_measure4(p, f, (uint32_t)i1, (uint32_t)i2, (uint32_t)i3, (uint32_t)i4);} while(0)
+#define LATSEQ_P7(p, f, i1, i2, i3, i4, i5) do {log_measure5(p, f, (uint32_t)i1, (uint32_t)i2, (uint32_t)i3, (uint32_t)i4, (uint32_t)i5); } while(0)
+#define LATSEQ_P8(p, f, i1, i2, i3, i4, i5, i6) do {log_measure6(p, f, (uint32_t)i1, (uint32_t)i2, (uint32_t)i3, (uint32_t)i4, (uint32_t)i5, (uint32_t)i6); } while(0)
+#define LATSEQ_P9(p, f, i1, i2, i3, i4, i5, i6, i7) do {log_measure7(p, f, (uint32_t)i1, (uint32_t)i2, (uint32_t)i3, (uint32_t)i4, (uint32_t)i5, (uint32_t)i6, (uint32_t)i7); } while(0)
+#define LATSEQ_P10(p, f, i1, i2, i3, i4, i5, i6, i7, i8) do {log_measure8(p, f, (uint32_t)i1, (uint32_t)i2, (uint32_t)i3, (uint32_t)i4, (uint32_t)i5, (uint32_t)i6, (uint32_t)i7, (uint32_t)i8); } while(0)
+#define LATSEQ_P11(p, f, i1, i2, i3, i4, i5, i6, i7, i8, i9) do {log_measure9(p, f, (uint32_t)i1, (uint32_t)i2, (uint32_t)i3, (uint32_t)i4, (uint32_t)i5, (uint32_t)i6, (uint32_t)i7, (uint32_t)i8, (uint32_t)i9); } while(0)
+#define LATSEQ_P12(p, f, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10) do {log_measure10(p, f, (uint32_t)i1, (uint32_t)i2, (uint32_t)i3, (uint32_t)i4, (uint32_t)i5, (uint32_t)i6, (uint32_t)i7, (uint32_t)i8, (uint32_t)i9, (uint32_t)i10); } while(0)
+#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,NAME,...) NAME
+#define LATSEQ_P(...) GET_MACRO(__VA_ARGS__, LATSEQ_P12, LATSEQ_P11, LATSEQ_P10, LATSEQ_P9, LATSEQ_P8, LATSEQ_P7, LATSEQ_P6, LATSEQ_P5, LATSEQ_P4, LATSEQ_P3)(__VA_ARGS__)
+#define OCCUPANCY(w, r) (w - r)
+
+/*--- STRUCT -----------------------------------------------------------------*/
+
+// A latseq element of the buffer
+typedef struct latseq_element_t {
+  uint64_t            ts; // timestamp of the measure
+  const char *        point;
+  const char *        format;
+  ushort              len_id; // Number data identifiers
+  uint32_t            data_id[NB_DATA_IDENTIFIERS]; // values for the data identifier. What is the best type ?
+} latseq_element_t;
+
+// Statistics structures for latseq
+typedef struct latseq_stats_t {
+  uint32_t        entry_counter;
+  uint32_t        bytes_counter;
+} latseq_stats_t;
+
+//thread specific data struct
+typedef struct latseq_thread_data_t {
+  uint8_t             th_latseq_id; //Identifier of pthread for registry
+  latseq_element_t    log_buffer[RING_BUFFER_SIZE]; //log buffer, structure mutex-less
+  unsigned int        i_write_head; // position of writer in the log_buffer (main thread)
+} latseq_thread_data_t;
+
+//Registry of pointers to thread-specific struct latseq_data_thread
+typedef struct latseq_registry_t {
+  uint8_t                 read_ith_thread;
+  uint8_t                 nb_th;
+  latseq_thread_data_t *  tls[MAX_NB_THREAD];
+  unsigned int            i_read_heads[MAX_NB_THREAD]; // position of reader in the ith log buffer (logger thread)
+} latseq_registry_t;
+
+// Global structure of LatSeq module
+typedef struct latseq_t {
+  int                 is_running; //1 is running, 0 not running
+  char *              filelog_name;
+  FILE *              outstream; //Output descriptor
+  uint64_t            time_zero; // time zero
+  uint64_t            rdtsc_zero; //rdtsc zero
+  uint64_t            cpu_freq; //cpu frequency
+  latseq_registry_t   local_log_buffers; //Register of thread-specific buffers
+  latseq_stats_t      stats; // stats of latseq instance
+} latseq_t;
+
+/*--- EXTERNS ----------------------------------------------------------------*/
+
+extern latseq_t g_latseq; // global structure
+extern __thread latseq_thread_data_t tls_latseq;
+
+/*--- FUNCTIONS --------------------------------------------------------------*/
+/** \fn int init_latseq(const char * appname);
+ * \brief init latency sequences module.
+ * \param appname app's name. The output file is appname.date_hour.lseq
+ * \param cpufreq. cpu frequency in cycles.
+ * \return -1 if error 1 otherwise
+*/
+int init_latseq(const char * appname, uint64_t cpufreq);
+
+/** \fn init_logger_to_mem(void);
+ * \brief init thread logger
+ * \return -1 if error 1 otherwise
+*/
+int init_logger_latseq(void);
+
+/** \fn init_thread_for_latseq(void);
+ * \brief init tls_latseq for local oai thread
+ * \return -1 if error, 0 otherwise
+*/
+int init_thread_for_latseq(void);
+
+/** \fn l_rdtsc(void);
+ * \brief rdtsc wrapper
+ * \return time
+*/
+static __inline__ uint64_t l_rdtsc(void) {
+  uint32_t a, d;
+  __asm__ volatile ("rdtsc" : "=a" (a), "=d" (d));
+  return (((uint64_t)d)<<32) | ((uint64_t)a);
+}
+
+/** \fn get_cpu_freq_cycles(void);
+ * \brief Compute CPU clock in a 1 second experiment
+ * \return CPU clock in cycles
+*/
+uint64_t get_cpu_freq_cycles(void);
+
+/*--- MEASUREMENTS -----------------------------------------------------------*/
+/** \fn void log_measure(const char * point, const char *identifier);
+ * \brief function to log a new measure into buffer.
+ * From 1 to NB_DATA_IDENTIFIERS
+ * \param point name of the measurement point
+ * \param id identifier for the data pointed
+ * \todo  measure latency introduced by this function
+*/
+static __inline__ void log_measure1(const char * point, const char *fmt, uint32_t i1)
+{
+  //check if the oai thread is already registered
+  if (tls_latseq.th_latseq_id == 0) {
+    //is not initialized yet
+    if (init_thread_for_latseq()) {
+      return;
+    }
+  }
+  //get reference on new element
+  latseq_element_t * e = &tls_latseq.log_buffer[tls_latseq.i_write_head%RING_BUFFER_SIZE];
+  e->ts = l_rdtsc();
+  e->point = point;
+  e->format = fmt;
+  e->len_id = 1;
+  e->data_id[0] = i1;
+  //Update head position
+  tls_latseq.i_write_head++;
+}
+
+static __inline__ void log_measure2(const char * point, const char *fmt, uint32_t i1, uint32_t i2)
+{
+  if (tls_latseq.th_latseq_id == 0) {
+    //is not initialized yet
+    if (init_thread_for_latseq()) {
+      return;
+    }
+  }
+  latseq_element_t * e = &tls_latseq.log_buffer[tls_latseq.i_write_head%RING_BUFFER_SIZE];
+  e->ts = l_rdtsc();
+  e->point = point;
+  e->format = fmt;
+  e->len_id = 2;
+  e->data_id[0] = i1;
+  e->data_id[1] = i2;
+  tls_latseq.i_write_head++;
+}
+
+static __inline__ void log_measure3(const char * point, const char *fmt, uint32_t i1, uint32_t i2, uint32_t i3)
+{
+  if (tls_latseq.th_latseq_id == 0) {
+    //is not initialized yet
+    if (init_thread_for_latseq()) {
+      return;
+    }
+  }
+  latseq_element_t * e = &tls_latseq.log_buffer[tls_latseq.i_write_head%RING_BUFFER_SIZE];
+  e->ts = l_rdtsc();
+  e->point = point;
+  e->format = fmt;
+  e->len_id = 3;
+  e->data_id[0] = i1;
+  e->data_id[1] = i2;
+  e->data_id[2] = i3;
+  tls_latseq.i_write_head++;
+}
+
+static __inline__ void log_measure4(const char * point, const char *fmt, uint32_t i1, uint32_t i2, uint32_t i3, uint32_t i4)
+{
+  if (tls_latseq.th_latseq_id == 0) {
+    //is not initialized yet
+    if (init_thread_for_latseq()) {
+      return;
+    }
+  }
+  latseq_element_t * e = &tls_latseq.log_buffer[tls_latseq.i_write_head%RING_BUFFER_SIZE];
+  e->ts = l_rdtsc();
+  e->point = point;
+  e->format = fmt;
+  e->len_id = 4;
+  e->data_id[0] = i1;
+  e->data_id[1] = i2;
+  e->data_id[2] = i3;
+  e->data_id[3] = i4;
+  tls_latseq.i_write_head++;
+}
+
+static __inline__ void log_measure5(const char * point, const char *fmt, uint32_t i1, uint32_t i2, uint32_t i3, uint32_t i4, uint32_t i5)
+{
+  if (tls_latseq.th_latseq_id == 0) {
+    //is not initialized yet
+    if (init_thread_for_latseq()) {
+      return;
+    }
+  }
+  latseq_element_t * e = &tls_latseq.log_buffer[tls_latseq.i_write_head%RING_BUFFER_SIZE];
+  e->ts = l_rdtsc();
+  e->point = point;
+  e->format = fmt;
+  e->len_id = 5;
+  e->data_id[0] = i1;
+  e->data_id[1] = i2;
+  e->data_id[2] = i3;
+  e->data_id[3] = i4;
+  e->data_id[4] = i5;
+  tls_latseq.i_write_head++;
+}
+
+static __inline__ void log_measure6(const char * point, const char *fmt, uint32_t i1, uint32_t i2, uint32_t i3, uint32_t i4, uint32_t i5, uint32_t i6)
+{
+  if (tls_latseq.th_latseq_id == 0) {
+    //is not initialized yet
+    if (init_thread_for_latseq()) {
+      return;
+    }
+  }
+  latseq_element_t * e = &tls_latseq.log_buffer[tls_latseq.i_write_head%RING_BUFFER_SIZE];
+  e->ts = l_rdtsc();
+  e->point = point;
+  e->format = fmt;
+  e->len_id = 6;
+  e->data_id[0] = i1;
+  e->data_id[1] = i2;
+  e->data_id[2] = i3;
+  e->data_id[3] = i4;
+  e->data_id[4] = i5;
+  e->data_id[5] = i6;
+  tls_latseq.i_write_head++;
+}
+
+
+static __inline__ void log_measure7(const char * point, const char *fmt, uint32_t i1, uint32_t i2, uint32_t i3, uint32_t i4, uint32_t i5, uint32_t i6, uint32_t i7)
+{
+  if (tls_latseq.th_latseq_id == 0) {
+    //is not initialized yet
+    if (init_thread_for_latseq()) {
+      return;
+    }
+  }
+  latseq_element_t * e = &tls_latseq.log_buffer[tls_latseq.i_write_head%RING_BUFFER_SIZE];
+  e->ts = l_rdtsc();
+  e->point = point;
+  e->format = fmt;
+  e->len_id = 7;
+  e->data_id[0] = i1;
+  e->data_id[1] = i2;
+  e->data_id[2] = i3;
+  e->data_id[3] = i4;
+  e->data_id[4] = i5;
+  e->data_id[5] = i6;
+  e->data_id[6] = i7;
+  tls_latseq.i_write_head++;
+}
+
+
+static __inline__ void log_measure8(const char * point, const char *fmt, uint32_t i1, uint32_t i2, uint32_t i3, uint32_t i4, uint32_t i5, uint32_t i6, uint32_t i7, uint32_t i8)
+{
+  if (tls_latseq.th_latseq_id == 0) {
+    //is not initialized yet
+    if (init_thread_for_latseq()) {
+      return;
+    }
+  }
+  latseq_element_t * e = &tls_latseq.log_buffer[tls_latseq.i_write_head%RING_BUFFER_SIZE];
+  e->ts = l_rdtsc();
+  e->point = point;
+  e->format = fmt;
+  e->len_id = 8;
+  e->data_id[0] = i1;
+  e->data_id[1] = i2;
+  e->data_id[2] = i3;
+  e->data_id[3] = i4;
+  e->data_id[4] = i5;
+  e->data_id[5] = i6;
+  e->data_id[6] = i7;
+  e->data_id[7] = i8;
+  tls_latseq.i_write_head++;
+}
+
+
+static __inline__ void log_measure9(const char * point, const char *fmt, uint32_t i1, uint32_t i2, uint32_t i3, uint32_t i4, uint32_t i5, uint32_t i6, uint32_t i7, uint32_t i8, uint32_t i9)
+{
+  if (tls_latseq.th_latseq_id == 0) {
+    //is not initialized yet
+    if (init_thread_for_latseq()) {
+      return;
+    }
+  }
+  latseq_element_t * e = &tls_latseq.log_buffer[tls_latseq.i_write_head%RING_BUFFER_SIZE];
+  e->ts = l_rdtsc();
+  e->point = point;
+  e->format = fmt;
+  e->len_id = 9;
+  e->data_id[0] = i1;
+  e->data_id[1] = i2;
+  e->data_id[2] = i3;
+  e->data_id[3] = i4;
+  e->data_id[4] = i5;
+  e->data_id[5] = i6;
+  e->data_id[6] = i7;
+  e->data_id[7] = i8;
+  e->data_id[8] = i9;
+  tls_latseq.i_write_head++;
+}
+
+
+static __inline__ void log_measure10(const char * point, const char *fmt, uint32_t i1, uint32_t i2, uint32_t i3, uint32_t i4, uint32_t i5, uint32_t i6, uint32_t i7, uint32_t i8, uint32_t i9, uint32_t i10)
+{
+  if (tls_latseq.th_latseq_id == 0) {
+    //is not initialized yet
+    if (init_thread_for_latseq()) {
+      return;
+    }
+  }
+  latseq_element_t * e = &tls_latseq.log_buffer[tls_latseq.i_write_head%RING_BUFFER_SIZE];
+  e->ts = l_rdtsc();
+  e->point = point;
+  e->format = fmt;
+  e->len_id = 10;
+  e->data_id[0] = i1;
+  e->data_id[1] = i2;
+  e->data_id[2] = i3;
+  e->data_id[3] = i4;
+  e->data_id[4] = i5;
+  e->data_id[5] = i6;
+  e->data_id[6] = i7;
+  e->data_id[7] = i8;
+  e->data_id[8] = i9;
+  e->data_id[9] = i10;
+  tls_latseq.i_write_head++;
+}
+
+/** \fn static int write_latseq_entry(void);
+ * \brief private function to write an entry in the log file
+*/
+//static int write_latseq_entry(void);
+
+/** \fn void log_to_file(void);
+ * \brief function to save buffer of logs into a file
+*/
+void latseq_log_to_file(void);
+
+/** \fn void fflush_latseq_periodically(void);
+ * \brief flush periodically into fprintf
+*/
+void fflush_latseq_periodically(void);
+
+/** \fn void latseq_print_stats(void);
+ * \brief print some stats about latseq
+*/
+void latseq_print_stats(void);
+
+/** \fn int close_latseq(void);
+ * \brief finish latseq measurement if a latseq is running
+ * \return 0 if error 1 otherwise
+*/
+int close_latseq(void);
+
+/*----------------------------------------------------------------------------*/
+
+#endif
diff --git a/common/utils/hashtable/hashtable.h b/common/utils/hashtable/hashtable.h
index 09f8623ce2..27002f609e 100644
--- a/common/utils/hashtable/hashtable.h
+++ b/common/utils/hashtable/hashtable.h
@@ -37,6 +37,7 @@ typedef enum hashtable_return_code_e {
   HASH_TABLE_KEY_ALREADY_EXISTS      = 3,
   HASH_TABLE_BAD_PARAMETER_HASHTABLE = 4,
   HASH_TABLE_SYSTEM_ERROR            = 5,
+  HASH_TABLE_NONE                    = 6,
   HASH_TABLE_CODE_MAX
 } hashtable_rc_t;
 
diff --git a/executables/main-ocp.c b/executables/main-ocp.c
index c9388e179d..b8ee7d7a10 100644
--- a/executables/main-ocp.c
+++ b/executables/main-ocp.c
@@ -64,6 +64,10 @@ static int DEFENBS[] = {0};
 #include <openair2/LAYER2/MAC/mac_vars.h>
 #include <openair2/RRC/LTE/rrc_vars.h>
 
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 pthread_cond_t nfapi_sync_cond;
 pthread_mutex_t nfapi_sync_mutex;
 int nfapi_sync_var=-1; //!< protected by mutex \ref nfapi_sync_mutex
@@ -677,7 +681,7 @@ void rx_rf(RU_t *ru, L1_rxtx_proc_t *proc) {
     exit_fun("Exiting IQ record/playback");
 #else
     //exit_fun( "problem receiving samples" );
-    LOG_E(PHY, "problem receiving samples");
+    LOG_E(PHY, "problem receiving samples\n");
 #endif
   }
 
@@ -689,6 +693,11 @@ void rx_rf(RU_t *ru, L1_rxtx_proc_t *proc) {
 
   old_ts=timestamp_rx;
   setAllfromTS(timestamp_rx, proc);
+
+#if LATSEQ
+  LATSEQ_P("U phy.in.ant--phy.in.proc","len%d::fm%d.subfm%d", rxs, proc->frame_rx, proc->subframe_rx);
+#endif
+
 }
 
 void ocp_tx_rf(RU_t *ru, L1_rxtx_proc_t *proc) {
@@ -734,6 +743,11 @@ void ocp_tx_rf(RU_t *ru, L1_rxtx_proc_t *proc) {
     sf_extension = (sf_extension)&0xfffffffc;
 #endif
 
+#if LATSEQ
+    LATSEQ_P("D phy.out.proc--phy.out.ant","len%d::fm%d.subfm%d",siglen, proc->frame_tx, proc->subframe_tx);
+#endif
+
+
     for (i=0; i<ru->nb_tx; i++)
       txp[i] = (void *)&ru->common.txdata[i][(proc->subframe_tx*fp->samples_per_tti)-sf_extension];
 
@@ -1038,18 +1052,17 @@ void set_default_frame_parms(LTE_DL_FRAME_PARMS *frame_parms[MAX_NUM_CCs]) {
 
 void init_pdcp(void) {
   if (!NODE_IS_DU(RC.rrc[0]->node_type)) {
-    pdcp_layer_init();
+    pdcp_layer_init();  //gdb
     uint32_t pdcp_initmask = (IS_SOFTMODEM_NOS1) ?
                              (PDCP_USE_NETLINK_BIT | LINK_ENB_PDCP_TO_IP_DRIVER_BIT) : LINK_ENB_PDCP_TO_GTPV1U_BIT;
 
-    if (IS_SOFTMODEM_NOS1)
+    if (IS_SOFTMODEM_NOS1)  //gdb
       pdcp_initmask = pdcp_initmask | ENB_NAS_USE_TUN_BIT | SOFTMODEM_NOKRNMOD_BIT  ;
 
     pdcp_initmask = pdcp_initmask | ENB_NAS_USE_TUN_W_MBMS_BIT;
 
     if ( split73!=SPLIT73_DU)
       pdcp_module_init(pdcp_initmask, 0);
-
     if (NODE_IS_CU(RC.rrc[0]->node_type)) {
       //pdcp_set_rlc_data_req_func(proto_agent_send_rlc_data_req);
     } else {
@@ -1154,7 +1167,9 @@ int main ( int argc, char **argv ) {
   set_softmodem_sighandler();
   cpuf=get_cpu_freq_GHz();
   set_taus_seed (0);
-
+#if LATSEQ
+  init_latseq("/tmp/main_ocp", (uint64_t)(cpuf*1000000000LL));
+#endif
   if (opp_enabled ==1)
     reset_opp_meas();
 
@@ -1338,6 +1353,9 @@ int main ( int argc, char **argv ) {
   oai_exit=1;
   LOG_I(ENB_APP,"oai_exit=%d\n",oai_exit);
   // stop threads
+  #if LATSEQ
+    close_latseq(); //close before end of threads
+  #endif
 
   if (RC.nb_inst == 0 || !NODE_IS_CU(node_type)) {
     if(IS_SOFTMODEM_DOSCOPE)
diff --git a/executables/nr-softmodem.c b/executables/nr-softmodem.c
index 54345dc6b0..11c33a5f60 100644
--- a/executables/nr-softmodem.c
+++ b/executables/nr-softmodem.c
@@ -61,6 +61,9 @@ unsigned short config_frames[4] = {2,9,11,13};
 #include "common/utils/LOG/log.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
 #include "UTIL/OPT/opt.h"
+#if LATSEQ
+  "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "intertask_interface.h"
 
@@ -651,7 +654,12 @@ int main( int argc, char **argv ) {
   }
 
   cpuf=get_cpu_freq_GHz();
+
+#if LATSEQ
+  init_latseq("/tmp/nr_softmodem", (uint64_t)(cpuf*1000000000LL));
+#endif
   itti_init(TASK_MAX, tasks_info);
+
   // initialize mscgen log after ITTI
   init_opt();
   if(PDCP_USE_NETLINK && !IS_SOFTMODEM_NOS1) {
@@ -823,6 +831,9 @@ int main( int argc, char **argv ) {
       }
 
   #endif*/
+  #if LATSEQ
+    close_latseq(); //close befire head of threads
+  #endif
   printf("stopping MODEM threads\n");
   // cleanup
   stop_gNB(NB_gNB_INST);
diff --git a/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c b/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c
index 3ccbd8ca35..80360c595a 100644
--- a/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c
+++ b/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c
@@ -40,6 +40,9 @@
 #include "SCHED/sched_eNB.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 #include "targets/RT/USER/lte-softmodem.h"
 #include <syscall.h>
 #include <common/utils/threadPool/thread-pool.h>
@@ -373,8 +376,16 @@ int dlsch_encoding(PHY_VARS_eNB *eNB,
     //    printf("CRC %x (A %d)\n",crc,A);
     hadlsch->B = A+24;
     //    hadlsch->b = a;
+    // LATSEQ
+/*
+#if LATSEQ
+    LATSEQ_P_TEST("D mac.txreq--mac.harq","rnti%d:harq%d.fm%d.subfm%d",dlsch->rnti, harq_pid, frame, subframe);
+#endif
+*/
+
+    // END_LATSEQ
     memcpy(hadlsch->b,a,(A/8)+4);
-    
+
     if (lte_segmentation(hadlsch->b,
                          hadlsch->c,
                          hadlsch->B,
diff --git a/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c b/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c
index fceff580a3..36c27df3e2 100644
--- a/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c
+++ b/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c
@@ -43,6 +43,10 @@
 #include "transport_proto.h"
 #include <executables/split_headers.h>
 
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 extern WORKER_CONF_t get_thread_worker_conf(void);
 extern volatile int oai_exit;
 
@@ -357,6 +361,9 @@ int ulsch_decoding_data(PHY_VARS_eNB *eNB, L1_rxtx_proc_t *proc,
     int sz=Kr_bytes - Fbytes - ((ulsch_harq->C>1)?3:0);
     pushTpool(proc->threadPool,req);
     proc->nbDecode++;
+#if LATSEQ
+    LATSEQ_P("U phy.in.proc--mac.harq.up", "len%d::ue%d.cbseg%d.fm%d.subfm%d", sz, rdata->UEid, r, rdata->frame, rdata->subframe);
+#endif
     LOG_D(PHY,"Added a block to decode, in pipe: %d\n",proc->nbDecode);
     r_offset+=E;
     offset+=sz;	    
diff --git a/openair1/PHY/phy_extern_ue.h b/openair1/PHY/phy_extern_ue.h
index cff03e375d..2daa47921e 100644
--- a/openair1/PHY/phy_extern_ue.h
+++ b/openair1/PHY/phy_extern_ue.h
@@ -35,8 +35,8 @@ extern unsigned int TX_DMA_BUFFER[4][NB_ANTENNAS_TX];
 
 extern int number_of_cards;
 
-extern const short conjugate[8],conjugate2[8];
 
+extern const short conjugate[8],conjugate2[8];
 
 extern PHY_VARS_UE ***PHY_vars_UE_g;
 
diff --git a/openair1/SCHED/fapi_l1.c b/openair1/SCHED/fapi_l1.c
index ecfec02193..2b35ffaf30 100644
--- a/openair1/SCHED/fapi_l1.c
+++ b/openair1/SCHED/fapi_l1.c
@@ -37,6 +37,9 @@
 #include "nfapi/oai_integration/vendor_ext.h"
 #include "nfapi_pnf_interface.h"
 #include "fapi_l1.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "common/ran_context.h"
 extern RAN_CONTEXT_t RC;
@@ -231,6 +234,12 @@ void handle_nfapi_dlsch_pdu(PHY_VARS_eNB *eNB,int frame,int subframe,L1_rxtx_pro
     LOG_E(PHY,"illegal harq_pid %d %s:%d\n", harq_pid, __FILE__, __LINE__);
     return;
   }
+#if LATSEQ
+  if (rel8->rnti != 0xFFFF) {
+    uint16_t sfn_sf = (uint16_t)((frame << 4 ) | subframe);
+    LATSEQ_P("D mac.txreq--mac.harq.down", "len%d:rnti%d:txreq%d.harq%d.sfn%d", rel8->length, rel8->rnti, rel8->pdu_index, harq_pid, sfn_sf);
+  }
+#endif
 
   dlsch0_harq     = dlsch0->harq_processes[harq_pid];
   dlsch1_harq     = dlsch1->harq_processes[harq_pid];
diff --git a/openair1/SCHED/phy_procedures_lte_eNb.c b/openair1/SCHED/phy_procedures_lte_eNb.c
index 1a35f6ee68..6d36db4aa8 100644
--- a/openair1/SCHED/phy_procedures_lte_eNb.c
+++ b/openair1/SCHED/phy_procedures_lte_eNb.c
@@ -41,6 +41,9 @@
 #include <common/utils/system.h>
 #include "common/utils/LOG/vcd_signal_dumper.h"
 #include <nfapi/oai_integration/nfapi_pnf.h>
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "assertions.h"
 
@@ -682,6 +685,13 @@ void phy_procedures_eNB_TX(PHY_VARS_eNB *eNB,
                 dlsch0->harq_ids[frame%2][6],
                 dlsch0->harq_ids[frame%2][7]);
       } else {
+
+#if LATSEQ
+//dci is always 1
+        if(dlsch0->rnti != 0xFFFF)  // Corresponds to a broadcast rnti
+          LATSEQ_P("D mac.harq.down--phy.out.proc","len%d:rnti%d:harq%d.fm%d.subfm%d", dlsch0->harq_processes[harq_pid]->TBS/8,dlsch0->rnti, harq_pid, frame, subframe);
+#endif
+
         if (dlsch_procedures(eNB,
                              proc,
                              harq_pid,
@@ -1317,15 +1327,13 @@ void postDecode(L1_rxtx_proc_t *proc, notifiedFIFO_elt_t *req) {
   bool decodeSucess=rdata->decodeIterations <= rdata->maxIterations;
   ulsch_harq->processedSegments++;
   LOG_D(PHY, "processing result of segment: %d, ue %d, processed %d/%d\n",
-	rdata->segment_r, rdata->UEid, ulsch_harq->processedSegments, rdata->nbSegments);
+    rdata->segment_r, rdata->UEid, ulsch_harq->processedSegments, rdata->nbSegments);
   proc->nbDecode--;
   LOG_D(PHY,"remain to decoded in subframe: %d\n", proc->nbDecode);
-  if (decodeSucess)  {
+  if (decodeSucess) {
     int Fbytes=(rdata->segment_r==0) ? rdata->Fbits>>3 : 0;
     int sz=(rdata->Kr>>3) - Fbytes - ((ulsch_harq->C>1)?3:0);
-    memcpy(ulsch_harq->decodedBytes+rdata->offset,
-	   rdata->decoded_bytes+Fbytes,
-	   sz);
+    memcpy(ulsch_harq->decodedBytes+rdata->offset, rdata->decoded_bytes+Fbytes, sz);
   } else {
     if ( rdata->nbSegments != ulsch_harq->processedSegments ) {
       int nb=abortTpool(proc->threadPool, req->key);
@@ -1333,76 +1341,82 @@ void postDecode(L1_rxtx_proc_t *proc, notifiedFIFO_elt_t *req) {
       proc->nbDecode-=nb;
       LOG_D(PHY,"uplink segment error %d/%d, aborted %d segments\n",rdata->segment_r,rdata->nbSegments, nb);
       AssertFatal(ulsch_harq->processedSegments+nb == rdata->nbSegments,"processed: %d, aborted: %d, total %d\n",
-		  ulsch_harq->processedSegments, nb, rdata->nbSegments);
+      ulsch_harq->processedSegments, nb, rdata->nbSegments);
       ulsch_harq->processedSegments=rdata->nbSegments;
     }
   }
 
   // if this UE segments are all done
   if ( rdata->nbSegments == ulsch_harq->processedSegments) {
-      //compute the expected ULSCH RX power (for the stats)
-      int i=rdata->UEid;
-      ulsch_harq->delta_TF = get_hundred_times_delta_IF_eNB(eNB,i,rdata->harq_pid, 0); // 0 means bw_factor is not considered
-      if (RC.mac != NULL) { /* ulsim does not use RC.mac context. */
-	if (ulsch_harq->cqi_crc_status == 1) {
-	  fill_ulsch_cqi_indication(eNB,rdata->frame,rdata->subframe,ulsch_harq,ulsch->rnti);
-	  RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
-	} else {
-	  if(RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag & (1 << rdata->subframe) ) {
-	    RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
-	    RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_timer=30;
-	    LOG_D(PHY,"Frame %d,Subframe %d, We're supposed to get a cqi here. Set cqi_req_timer to 30.\n",rdata->frame,rdata->subframe);
-	  }
-	}
+    //compute the expected ULSCH RX power (for the stats)
+    int i=rdata->UEid;
+    ulsch_harq->delta_TF = get_hundred_times_delta_IF_eNB(eNB,i,rdata->harq_pid, 0); // 0 means bw_factor is not considered
+    if (RC.mac != NULL) { /* ulsim does not use RC.mac context. */
+      if (ulsch_harq->cqi_crc_status == 1) {
+        fill_ulsch_cqi_indication(eNB,rdata->frame,rdata->subframe,ulsch_harq,ulsch->rnti);
+        RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
+      } else {
+        if(RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag & (1 << rdata->subframe) ) {
+          RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
+          RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_timer=30;
+          LOG_D(PHY,"Frame %d,Subframe %d, We're supposed to get a cqi here. Set cqi_req_timer to 30.\n",rdata->frame,rdata->subframe);
+        }
       }
-	
-      if (!decodeSucess) {
-        T(T_ENB_PHY_ULSCH_UE_NACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti),
-          T_INT(rdata->harq_pid));
-	fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,1); // indicate NAK to MAC
-	fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
-	LOG_D(PHY,"[eNB %d][PUSCH %d] frame %d subframe %d UE %d Error receiving ULSCH, round %d/%d (ACK %d,%d)\n",
-	      eNB->Mod_id,rdata->harq_pid,
-	      rdata->frame,rdata->subframe, i,
-	      ulsch_harq->round,
-	      ulsch->Mlimit,
-	      ulsch_harq->o_ACK[0],
-	      ulsch_harq->o_ACK[1]);
-	  
-	if (ulsch_harq->round >= 3)  {
-	  ulsch_harq->status  = SCH_IDLE;
-	  ulsch_harq->handled = 0;
-	  ulsch->harq_mask   &= ~(1 << rdata->harq_pid);
-	  ulsch_harq->round   = 0;
-	}
-	/* Mark the HARQ process to release it later if max transmission reached
-	 * (see below).
-	 * MAC does not send the max transmission count, we have to deal with it
-	 * locally in PHY.
-	 */
-	ulsch_harq->handled = 1;
-      }  // ulsch in error
-      else if(ulsch_harq->repetition_number == ulsch_harq->total_number_of_repetitions){
-	fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,0); // indicate ACK to MAC
-	fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
-	ulsch_harq->status = SCH_IDLE;
-	ulsch->harq_mask &= ~(1 << rdata->harq_pid);
-	for (int j=0;j<NUMBER_OF_ULSCH_MAX;j++) 
-           if (eNB->ulsch_stats[j].rnti == ulsch->rnti) {
-              eNB->ulsch_stats[j].total_bytes_rx+=ulsch_harq->TBS;
-              for (int aa=0;aa<eNB->frame_parms.nb_antennas_rx;aa++) {
-                eNB->ulsch_stats[j].ulsch_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_power[aa]);
-                eNB->ulsch_stats[j].ulsch_noise_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_noise_power[aa]); 
-              }
-              break;
-           }
-        T (T_ENB_PHY_ULSCH_UE_ACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti),
-           T_INT(rdata->harq_pid));
-      }  // ulsch not in error
-	
-      if (ulsch_harq->O_ACK>0)
-	fill_ulsch_harq_indication(eNB,ulsch_harq,ulsch->rnti,rdata->frame,rdata->subframe,ulsch->bundling);
-  } 
+    }
+
+    if (!decodeSucess) {
+      T(T_ENB_PHY_ULSCH_UE_NACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti), T_INT(rdata->harq_pid));
+#if LATSEQ
+      LATSEQ_P("I mac.harq.up", "nack%d:ue%d:harq%d.fm%d.subfm%d", ulsch_harq->round, rdata->UEid, rdata->harq_pid, rdata->frame, rdata->subframe);
+#endif
+      fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,1); // indicate NAK to MAC
+      fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
+
+      LOG_D(PHY,"[eNB %d][PUSCH %d] frame %d subframe %d UE %d Error receiving ULSCH, round %d/%d (ACK %d,%d)\n",
+            eNB->Mod_id,rdata->harq_pid,
+            rdata->frame,rdata->subframe, i,
+            ulsch_harq->round,
+            ulsch->Mlimit,
+            ulsch_harq->o_ACK[0],
+            ulsch_harq->o_ACK[1]);
+        
+      if (ulsch_harq->round >= 3)  {
+        ulsch_harq->status  = SCH_IDLE;
+        ulsch_harq->handled = 0;
+        ulsch->harq_mask   &= ~(1 << rdata->harq_pid);
+        ulsch_harq->round   = 0;
+      }
+      /* Mark the HARQ process to release it later if max transmission reached
+        * (see below).
+        * MAC does not send the max transmission count, we have to deal with it
+        * locally in PHY.
+        */
+      ulsch_harq->handled = 1;
+    }  // ulsch in error
+    else if(ulsch_harq->repetition_number == ulsch_harq->total_number_of_repetitions) {
+#if LATSEQ
+      LATSEQ_P("I mac.harq.up", "nack%d:ue%d:harq%d.fm%d.subfm%d", 0, rdata->UEid, rdata->harq_pid, rdata->frame, rdata->subframe);
+#endif
+      fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,0); // indicate ACK to MAC
+      fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
+      ulsch_harq->status = SCH_IDLE;
+      ulsch->harq_mask &= ~(1 << rdata->harq_pid);
+      for (int j=0;j<NUMBER_OF_ULSCH_MAX;j++) {
+        if (eNB->ulsch_stats[j].rnti == ulsch->rnti) {
+          eNB->ulsch_stats[j].total_bytes_rx+=ulsch_harq->TBS;
+          for (int aa=0;aa<eNB->frame_parms.nb_antennas_rx;aa++) {
+            eNB->ulsch_stats[j].ulsch_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_power[aa]);
+            eNB->ulsch_stats[j].ulsch_noise_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_noise_power[aa]); 
+          }
+          break;
+        }
+      }
+      T (T_ENB_PHY_ULSCH_UE_ACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti), T_INT(rdata->harq_pid));
+    }  // ulsch not in error
+
+    if (ulsch_harq->O_ACK>0)
+      fill_ulsch_harq_indication(eNB,ulsch_harq,ulsch->rnti,rdata->frame,rdata->subframe,ulsch->bundling);
+  }
 }
 
 void pusch_procedures(PHY_VARS_eNB *eNB,L1_rxtx_proc_t *proc) {
@@ -1498,13 +1512,20 @@ void pusch_procedures(PHY_VARS_eNB *eNB,L1_rxtx_proc_t *proc) {
       ulsch->harq_mask &= ~(1 << harq_pid);
       LOG_W (PHY, "Removing stale ULSCH config for UE %x harq_pid %d (harq_mask is now 0x%2.2x)\n", ulsch->rnti, harq_pid, ulsch->harq_mask);
     }
+/*
+#if LATSEQ
+    LATSEQ_P_TEST("U phy.in.proc--mac.demux","ue%d.rnti%d.fm%d:harq%d.round%d.subfm%d",i, ulsch->rnti, frame, harq_pid, ulsch_harq->round, subframe);
+#endif
+*/
   }   //   for (i=0; i<NUMBER_OF_ULSCH_MAX; i++)
+
   
   while (proc->nbDecode > 0) {
     notifiedFIFO_elt_t *req=pullTpool(proc->respDecode, proc->threadPool);
     postDecode(proc, req);
     delNotifiedFIFO_elt(req);
   }
+
 }
 
 extern int      oai_exit;
diff --git a/openair2/COMMON/gtpv1_u_messages_types.h b/openair2/COMMON/gtpv1_u_messages_types.h
index 096f0f4697..29884d5c0f 100644
--- a/openair2/COMMON/gtpv1_u_messages_types.h
+++ b/openair2/COMMON/gtpv1_u_messages_types.h
@@ -120,6 +120,7 @@ typedef struct gtpv1u_enb_tunnel_data_req_s {
   uint32_t               offset;               ///< start of message offset in buffer
   rnti_t                 rnti;
   rb_id_t                rab_id;
+  uint32_t               seqnum;
 } gtpv1u_enb_tunnel_data_req_t;
 
 typedef struct gtpv1u_enb_data_forwarding_req_s {
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c b/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c
index 596d978a98..fe7fdd99d6 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c
@@ -58,6 +58,9 @@
 #include <dlfcn.h>
 
 #include "T.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #define ENABLE_MAC_PAYLOAD_DEBUG
 //#define DEBUG_eNB_SCHEDULER 1
@@ -753,7 +756,6 @@ schedule_ue_spec(module_id_t module_idP,
                   round_DL,
                   ue_template->oldmcs1[harq_pid]);
           }
-
           dl_req->tl.tag = NFAPI_DL_CONFIG_REQUEST_BODY_TAG;
           eNB->DL_req[CC_id].sfn_sf = frameP<<4 | subframeP;
           eNB->DL_req[CC_id].header.message_id = NFAPI_DL_CONFIG_REQUEST;
@@ -947,6 +949,9 @@ schedule_ue_spec(module_id_t module_idP,
 
         LOG_D(MAC, "dlsch_mcs before and after the rate matching = (%d, %d), TBS %d, nb_rb %d\n",
               eNB_UE_stats->dlsch_mcs1, mcs, TBS, nb_rb);
+#if LATSEQ
+        LATSEQ_P("I mac.sched.down", "mcs%d.tbs%d.nrb%d:rnti%d:lcid%d", eNB_UE_stats->dlsch_mcs1, TBS, nb_rb, rnti, sdu_lcids[0]);
+#endif
 
         int post_padding = TBS - header_length_total - sdu_length_total - ta_len > 2;
         int padding = post_padding ? 0 : TBS - header_length_total - sdu_length_total - ta_len;
@@ -1186,6 +1191,9 @@ schedule_ue_spec(module_id_t module_idP,
                                     dlsch_pdu->payload[0]);
         LOG_D(MAC, "Filled NFAPI configuration for DCI/DLSCH/TXREQ %d, new SDU\n",
               eNB->pdu_index[CC_id]);
+#if LATSEQ
+        LATSEQ_P("D mac.mux--mac.txreq","len%d:rnti%d:lcid%d.txreq%d.reqfm%d.harq%d.sfn%d", TBS, rnti, sdu_lcids[0], eNB->pdu_index[CC_id], frameP, harq_pid, eNB->TX_req[CC_id].sfn_sf);
+#endif
         eNB->pdu_index[CC_id]++;
         program_dlsch_acknak(module_idP,
                              CC_id,
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c b/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c
index 6c9ffabd4f..9e85ad47d7 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c
@@ -49,6 +49,9 @@
 #include "rlc.h"
 #include "common/utils/lte/prach_utils.h"
 #include "T.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 
 #ifdef PHY_TX_THREAD
@@ -2079,6 +2082,9 @@ schedule_ue_spec_fairRR(module_id_t module_idP,
                                     0, //number of PRBs treated as one subband, not used here
                                     0 // number of beamforming vectors, not used here
                                    );
+#if LATSEQ
+            LATSEQ_P("D mac.mux--mac.txreq","len%d:rnti%d:lcid%d.txreq%d.reqfm%d.harq%d.sfn%d", TBS, rnti, sdu_lcids[0], eNB->pdu_index[CC_id], frameP, harq_pid, eNB->TX_req[CC_id].sfn_sf);
+#endif
             dl_req->number_pdu++;
             eNB->TX_req[CC_id].sfn_sf = fill_nfapi_tx_req(&eNB->TX_req[CC_id].tx_request_body,
                                         (frameP*10)+subframeP,
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_mch.c b/openair2/LAYER2/MAC/eNB_scheduler_mch.c
index 1272b16ec0..726da282f9 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_mch.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_mch.c
@@ -48,7 +48,7 @@
 #include "pdcp.h"
 #include "assertions.h"
 
-#include "SIMULATION/TOOLS/sim.h"	// for taus
+#include "SIMULATION/TOOLS/sim.h"  // for taus
 
 #define ENABLE_MAC_PAYLOAD_DEBUG
 #define DEBUG_eNB_SCHEDULER 1
@@ -58,27 +58,27 @@ extern RAN_CONTEXT_t RC;
 
 int8_t
 get_mbsfn_sf_alloction(module_id_t module_idP, uint8_t CC_id,
-		       uint8_t mbsfn_sync_area)
+           uint8_t mbsfn_sync_area)
 {
     // currently there is one-to-one mapping between sf allocation pattern and sync area
     if (mbsfn_sync_area > MAX_MBSFN_AREA) {
-	LOG_W(MAC,
-	      "[eNB %d] CC_id %d MBSFN synchronization area %d out of range\n ",
-	      module_idP, CC_id, mbsfn_sync_area);
-	return -1;
+  LOG_W(MAC,
+        "[eNB %d] CC_id %d MBSFN synchronization area %d out of range\n ",
+        module_idP, CC_id, mbsfn_sync_area);
+  return -1;
     }else if (RC.mac[module_idP]->
-	       common_channels[CC_id].non_mbsfn_SubframeConfig
-	       != NULL) {
-	return mbsfn_sync_area;
+         common_channels[CC_id].non_mbsfn_SubframeConfig
+         != NULL) {
+  return mbsfn_sync_area;
     }else if (RC.mac[module_idP]->
-	       common_channels[CC_id].mbsfn_SubframeConfig[mbsfn_sync_area]
-	       != NULL) {
-	return mbsfn_sync_area;
+         common_channels[CC_id].mbsfn_SubframeConfig[mbsfn_sync_area]
+         != NULL) {
+  return mbsfn_sync_area;
     } else {
-	LOG_W(MAC,
-	      "[eNB %d] CC_id %d MBSFN Subframe Config pattern %d not found \n ",
-	      module_idP, CC_id, mbsfn_sync_area);
-	return -1;
+  LOG_W(MAC,
+        "[eNB %d] CC_id %d MBSFN Subframe Config pattern %d not found \n ",
+        module_idP, CC_id, mbsfn_sync_area);
+  return -1;
     }
 }
 
@@ -92,14 +92,14 @@ static uint32_t msi_sfs=0;
 
 static int check_CAS_sf(frame_t frameP,sub_frame_t subframeP){
    if( ((frameP&3)==0) && (subframeP == 0))
-	return 1;	
+  return 1;  
    else 
-   	return 0;
+     return 0;
 }
 static int check_nonMBSFN_sf(frame_t frameP,COMMON_channels_t *cc,int sf){
-   uint32_t non_mbsfn_SubframeConfig = (cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]<<1 | cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]>>7);	
+   uint32_t non_mbsfn_SubframeConfig = (cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]<<1 | cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]>>7);  
    if( frameP % (4<<cc->non_mbsfn_SubframeConfig->radioFrameAllocationPeriod_r14) == cc->non_mbsfn_SubframeConfig->radioFrameAllocationOffset_r14 ){
-	return (non_mbsfn_SubframeConfig & (0x200>>(sf)))==(0x200 >> (sf));
+  return (non_mbsfn_SubframeConfig & (0x200>>(sf)))==(0x200 >> (sf));
    }
    return 0;
 }
@@ -110,29 +110,29 @@ static int mbms_mch_i=0;
 
 int
 schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
-	      sub_frame_t subframeP)
+        sub_frame_t subframeP)
 {
 
     nfapi_dl_config_request_body_t *dl_req;
     //nfapi_dl_config_request_pdu_t *dl_config_pdu;
     
     int mcch_flag = 0, mtch_flag = 0, msi_flag = 0;
-    int mbsfn_period = 0;	// 1<<(RC.mac[module_idP]->mbsfn_SubframeConfig[0]->radioframeAllocationPeriod);
-    int mcch_period = 0;	//32<<(RC.mac[module_idP]->mbsfn_AreaInfo[0]->mcch_Config_r9.mcch_RepetitionPeriod_r9);
+    int mbsfn_period = 0;  // 1<<(RC.mac[module_idP]->mbsfn_SubframeConfig[0]->radioframeAllocationPeriod);
+    int mcch_period = 0;  //32<<(RC.mac[module_idP]->mbsfn_AreaInfo[0]->mcch_Config_r9.mcch_RepetitionPeriod_r9);
     //TOCHECK mtch index here
     if(RC.mac[module_idP]->common_channels[CC_id].
               pmch_Config[0] == NULL )
-	return 0;
+  return 0;
 
     //TOCHECK mtch index here
     int mch_scheduling_period =
-	8 << (RC.mac[module_idP]->common_channels[CC_id].
-	      pmch_Config[0]->mch_SchedulingPeriod_r9);
+  8 << (RC.mac[module_idP]->common_channels[CC_id].
+        pmch_Config[0]->mch_SchedulingPeriod_r9);
 
     unsigned char mcch_sdu_length;
     unsigned char header_len_mcch = 0, header_len_msi =
-	0, header_len_mtch = 0, header_len_mtch_temp =
-	0, header_len_mcch_temp = 0, header_len_msi_temp = 0;
+  0, header_len_mtch = 0, header_len_mtch_temp =
+  0, header_len_mcch_temp = 0, header_len_msi_temp = 0;
     int ii = 0, msi_pos = -1;
     int mcch_mcs = -1;
     int shifted_sf = 0;
@@ -143,23 +143,23 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
 
     unsigned char sdu_lcids[11], num_sdus = 0, offset = 0;
     uint16_t sdu_lengths[11], sdu_length_total = 0;
-    unsigned char mch_buffer[MAX_DLSCH_PAYLOAD_BYTES];	// check the max value, this is for dlsch only
+    unsigned char mch_buffer[MAX_DLSCH_PAYLOAD_BYTES];  // check the max value, this is for dlsch only
 
     COMMON_channels_t *cc = &RC.mac[module_idP]->common_channels[CC_id];
 
     cc->MCH_pdu.Pdu_size = 0;
 
     for (i = 0; i < cc->num_active_mbsfn_area; i++) {
-	// assume, that there is always a mapping
-	if ((j = get_mbsfn_sf_alloction(module_idP, CC_id, i)) == -1) {
-	    return 0;
-	}
+  // assume, that there is always a mapping
+  if ((j = get_mbsfn_sf_alloction(module_idP, CC_id, i)) == -1) {
+      return 0;
+  }
 
         if(cc->non_mbsfn_SubframeConfig){
             int alloc_offset=0;
             uint32_t period;
 
-            uint32_t non_mbsfn_SubframeConfig = (cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]<<1 | cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]>>7);	
+            uint32_t non_mbsfn_SubframeConfig = (cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]<<1 | cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]>>7);  
             long mcch_offset        = cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9;
 
             period = 4<<cc->non_mbsfn_SubframeConfig->radioFrameAllocationPeriod_r14;
@@ -168,77 +168,63 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
          
             // get the real MCS value
             switch (cc->mbsfn_AreaInfo[i]->mcch_Config_r9.signallingMCS_r9) {
-        	case 0:
-          	mcch_mcs = 2;
-          	break;
+          case 0:
+            mcch_mcs = 2;
+            break;
 
-        	case 1:
-          	mcch_mcs = 7;
-          	break;
+          case 1:
+            mcch_mcs = 7;
+            break;
 
-        	case 2:
-          	mcch_mcs = 13;
-          	break;
+          case 2:
+            mcch_mcs = 13;
+            break;
 
-        	case 3:
-          	mcch_mcs = 19;
-          	break;
+          case 3:
+            mcch_mcs = 19;
+            break;
             }
-	   	  
+         
             if (cc->pmch_Config[0]) {
-        		mch_scheduling_period = 8 << cc->pmch_Config[0]->mch_SchedulingPeriod_r9;
+            mch_scheduling_period = 8 << cc->pmch_Config[0]->mch_SchedulingPeriod_r9;
             }
 
            LOG_D(MAC,"frameP %d subframe %d period %d alloc_offset %d mcch_mcs %d mcch_period %d mcch_offset %ld buf %x mch_scheduling_period %d\n",frameP, subframeP, period, alloc_offset,mcch_mcs, mcch_period, mcch_offset,(cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0]),mch_scheduling_period);
-	//if( (frameP % (4 << cc->commonSF_AllocPeriod_r9) ) == 0 ){
-	//	   if((subframeP==0)){
-	//	   	x=0;
-	//	   	mbms_mch_i=0;
-	//	   }
-	//}
-            //if (frameP % (4 << cc->commonSF_AllocPeriod_r9 ) == 0) {
-	    //       if((subframeP==0)){
-	    //       	x=0;
-	    //       	mbms_mch_i=0;
-	    //       }
-	    //}
             if (cc->pmch_Config[0]) {
               //  Find the first subframe in this MCH to transmit MSI
               if (frameP % 1 == 0) {
                 if (frameP % mch_scheduling_period == 0) {
-		   msi_pos=0;
-		   if((frameP&3)==0)
-			msi_pos++;
-		   while((non_mbsfn_SubframeConfig & (0x100 >> msi_pos)) == (0x100>>msi_pos))
-			msi_pos++;
-		   mbms_mch_i=0;
-
-		   if((subframeP==0)){
-		   	x=0;
-		   	mbms_mch_i=0;
-		   }
-		 
-		}
+                  msi_pos=0;
+                  if((frameP&3)==0)
+                    msi_pos++;
+                  while((non_mbsfn_SubframeConfig & (0x100 >> msi_pos)) == (0x100>>msi_pos))
+                    msi_pos++;
+                  mbms_mch_i=0;
+
+                  if((subframeP==0)){
+                    x=0;
+                    mbms_mch_i=0;
+                  }
+                }
               }
             }
-
-	    if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9+shifted_sf){
-
-			shifted_sf = check_nonMBSFN_sf(frameP,cc,subframeP)+check_CAS_sf(frameP,subframeP);
-			msi_pos=subframeP+shifted_sf;
-			if(shifted_sf==0)
-				mbms_mch_i++;
-			LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d shifted_sf %d\n",frameP, subframeP, msi_pos,mbms_mch_i,shifted_sf);
-		}
-	    }
+      if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+    if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9+shifted_sf){
+
+      shifted_sf = check_nonMBSFN_sf(frameP,cc,subframeP)+check_CAS_sf(frameP,subframeP);
+      msi_pos=subframeP+shifted_sf;
+      if(shifted_sf==0)
+        mbms_mch_i++;
+      LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d shifted_sf %d\n",frameP, subframeP, msi_pos,mbms_mch_i,shifted_sf);
+    }
+      }
 
             // Check if the subframe is for MSI, MCCH or MTCHs and Set the correspoding flag to 1
             switch (subframeP) {
               case 0: 
-          	    if (msi_pos == 0) {
-            	      msi_flag = 1;
-          	    }
+                if (msi_pos == 0) {
+                    msi_flag = 1;
+                }
                       mtch_flag = 1;
                 break;
               case 1:
@@ -331,7 +317,7 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
                               msi_flag, mcch_flag, mtch_flag);
             }
 
-	    //TODO quitar la subframe 0 del otro switch ... está mal interpretado ? 
+      //TODO quitar la subframe 0 del otro switch ... está mal interpretado ? 
            // if((frameP&3) == 0){
            //            mtch_flag=0;mcch_flag=0;msi_flag=0;
            // }
@@ -344,73 +330,73 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
                     }
                   break;
                   case 1:{
-                  	if ((non_mbsfn_SubframeConfig & 0x100) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x100) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 2:{
-                  	if ((non_mbsfn_SubframeConfig & 0x80) > 0)
-                  	   {mtch_flag=0;mcch_flag=0;msi_flag=0;}
+                    if ((non_mbsfn_SubframeConfig & 0x80) > 0)
+                       {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 3:{
-                  	if ((non_mbsfn_SubframeConfig & 0x40) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x40) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 4:{
-                  	if ((non_mbsfn_SubframeConfig & 0x20) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x20) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 5:{
-                  	if ((non_mbsfn_SubframeConfig & 0x10) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x10) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 6:{
-                  	if ((non_mbsfn_SubframeConfig & 0x8) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x8) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 7:{
-                  	if ((non_mbsfn_SubframeConfig & 0x4) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x4) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 8:{
-                  	if ((non_mbsfn_SubframeConfig & 0x2) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x2) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 9:{
-                  	if ((non_mbsfn_SubframeConfig & 0x1) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x1) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                   }
                   break;
                }
             }
-	    // sf allocation is non-overlapping
+      // sf allocation is non-overlapping
             if ((msi_flag == 1) || (mcch_flag == 1) || (mtch_flag == 1)) {
-		  x++;
-		  //if( (msi_flag!=1 && mcch_flag!=1) || (msi_flag!=1 && mcch_flag!=1 && mtch_flag!=1)  ){
-		        	//x++;
-		  //}
-		 	
-		  if(msi_flag==1){
-		  	if ( (/*AJ*/ (/*V*/ ( /*U*/ (frameP %( 4 << cc->commonSF_AllocPeriod_r9)) ) / 8 ) % ((8 << cc->pmch_Config[mbms_mch_i]->mch_SchedulingPeriod_r9) / 8 ) ) != 0 ){
-				msi_flag=0;
-				LOG_D(MAC,"frameP %d subframeP %d reset(%d)\n",frameP, subframeP, mbms_mch_i);
-			}
-	        
-		  }
-
-	          LOG_D(MAC,"[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d, x %d\n",
+      x++;
+      //if( (msi_flag!=1 && mcch_flag!=1) || (msi_flag!=1 && mcch_flag!=1 && mtch_flag!=1)  ){
+              //x++;
+      //}
+       
+      if(msi_flag==1){
+        if ( (/*AJ*/ (/*V*/ ( /*U*/ (frameP %( 4 << cc->commonSF_AllocPeriod_r9)) ) / 8 ) % ((8 << cc->pmch_Config[mbms_mch_i]->mch_SchedulingPeriod_r9) / 8 ) ) != 0 ){
+        msi_flag=0;
+        LOG_D(MAC,"frameP %d subframeP %d reset(%d)\n",frameP, subframeP, mbms_mch_i);
+      }
+          
+      }
+
+            LOG_D(MAC,"[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d, x %d\n",
                   module_idP, CC_id, frameP, subframeP, i, j,
                    msi_flag, mcch_flag, mtch_flag,x);
                   break;
             }
-	   
+     
 
         }else if(cc->mbsfn_SubframeConfig[j]){
 
@@ -418,7 +404,7 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
                 1 << (cc->mbsfn_SubframeConfig[j]->radioframeAllocationPeriod);
             mcch_period =
                 32 << (cc->mbsfn_AreaInfo[i]->
-            	   mcch_Config_r9.mcch_RepetitionPeriod_r9);
+                 mcch_Config_r9.mcch_RepetitionPeriod_r9);
             msi_pos = 0;
             ii = 0;
             LOG_D(MAC, "[eNB %d] CC_id %d Frame %d subframeP %d : Checking MBSFN Sync Area %d/%d with SF allocation %d/%d for MCCH and MTCH (mbsfn period %d, mcch period %d)\n",
@@ -445,241 +431,241 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
             }
 
             // 1st: Check the MBSFN subframes from SIB2 info (SF allocation pattern i, max 8 non-overlapping patterns exist)
-            if (frameP % mbsfn_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {	// MBSFN frameP
-                if (cc->mbsfn_SubframeConfig[j]->subframeAllocation.present == LTE_MBSFN_SubframeConfig__subframeAllocation_PR_oneFrame) {	// one-frameP format
-            	     //  Find the first subframeP in this MCH to transmit MSI
-            	     if (frameP % mch_scheduling_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {
-            	         while (ii == 0) {
-            	     	ii = cc->
-            	     	    mbsfn_SubframeConfig[j]->subframeAllocation.
-            	     	    choice.oneFrame.buf[0] & (0x80 >> msi_pos);
-            	     	msi_pos++;
-            	         }
-            	         LOG_D(MAC, "[eNB %d] CC_id %d Frame %d subframeP %d : sync area %d sf allocation pattern %d sf alloc %x msi pos is %d \n",
-            	     	  module_idP, CC_id, frameP, subframeP, i, j,
-            	     	  cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0],
-            	     	  msi_pos);
-	 	         if((subframeP==1)){
-		        	x=0;
-		        	mbms_mch_i=0;
-	      	     	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		         }
-            	     }
-	       
-            	     // Check if the subframeP is for MSI, MCCH or MTCHs and Set the correspoding flag to 1
-            	     switch (subframeP) {
-            	     case 1:
-            	         if (cc->tdd_Config == NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF1) == MBSFN_FDD_SF1) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=1;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-            	     	    if (msi_pos == 1) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ( (frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&& ( (cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF1) == MBSFN_FDD_SF1) ) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 2:
-            	         if (cc->tdd_Config == NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF2) ==  MBSFN_FDD_SF2) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=2;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-
-            	     	    if (msi_pos == 2) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ( (frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&& ((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF2) ==  MBSFN_FDD_SF2)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 3:
-            	         if (cc->tdd_Config != NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF3) ==  MBSFN_TDD_SF3) {
-            	     	    if (msi_pos == 1) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF3) ==  MBSFN_TDD_SF3)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         } else {	// FDD
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF3) ==  MBSFN_FDD_SF3) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=3;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-            	     	    if (msi_pos == 3) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF3) == MBSFN_FDD_SF3)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 4:
-            	         if (cc->tdd_Config != NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF4) == MBSFN_TDD_SF4) {
-            	     	    if (msi_pos == 2) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF4) == MBSFN_TDD_SF4)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 6:
-            	         if (cc->tdd_Config == NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF6) ==  MBSFN_FDD_SF6) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=4;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-            	     	    if (msi_pos == 4) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF6) ==  MBSFN_FDD_SF6)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 7:
-            	         if (cc->tdd_Config != NULL) {	// TDD
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF7) == MBSFN_TDD_SF7) {
-            	     	    if (msi_pos == 3) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF7) ==  MBSFN_TDD_SF7)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         } else {	// FDD
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF7) == MBSFN_FDD_SF7) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=5;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-
-            	     	    if (msi_pos == 5) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF7) == MBSFN_FDD_SF7)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 8:
-            	         if (cc->tdd_Config != NULL) {	//TDD
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF8) == MBSFN_TDD_SF8) {
-            	     	    if (msi_pos == 4) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF8) == MBSFN_TDD_SF8)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         } else {	// FDD
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF8) ==  MBSFN_FDD_SF8) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=6;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-            	     	    if (msi_pos == 6) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF8) == MBSFN_FDD_SF8)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 9:
-            	         if (cc->tdd_Config != NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF9) ==  MBSFN_TDD_SF9) {
-            	     	    if (msi_pos == 5) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF9) == MBSFN_TDD_SF9)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     }	// end switch
-            	     // sf allocation is non-overlapping
-            	     if ((msi_flag == 1) || (mcch_flag == 1) || (mtch_flag == 1)) {
-		     	  x++;
-		         //if( (msi_flag!=1 && mcch_flag!=1) || (msi_flag!=1 && mcch_flag!=1 && mtch_flag!=1)  ){
-		     		//x++;
-		         //}
-			  if(msi_flag==1){
-			  	if ( (/*AJ*/ (/*V*/ ( /*U*/ (frameP %( 4 << cc->commonSF_AllocPeriod_r9)) ) / 8 ) % ((8 << cc->pmch_Config[mbms_mch_i]->mch_SchedulingPeriod_r9) / 8 ) ) != 0 ){
-					msi_flag=0;
-					LOG_D(MAC,"frameP %d subframeP %d reset(%d)\n",frameP, subframeP, mbms_mch_i);
-				}
-		        
-			  }
-
-            	         LOG_D(MAC,"[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d x %d\n",
-            	     	  module_idP, CC_id, frameP, subframeP, i, j,
-            	     	  msi_flag, mcch_flag, mtch_flag,x);
-            	         break;
-            	     }
+            if (frameP % mbsfn_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {  // MBSFN frameP
+                if (cc->mbsfn_SubframeConfig[j]->subframeAllocation.present == LTE_MBSFN_SubframeConfig__subframeAllocation_PR_oneFrame) {  // one-frameP format
+                   //  Find the first subframeP in this MCH to transmit MSI
+                   if (frameP % mch_scheduling_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {
+                       while (ii == 0) {
+                     ii = cc->
+                         mbsfn_SubframeConfig[j]->subframeAllocation.
+                         choice.oneFrame.buf[0] & (0x80 >> msi_pos);
+                     msi_pos++;
+                       }
+                       LOG_D(MAC, "[eNB %d] CC_id %d Frame %d subframeP %d : sync area %d sf allocation pattern %d sf alloc %x msi pos is %d \n",
+                       module_idP, CC_id, frameP, subframeP, i, j,
+                       cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0],
+                       msi_pos);
+              if((subframeP==1)){
+              x=0;
+              mbms_mch_i=0;
+                 LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+             }
+                   }
+         
+                   // Check if the subframeP is for MSI, MCCH or MTCHs and Set the correspoding flag to 1
+                   switch (subframeP) {
+                   case 1:
+                       if (cc->tdd_Config == NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF1) == MBSFN_FDD_SF1) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=1;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+                         if (msi_pos == 1) {
+                       msi_flag = 1;
+                         }
+                         if ( (frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       && ( (cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF1) == MBSFN_FDD_SF1) ) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 2:
+                       if (cc->tdd_Config == NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF2) ==  MBSFN_FDD_SF2) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=2;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+
+                         if (msi_pos == 2) {
+                       msi_flag = 1;
+                         }
+                         if ( (frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       && ((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF2) ==  MBSFN_FDD_SF2)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 3:
+                       if (cc->tdd_Config != NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF3) ==  MBSFN_TDD_SF3) {
+                         if (msi_pos == 1) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF3) ==  MBSFN_TDD_SF3)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       } else {  // FDD
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF3) ==  MBSFN_FDD_SF3) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=3;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+                         if (msi_pos == 3) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF3) == MBSFN_FDD_SF3)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 4:
+                       if (cc->tdd_Config != NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF4) == MBSFN_TDD_SF4) {
+                         if (msi_pos == 2) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF4) == MBSFN_TDD_SF4)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 6:
+                       if (cc->tdd_Config == NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF6) ==  MBSFN_FDD_SF6) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=4;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+                         if (msi_pos == 4) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF6) ==  MBSFN_FDD_SF6)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 7:
+                       if (cc->tdd_Config != NULL) {  // TDD
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF7) == MBSFN_TDD_SF7) {
+                         if (msi_pos == 3) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF7) ==  MBSFN_TDD_SF7)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       } else {  // FDD
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF7) == MBSFN_FDD_SF7) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=5;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+
+                         if (msi_pos == 5) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF7) == MBSFN_FDD_SF7)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 8:
+                       if (cc->tdd_Config != NULL) {  //TDD
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF8) == MBSFN_TDD_SF8) {
+                         if (msi_pos == 4) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF8) == MBSFN_TDD_SF8)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       } else {  // FDD
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF8) ==  MBSFN_FDD_SF8) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=6;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+                         if (msi_pos == 6) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF8) == MBSFN_FDD_SF8)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 9:
+                       if (cc->tdd_Config != NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF9) ==  MBSFN_TDD_SF9) {
+                         if (msi_pos == 5) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF9) == MBSFN_TDD_SF9)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   }  // end switch
+                   // sf allocation is non-overlapping
+                   if ((msi_flag == 1) || (mcch_flag == 1) || (mtch_flag == 1)) {
+             x++;
+             //if( (msi_flag!=1 && mcch_flag!=1) || (msi_flag!=1 && mcch_flag!=1 && mtch_flag!=1)  ){
+             //x++;
+             //}
+        if(msi_flag==1){
+          if ( (/*AJ*/ (/*V*/ ( /*U*/ (frameP %( 4 << cc->commonSF_AllocPeriod_r9)) ) / 8 ) % ((8 << cc->pmch_Config[mbms_mch_i]->mch_SchedulingPeriod_r9) / 8 ) ) != 0 ){
+          msi_flag=0;
+          LOG_D(MAC,"frameP %d subframeP %d reset(%d)\n",frameP, subframeP, mbms_mch_i);
+        }
+            
+        }
+
+                       LOG_D(MAC,"[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d x %d\n",
+                       module_idP, CC_id, frameP, subframeP, i, j,
+                       msi_flag, mcch_flag, mtch_flag,x);
+                       break;
+                   }
                 } else {// four-frameP format
-			 printf("Hola\n");
-			 AssertFatal(1==0,"four-frameP format: not implemented yet\n");
+       printf("Hola\n");
+       AssertFatal(1==0,"four-frameP format: not implemented yet\n");
                 }
             }
         } // MBMS format
@@ -691,9 +677,9 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
 
     // Calculate the mcs
     if ((msi_flag == 1) || (mcch_flag == 1)) {
-	cc->MCH_pdu.mcs = mcch_mcs;
-    } else if (mtch_flag == 1) {	// only MTCH in this subframeP
-	cc->MCH_pdu.mcs = cc->pmch_Config[mbms_mch_i]->dataMCS_r9;
+  cc->MCH_pdu.mcs = mcch_mcs;
+    } else if (mtch_flag == 1) {  // only MTCH in this subframeP
+  cc->MCH_pdu.mcs = cc->pmch_Config[mbms_mch_i]->dataMCS_r9;
     }
 
 
@@ -709,400 +695,400 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
     // MSI buffer pointer
     char *buffer_pointer=NULL;
     if (msi_flag == 1) {
-	// Create MSI here
-	msi_ptr = &msi_control_element[0];
-
-	//Header for MTCHs
-	num_mtch = cc->mbms_SessionList[mbms_mch_i]->list.count;
-
-    	TBS =
-	get_TBS_DL(cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
-	//l=0;
-
-	for (k = 0; k < num_mtch; k++) {	// loop for all session in this MCH (MCH[0]) at this moment
-
-	    ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[mbms_mch_i]->list.array[k]->logicalChannelIdentity_r9;	//mtch_lcid;
-
-	    if( msi_sfs != 0 )
-	    	msi_pmch_stop = msi_sfs-1;
-	    else 
-		msi_pmch_stop = msi_sfs;
-	
-    	    msi_pmch_stop = msi_sfs;
-
-	    if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
-	        ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = (((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) >> 8) & 0x7f);
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = ((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) & 0xff);
-		msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
-	    }else{
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;	// last subframeP of this mtch (only one mtch now)
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
-		msi_pmch_stop=0;
-	    }
-	    msi_ptr += sizeof(MSI_ELEMENT);
-	}
-
-	msi_length = msi_ptr - msi_control_element;
-
-	if (msi_length < 128) {
-	    header_len_msi = 2;
-	} else {
-	    header_len_msi = 3;
-	}
-
-	LOG_D(MAC, "[eNB %d] CC_id %d Frame %d : MSI->MCH, length of MSI is %d bytes TBS %d, bytes in buffer %d stop_sf_LSB %d msi_sfs %d cc->pmch_Config[0]->sf_AllocEnd_r9 %ld\n",
-	      module_idP, CC_id, frameP, msi_length,TBS, bytes_in_buffer,msi_pmch_stop,msi_sfs,cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
-	    
-	msi_sfs = 0;
-
-	// Store MSI data to mch_buffer[0]
-	memcpy((char *) &mch_buffer[sdu_length_total],
-	       msi_control_element, msi_length);
-
-	buffer_pointer = (char *) &mch_buffer[sdu_length_total];
-
-	sdu_lcids[num_sdus] = MCH_SCHDL_INFO;
-	sdu_lengths[num_sdus] = msi_length;
-	sdu_length_total += sdu_lengths[num_sdus];
-	LOG_D(MAC, "[eNB %d] CC_id %d Create %d bytes for MSI\n",
-	      module_idP, CC_id, sdu_lengths[num_sdus]);
-	num_sdus++;
-	cc->msi_active = 1;
+  // Create MSI here
+  msi_ptr = &msi_control_element[0];
+
+  //Header for MTCHs
+  num_mtch = cc->mbms_SessionList[mbms_mch_i]->list.count;
+
+      TBS =
+  get_TBS_DL(cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
+  //l=0;
+
+  for (k = 0; k < num_mtch; k++) {  // loop for all session in this MCH (MCH[0]) at this moment
+
+      ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[mbms_mch_i]->list.array[k]->logicalChannelIdentity_r9;  //mtch_lcid;
+
+      if( msi_sfs != 0 )
+        msi_pmch_stop = msi_sfs-1;
+      else 
+    msi_pmch_stop = msi_sfs;
+  
+          msi_pmch_stop = msi_sfs;
+
+      if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
+          ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = (((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) >> 8) & 0x7f);
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = ((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) & 0xff);
+    msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
+      }else{
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;  // last subframeP of this mtch (only one mtch now)
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
+    msi_pmch_stop=0;
+      }
+      msi_ptr += sizeof(MSI_ELEMENT);
+  }
+
+  msi_length = msi_ptr - msi_control_element;
+
+  if (msi_length < 128) {
+      header_len_msi = 2;
+  } else {
+      header_len_msi = 3;
+  }
+
+  LOG_D(MAC, "[eNB %d] CC_id %d Frame %d : MSI->MCH, length of MSI is %d bytes TBS %d, bytes in buffer %d stop_sf_LSB %d msi_sfs %d cc->pmch_Config[0]->sf_AllocEnd_r9 %ld\n",
+        module_idP, CC_id, frameP, msi_length,TBS, bytes_in_buffer,msi_pmch_stop,msi_sfs,cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
+      
+  msi_sfs = 0;
+
+  // Store MSI data to mch_buffer[0]
+  memcpy((char *) &mch_buffer[sdu_length_total],
+         msi_control_element, msi_length);
+
+  buffer_pointer = (char *) &mch_buffer[sdu_length_total];
+
+  sdu_lcids[num_sdus] = MCH_SCHDL_INFO;
+  sdu_lengths[num_sdus] = msi_length;
+  sdu_length_total += sdu_lengths[num_sdus];
+  LOG_D(MAC, "[eNB %d] CC_id %d Create %d bytes for MSI\n",
+        module_idP, CC_id, sdu_lengths[num_sdus]);
+  num_sdus++;
+  cc->msi_active = 1;
     }
     // there is MCCH
     if (mcch_flag == 1) {
-	//MCCH scheduling if !FeMBMS
-	if(!cc->non_mbsfn_SubframeConfig){
+  //MCCH scheduling if !FeMBMS
+  if(!cc->non_mbsfn_SubframeConfig){
           mcch_sdu_length = mac_rrc_data_req(module_idP, CC_id, frameP, MCCH_COUNTING, 0xFFFC, 1, &cc->MCCH_pdu.payload[0], 
-					 i);	// this is the mbsfn sync area index
-	  if(mcch_sdu_length>0)
-		LOG_I(MAC, "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE COUNTING (area %d, sfAlloc %d)\n",
-		  module_idP, CC_id, frameP, subframeP, i, j);
+           i);  // this is the mbsfn sync area index
+    if(mcch_sdu_length>0)
+    LOG_I(MAC, "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE COUNTING (area %d, sfAlloc %d)\n",
+      module_idP, CC_id, frameP, subframeP, i, j);
 
-	  if (mcch_sdu_length > 0) {
+    if (mcch_sdu_length > 0) {
               mcch_sdu_length+=1; //RLC ?
-	      LOG_D(MAC, "[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
-		    module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
-
-	      header_len_mcch = 2;
-
-	      if (cc->tdd_Config != NULL) {
-		  LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
-			module_idP, CC_id, frameP, subframeP,
-			mcch_sdu_length, mcch_mcs);
-	      } else {
-		  LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
-			module_idP, CC_id, frameP, subframeP,
-			mcch_sdu_length, mcch_mcs);
-	      }
-
-	      cc->mcch_active = 1;
-
-	      memcpy((char *) &mch_buffer[sdu_length_total]+1,
-		     &cc->MCCH_pdu.payload[0], mcch_sdu_length);
-	      sdu_lcids[num_sdus] = MCCH_LCHANID;
-	      sdu_lengths[num_sdus] = mcch_sdu_length;
-
-	      if (sdu_lengths[num_sdus] > 128) {
-		  header_len_mcch = 3;
-	      }
-
-	      sdu_length_total += sdu_lengths[num_sdus];
-	      LOG_D(MAC,
-		    "[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
-		    module_idP, CC_id, sdu_lengths[num_sdus]);
-	      num_sdus++;
-	  }
-	}
-
-	//MCCH scheduling ... do it anyway
-	{
-	    LOG_I(MAC, "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE (area %d, sfAlloc %d)\n",
-	  	module_idP, CC_id, frameP, subframeP, i, j);
-
-	    mcch_sdu_length = mac_rrc_data_req(module_idP, CC_id, frameP, MCCH, 0xFFFC, 1, &cc->MCCH_pdu.payload[0], 
-				       i);	// this is the mbsfn sync area index
-
-	    if (mcch_sdu_length > 0) {
-		mcch_sdu_length+=1; //RLC ?
-		LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
-		      module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
-
-		header_len_mcch = 2;
-
-		if (cc->tdd_Config != NULL) {
-		    LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
-			  module_idP, CC_id, frameP, subframeP,
-			  mcch_sdu_length, mcch_mcs);
-		} else {
-		    LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
-			  module_idP, CC_id, frameP, subframeP,
-			  mcch_sdu_length, mcch_mcs);
-		}
-
-		cc->mcch_active = 1;
-
-		memcpy((char *) &mch_buffer[sdu_length_total]+1,
-		       &cc->MCCH_pdu.payload[0], mcch_sdu_length);
-		sdu_lcids[num_sdus] = MCCH_LCHANID;
-		sdu_lengths[num_sdus] = mcch_sdu_length;
-
-		if (sdu_lengths[num_sdus] > 128) {
-		    header_len_mcch = 3;
-		}
-
-		sdu_length_total += sdu_lengths[num_sdus];
-		LOG_D(MAC,"[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
-		      module_idP, CC_id, sdu_lengths[num_sdus]);
-		num_sdus++;
-	    }
-	}
+        LOG_D(MAC, "[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
+        module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
+
+        header_len_mcch = 2;
+
+        if (cc->tdd_Config != NULL) {
+      LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
+      module_idP, CC_id, frameP, subframeP,
+      mcch_sdu_length, mcch_mcs);
+        } else {
+      LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
+      module_idP, CC_id, frameP, subframeP,
+      mcch_sdu_length, mcch_mcs);
+        }
+
+        cc->mcch_active = 1;
+
+        memcpy((char *) &mch_buffer[sdu_length_total]+1,
+         &cc->MCCH_pdu.payload[0], mcch_sdu_length);
+        sdu_lcids[num_sdus] = MCCH_LCHANID;
+        sdu_lengths[num_sdus] = mcch_sdu_length;
+
+        if (sdu_lengths[num_sdus] > 128) {
+      header_len_mcch = 3;
+        }
+
+        sdu_length_total += sdu_lengths[num_sdus];
+        LOG_D(MAC,
+        "[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
+        module_idP, CC_id, sdu_lengths[num_sdus]);
+        num_sdus++;
+    }
+  }
+
+  //MCCH scheduling ... do it anyway
+  {
+      LOG_I(MAC, "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE (area %d, sfAlloc %d)\n",
+      module_idP, CC_id, frameP, subframeP, i, j);
+
+      mcch_sdu_length = mac_rrc_data_req(module_idP, CC_id, frameP, MCCH, 0xFFFC, 1, &cc->MCCH_pdu.payload[0], 
+               i);  // this is the mbsfn sync area index
+
+      if (mcch_sdu_length > 0) {
+    mcch_sdu_length+=1; //RLC ?
+    LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
+          module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
+
+    header_len_mcch = 2;
+
+    if (cc->tdd_Config != NULL) {
+        LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
+        module_idP, CC_id, frameP, subframeP,
+        mcch_sdu_length, mcch_mcs);
+    } else {
+        LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
+        module_idP, CC_id, frameP, subframeP,
+        mcch_sdu_length, mcch_mcs);
+    }
+
+    cc->mcch_active = 1;
+
+    memcpy((char *) &mch_buffer[sdu_length_total]+1,
+           &cc->MCCH_pdu.payload[0], mcch_sdu_length);
+    sdu_lcids[num_sdus] = MCCH_LCHANID;
+    sdu_lengths[num_sdus] = mcch_sdu_length;
+
+    if (sdu_lengths[num_sdus] > 128) {
+        header_len_mcch = 3;
+    }
+
+    sdu_length_total += sdu_lengths[num_sdus];
+    LOG_D(MAC,"[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
+          module_idP, CC_id, sdu_lengths[num_sdus]);
+    num_sdus++;
+      }
+  }
     }// mcch_flag
 
 
     TBS =
-	get_TBS_DL(/*cc->pmch_Config[0]->dataMCS_r9*/cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
+  get_TBS_DL(/*cc->pmch_Config[0]->dataMCS_r9*/cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
     // do not let mcch and mtch multiplexing when relaying is active
     // for sync area 1, so not transmit data
     //if ((i == 0) && ((RC.mac[module_idP]->MBMS_flag != multicast_relay) || (RC.mac[module_idP]->mcch_active==0))) {
 
     // there is MTCHs, loop if there are more than 1
     if (mtch_flag == 1 ) {
-	// Calculate TBS
-	// get MTCH data from RLC (like for DTCH)
-	LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Schedule MTCH (area %d, sfAlloc %d)\n",
-	      module_idP, CC_id, frameP, subframeP, i, j);
-
-	header_len_mtch = 3;
-	LOG_D(MAC,"[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
-	      module_idP, CC_id, frameP, MTCH, TBS,
-	      TBS - header_len_mcch - header_len_msi - sdu_length_total -
-	      header_len_mtch);
-
-	//TODO
-	mbms_rab_id = cc->mbms_SessionList[0/*mbms_mch_i*/]->list.array[0]->logicalChannelIdentity_r9;
-
-	rlc_status =
-	    mac_rlc_status_ind(module_idP, 0xfffd, frameP, subframeP,
-			       module_idP, ENB_FLAG_YES, MBMS_FLAG_YES,
-				cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9,
-			       //MTCH,
+  // Calculate TBS
+  // get MTCH data from RLC (like for DTCH)
+  LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Schedule MTCH (area %d, sfAlloc %d)\n",
+        module_idP, CC_id, frameP, subframeP, i, j);
+
+  header_len_mtch = 3;
+  LOG_D(MAC,"[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
+        module_idP, CC_id, frameP, MTCH, TBS,
+        TBS - header_len_mcch - header_len_msi - sdu_length_total -
+        header_len_mtch);
+
+  //TODO
+  mbms_rab_id = cc->mbms_SessionList[0/*mbms_mch_i*/]->list.array[0]->logicalChannelIdentity_r9;
+
+  rlc_status =
+      mac_rlc_status_ind(module_idP, 0xfffd, frameP, subframeP,
+             module_idP, ENB_FLAG_YES, MBMS_FLAG_YES,
+        cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9,
+             //MTCH,
                                      0, 0
                                     );
 
-	bytes_in_buffer = rlc_status.bytes_in_buffer;
+  bytes_in_buffer = rlc_status.bytes_in_buffer;
 
-	//TOCHECK is this really neede?
-	if( !(mcch_flag==1 || msi_flag==1) )
-		msi_sfs = rlc_status.bytes_in_buffer/(TBS- header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)+(rlc_status.bytes_in_buffer%(TBS- header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)?1:0);
+  //TOCHECK is this really neede?
+  if( !(mcch_flag==1 || msi_flag==1) )
+    msi_sfs = rlc_status.bytes_in_buffer/(TBS- header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)+(rlc_status.bytes_in_buffer%(TBS- header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)?1:0);
 
         uint16_t TBS_MTCH =
-	get_TBS_DL(cc->pmch_Config[mbms_mch_i]->dataMCS_r9, to_prb(cc->mib->message.dl_Bandwidth));
+  get_TBS_DL(cc->pmch_Config[mbms_mch_i]->dataMCS_r9, to_prb(cc->mib->message.dl_Bandwidth));
 
-	if(msi_flag==1 && buffer_pointer!=NULL){
-	//	msi_ptr = &msi_control_element[0];
+  if(msi_flag==1 && buffer_pointer!=NULL){
+  //  msi_ptr = &msi_control_element[0];
 
-	    msi_pmch_stop = (rlc_status.bytes_in_buffer - header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)/(TBS_MTCH/*- header_len_mcch - header_len_msi -sdu_length_total*/ - header_len_mtch)+((rlc_status.bytes_in_buffer-TBS-header_len_mcch - header_len_msi -sdu_length_total)%(TBS_MTCH/*- header_len_mcch - header_len_msi -sdu_length_total*/ - header_len_mtch)?0:0);
+      msi_pmch_stop = (rlc_status.bytes_in_buffer - header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)/(TBS_MTCH/*- header_len_mcch - header_len_msi -sdu_length_total*/ - header_len_mtch)+((rlc_status.bytes_in_buffer-TBS-header_len_mcch - header_len_msi -sdu_length_total)%(TBS_MTCH/*- header_len_mcch - header_len_msi -sdu_length_total*/ - header_len_mtch)?0:0);
 
-	    for (k = 0; k < num_mtch; k++) {	// loop for all session in this MCH (MCH[0]) at this moment
-	      msi_ptr = &msi_control_element[k];
+      for (k = 0; k < num_mtch; k++) {  // loop for all session in this MCH (MCH[0]) at this moment
+        msi_ptr = &msi_control_element[k];
 
-	      ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[mbms_mch_i]->list.array[k]->logicalChannelIdentity_r9;	//mtch_lcid;
+        ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[mbms_mch_i]->list.array[k]->logicalChannelIdentity_r9;  //mtch_lcid;
 
-	      if( msi_pmch_stop > cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9)
-	             LOG_E(MAC,"e-MBMS Buffer Overflow\n"); 
+        if( msi_pmch_stop > cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9)
+               LOG_E(MAC,"e-MBMS Buffer Overflow\n"); 
 
-	      if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
-	          ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = (((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) >> 8) & 0x7f);
-	      	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = ((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) & 0xff);
-	          msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
-	      }else{
-	      	((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;	// last subframeP of this mtch (only one mtch now)
-	      	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
-	          msi_pmch_stop=0;
-	      }
-	      LOG_I(MAC,"frameP %d, subframeP %d LCID %d rlc_status.bytes_in_buffer %d stop_sf_LSB %d stop_sf_MSB %d msi_pmch_stop %d sf_AllocEnd_r9 %ld, msi_length %d\n",frameP,subframeP,((MSI_ELEMENT *) msi_ptr)->lcid,rlc_status.bytes_in_buffer,((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB,((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB, msi_pmch_stop,cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9, msi_length);
-	   }
+        if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
+            ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = (((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) >> 8) & 0x7f);
+          ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = ((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) & 0xff);
+            msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
+        }else{
+          ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;  // last subframeP of this mtch (only one mtch now)
+          ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
+            msi_pmch_stop=0;
+        }
+        LOG_I(MAC,"frameP %d, subframeP %d LCID %d rlc_status.bytes_in_buffer %d stop_sf_LSB %d stop_sf_MSB %d msi_pmch_stop %d sf_AllocEnd_r9 %ld, msi_length %d\n",frameP,subframeP,((MSI_ELEMENT *) msi_ptr)->lcid,rlc_status.bytes_in_buffer,((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB,((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB, msi_pmch_stop,cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9, msi_length);
+     }
 
-	    memcpy((char*)buffer_pointer,
-	       msi_control_element, msi_length);
-	}
+      memcpy((char*)buffer_pointer,
+         msi_control_element, msi_length);
+  }
 
-	LOG_D(MAC, "e-MBMS log channel %u frameP %d, subframeP %d,  rlc_status.bytes_in_buffer is %d TBS_MTCH %d pmch_stop %d msi_sfs %d\n",
-	      MTCH, frameP, subframeP, rlc_status.bytes_in_buffer,TBS_MTCH,msi_pmch_stop,msi_sfs);
+  LOG_D(MAC, "e-MBMS log channel %u frameP %d, subframeP %d,  rlc_status.bytes_in_buffer is %d TBS_MTCH %d pmch_stop %d msi_sfs %d\n",
+        MTCH, frameP, subframeP, rlc_status.bytes_in_buffer,TBS_MTCH,msi_pmch_stop,msi_sfs);
 
-	//TODO not sure whether msi and mch MCH should be precluded ... keep in mind this konditions just in case if ((rlc_status.bytes_in_buffer > 0 &&  msi_pmch_stop > 0) && ((msi_flag!=1 || mcch_flag!=1))
-	if ((rlc_status.bytes_in_buffer > 0 &&  msi_pmch_stop > 0) /*&& ((msi_flag!=1 || mcch_flag!=1))*/ /*|| (rlc_status.bytes_in_buffer > 0 && (msi_flag==1 || mcch_flag==1))*//*|| msi_sfs > cc->pmch_Config[0]->sf_AllocEnd_r9 */ /*msi_pmch_stop>=num_sf_alloc*/ ) {
-	    LOG_I(MAC,"[eNB %d][MBMS USER-PLANE], CC_id %d, Frame %d, Subframe %d MTCH->MCH, Requesting %d bytes from RLC (header len mtch %d) rlc_status.bytes_in_buffer %d, LCID %ld\n",
-		  module_idP, CC_id, frameP, subframeP,
-		  TBS - header_len_mcch - header_len_msi -
-		  sdu_length_total - header_len_mtch, header_len_mtch, rlc_status.bytes_in_buffer,cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9);
+  //TODO not sure whether msi and mch MCH should be precluded ... keep in mind this konditions just in case if ((rlc_status.bytes_in_buffer > 0 &&  msi_pmch_stop > 0) && ((msi_flag!=1 || mcch_flag!=1))
+  if ((rlc_status.bytes_in_buffer > 0 &&  msi_pmch_stop > 0) /*&& ((msi_flag!=1 || mcch_flag!=1))*/ /*|| (rlc_status.bytes_in_buffer > 0 && (msi_flag==1 || mcch_flag==1))*//*|| msi_sfs > cc->pmch_Config[0]->sf_AllocEnd_r9 */ /*msi_pmch_stop>=num_sf_alloc*/ ) {
+      LOG_I(MAC,"[eNB %d][MBMS USER-PLANE], CC_id %d, Frame %d, Subframe %d MTCH->MCH, Requesting %d bytes from RLC (header len mtch %d) rlc_status.bytes_in_buffer %d, LCID %ld\n",
+      module_idP, CC_id, frameP, subframeP,
+      TBS - header_len_mcch - header_len_msi -
+      sdu_length_total - header_len_mtch, header_len_mtch, rlc_status.bytes_in_buffer,cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9);
 
       sdu_lengths[num_sdus] = mac_rlc_data_req(module_idP, 0xfffd, module_idP, frameP, ENB_FLAG_YES, MBMS_FLAG_YES,cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9,
                                                TBS - header_len_mcch - header_len_msi - sdu_length_total - header_len_mtch,
-						     (char *)
-						     &mch_buffer[sdu_length_total]
+                 (char *)
+                 &mch_buffer[sdu_length_total]
                                 ,0,
                                  0
                                  );
-	    LOG_D(MAC,"[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_sfs %d sdu_lengths[num_sdus] %d\n",
-		  module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs, sdu_lengths[num_sdus]);
+      LOG_D(MAC,"[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_sfs %d sdu_lengths[num_sdus] %d\n",
+      module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs, sdu_lengths[num_sdus]);
 
-	    cc->mtch_active = 1;
+      cc->mtch_active = 1;
 
-	    sdu_lcids[num_sdus] = cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9/*MTCH*/;
-	    sdu_length_total += sdu_lengths[num_sdus];
+      sdu_lcids[num_sdus] = cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9/*MTCH*/;
+      sdu_length_total += sdu_lengths[num_sdus];
 
-	    if (msi_pmch_stop != 0 && msi_flag !=1)
-	    	msi_pmch_stop--;
+      if (msi_pmch_stop != 0 && msi_flag !=1)
+        msi_pmch_stop--;
 
-	    if (sdu_lengths[num_sdus] < 128) {
-		header_len_mtch = 2;
-	    }
+      if (sdu_lengths[num_sdus] < 128) {
+    header_len_mtch = 2;
+      }
 
-	    num_sdus++;
-	} 
-	else {
-	    header_len_mtch = 0;
-	}
+      num_sdus++;
+  } 
+  else {
+      header_len_mtch = 0;
+  }
     }
 
     // FINAL STEP: Prepare and multiplexe MSI, MCCH and MTCHs
     if ((sdu_length_total + header_len_msi + header_len_mcch + header_len_mtch) > 0) {
 
-	// Adjust the last subheader
-	header_len_mtch_temp = header_len_mtch;
-	header_len_mcch_temp = header_len_mcch;
-	header_len_msi_temp = header_len_msi;
-
-	if (header_len_mtch > 0) {
-	    header_len_mtch = 1;	// remove Length field in the  subheader for the last PDU
-	} else if (header_len_mcch > 0) {
-	    header_len_mcch = 1;
-	} else {
-	    header_len_msi = 1;
-	}
-
-	// Calculate the padding
-	if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
-	     sdu_length_total) < 0) {
-	    LOG_E(MAC, "Error in building MAC PDU, TBS %d < PDU %d \n",
-		  TBS,
-		  header_len_mtch + header_len_mcch + header_len_msi +
-		  sdu_length_total);
-	    return 0;
-	} else
-	    if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
-		 sdu_length_total) <= 2) {
-	    padding =
-		(TBS - header_len_mtch - header_len_mcch - header_len_msi -
-		 sdu_length_total);
-	    post_padding = 0;
-	} else {		// using post_padding, give back the Length field of subheader  for the last PDU
-	    padding = 0;
-
-	    if (header_len_mtch > 0) {
-		header_len_mtch = header_len_mtch_temp;
-	    } else if (header_len_mcch > 0) {
-		header_len_mcch = header_len_mcch_temp;
-	    } else {
-		header_len_msi = header_len_msi_temp;
-	    }
-
-	    post_padding =
-		TBS - sdu_length_total - header_len_msi - header_len_mcch -
-		header_len_mtch;
-	}
-
-	// Generate the MAC Header for MCH
-	// here we use the function for DLSCH because DLSCH & MCH have the same Header structure
-	offset = generate_dlsch_header((unsigned char *) cc->MCH_pdu.payload, num_sdus, sdu_lengths, sdu_lcids, 255,	// no drx
-				       31,	// no timing advance
-				       NULL,	// no contention res id
-				       padding, post_padding);
-
-	cc->MCH_pdu.Pdu_size = TBS;
-	cc->MCH_pdu.sync_area = i;
-	cc->MCH_pdu.msi_active = cc->msi_active;
-	cc->MCH_pdu.mcch_active = cc->mcch_active;
-	cc->MCH_pdu.mtch_active = cc->mtch_active;
-	LOG_D(MAC, " MCS for this sf is %d (mcch active %d, mtch active %d)\n",
-	      cc->MCH_pdu.mcs, cc->MCH_pdu.mcch_active,
-	      cc->MCH_pdu.mtch_active);
-	LOG_D(MAC, "[eNB %d][MBMS USER-PLANE ] CC_id %d Generate header : sdu_length_total %d, num_sdus %d, sdu_lengths[0] %d, sdu_lcids[0] %d => payload offset %d,padding %d,post_padding %d (mcs %d, TBS %d), header MTCH %d, header MCCH %d, header MSI %d\n",
-	      module_idP, CC_id, sdu_length_total, num_sdus,
-	      sdu_lengths[0], sdu_lcids[0], offset, padding, post_padding,
-	      cc->MCH_pdu.mcs, TBS, header_len_mtch, header_len_mcch,
-	      header_len_msi);
-	// copy SDU to mch_pdu after the MAC Header
-	memcpy(&cc->MCH_pdu.payload[offset], mch_buffer, sdu_length_total);
-
-	// filling remainder of MCH with random data if necessery
-	for (j = 0; j < (TBS - sdu_length_total - offset); j++) {
-	    cc->MCH_pdu.payload[offset + sdu_length_total + j] =
-		(char) (taus() & 0xff);
-	}
-
-	/* Tracing of PDU is done on UE side */
-	//if (opt_enabled == 1) {
-	trace_pdu(DIRECTION_DOWNLINK, (uint8_t *) cc->MCH_pdu.payload, TBS, module_idP, WS_M_RNTI , 0xfffd,	// M_RNTI = 6 in wirehsark
-	          RC.mac[module_idP]->frame,
-	          RC.mac[module_idP]->subframe, 0, 0);
-	LOG_D(OPT, "[eNB %d][MCH] CC_id %d Frame %d : MAC PDU with size %d\n",
-		  module_idP, CC_id, frameP, TBS);
-	//}
-
-       	eNB_MAC_INST *eNB = RC.mac[module_idP];
-    	dl_req = &eNB->DL_req[CC_id].dl_config_request_body;
-	dl_req->tl.tag = NFAPI_DL_CONFIG_REQUEST_BODY_TAG;
-    	fill_nfapi_mch_config(
-			dl_req,
-			TBS,
-			0,
-			0xfffd,
-			0,
-			get_Qm(cc->MCH_pdu.mcs),
-			cc->MCH_pdu.mcs,
-			6000, //equal to RS power
-			0 //mbsfn_area_id
-			);
-
-	eNB->TX_req[CC_id].sfn_sf = fill_nfapi_tx_req(&eNB->TX_req[CC_id].tx_request_body,
+  // Adjust the last subheader
+  header_len_mtch_temp = header_len_mtch;
+  header_len_mcch_temp = header_len_mcch;
+  header_len_msi_temp = header_len_msi;
+
+  if (header_len_mtch > 0) {
+      header_len_mtch = 1;  // remove Length field in the  subheader for the last PDU
+  } else if (header_len_mcch > 0) {
+      header_len_mcch = 1;
+  } else {
+      header_len_msi = 1;
+  }
+
+  // Calculate the padding
+  if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
+       sdu_length_total) < 0) {
+      LOG_E(MAC, "Error in building MAC PDU, TBS %d < PDU %d \n",
+      TBS,
+      header_len_mtch + header_len_mcch + header_len_msi +
+      sdu_length_total);
+      return 0;
+  } else
+      if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
+     sdu_length_total) <= 2) {
+      padding =
+    (TBS - header_len_mtch - header_len_mcch - header_len_msi -
+     sdu_length_total);
+      post_padding = 0;
+  } else {    // using post_padding, give back the Length field of subheader  for the last PDU
+      padding = 0;
+
+      if (header_len_mtch > 0) {
+    header_len_mtch = header_len_mtch_temp;
+      } else if (header_len_mcch > 0) {
+    header_len_mcch = header_len_mcch_temp;
+      } else {
+    header_len_msi = header_len_msi_temp;
+      }
+
+      post_padding =
+    TBS - sdu_length_total - header_len_msi - header_len_mcch -
+    header_len_mtch;
+  }
+
+  // Generate the MAC Header for MCH
+  // here we use the function for DLSCH because DLSCH & MCH have the same Header structure
+  offset = generate_dlsch_header((unsigned char *) cc->MCH_pdu.payload, num_sdus, sdu_lengths, sdu_lcids, 255,  // no drx
+               31,  // no timing advance
+               NULL,  // no contention res id
+               padding, post_padding);
+
+  cc->MCH_pdu.Pdu_size = TBS;
+  cc->MCH_pdu.sync_area = i;
+  cc->MCH_pdu.msi_active = cc->msi_active;
+  cc->MCH_pdu.mcch_active = cc->mcch_active;
+  cc->MCH_pdu.mtch_active = cc->mtch_active;
+  LOG_D(MAC, " MCS for this sf is %d (mcch active %d, mtch active %d)\n",
+        cc->MCH_pdu.mcs, cc->MCH_pdu.mcch_active,
+        cc->MCH_pdu.mtch_active);
+  LOG_D(MAC, "[eNB %d][MBMS USER-PLANE ] CC_id %d Generate header : sdu_length_total %d, num_sdus %d, sdu_lengths[0] %d, sdu_lcids[0] %d => payload offset %d,padding %d,post_padding %d (mcs %d, TBS %d), header MTCH %d, header MCCH %d, header MSI %d\n",
+        module_idP, CC_id, sdu_length_total, num_sdus,
+        sdu_lengths[0], sdu_lcids[0], offset, padding, post_padding,
+        cc->MCH_pdu.mcs, TBS, header_len_mtch, header_len_mcch,
+        header_len_msi);
+  // copy SDU to mch_pdu after the MAC Header
+  memcpy(&cc->MCH_pdu.payload[offset], mch_buffer, sdu_length_total);
+
+  // filling remainder of MCH with random data if necessery
+  for (j = 0; j < (TBS - sdu_length_total - offset); j++) {
+      cc->MCH_pdu.payload[offset + sdu_length_total + j] =
+    (char) (taus() & 0xff);
+  }
+
+  /* Tracing of PDU is done on UE side */
+  //if (opt_enabled == 1) {
+  trace_pdu(DIRECTION_DOWNLINK, (uint8_t *) cc->MCH_pdu.payload, TBS, module_idP, WS_M_RNTI , 0xfffd,  // M_RNTI = 6 in wirehsark
+            RC.mac[module_idP]->frame,
+            RC.mac[module_idP]->subframe, 0, 0);
+  LOG_D(OPT, "[eNB %d][MCH] CC_id %d Frame %d : MAC PDU with size %d\n",
+      module_idP, CC_id, frameP, TBS);
+  //}
+
+         eNB_MAC_INST *eNB = RC.mac[module_idP];
+      dl_req = &eNB->DL_req[CC_id].dl_config_request_body;
+  dl_req->tl.tag = NFAPI_DL_CONFIG_REQUEST_BODY_TAG;
+      fill_nfapi_mch_config(
+      dl_req,
+      TBS,
+      0,
+      0xfffd,
+      0,
+      get_Qm(cc->MCH_pdu.mcs),
+      cc->MCH_pdu.mcs,
+      6000, //equal to RS power
+      0 //mbsfn_area_id
+      );
+
+  eNB->TX_req[CC_id].sfn_sf = fill_nfapi_tx_req(&eNB->TX_req[CC_id].tx_request_body,
                                         (frameP * 10) + subframeP,
                                         TBS,
                                         eNB->pdu_index[CC_id],
                                         (uint8_t*)cc->MCH_pdu.payload);
-	return 1;
+  return 1;
     } else {
-	cc->MCH_pdu.Pdu_size = 0;
-	cc->MCH_pdu.sync_area = 0;
-	cc->MCH_pdu.msi_active = 0;
-	cc->MCH_pdu.mcch_active = 0;
-	cc->MCH_pdu.mtch_active = 0;
-	return 0;
+  cc->MCH_pdu.Pdu_size = 0;
+  cc->MCH_pdu.sync_area = 0;
+  cc->MCH_pdu.msi_active = 0;
+  cc->MCH_pdu.mcch_active = 0;
+  cc->MCH_pdu.mtch_active = 0;
+  return 0;
     }
 }
 int
 schedule_MBMS(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
-	      sub_frame_t subframeP)
+        sub_frame_t subframeP)
 {
 
     int mcch_flag = 0, mtch_flag = 0, msi_flag = 0;
-    int mbsfn_period = 0;	// 1<<(RC.mac[module_idP]->mbsfn_SubframeConfig[0]->radioframeAllocationPeriod);
-    int mcch_period = 0;	//32<<(RC.mac[module_idP]->mbsfn_AreaInfo[0]->mcch_Config_r9.mcch_RepetitionPeriod_r9);
+    int mbsfn_period = 0;  // 1<<(RC.mac[module_idP]->mbsfn_SubframeConfig[0]->radioframeAllocationPeriod);
+    int mcch_period = 0;  //32<<(RC.mac[module_idP]->mbsfn_AreaInfo[0]->mcch_Config_r9.mcch_RepetitionPeriod_r9);
     if(RC.mac[module_idP]->common_channels[CC_id].
               pmch_Config[0] == NULL )
 
-	return 0;
+  return 0;
 
 
     int mch_scheduling_period =
-	8 << (RC.mac[module_idP]->common_channels[CC_id].
-	      pmch_Config[0]->mch_SchedulingPeriod_r9);
+  8 << (RC.mac[module_idP]->common_channels[CC_id].
+        pmch_Config[0]->mch_SchedulingPeriod_r9);
     unsigned char mcch_sdu_length;
     unsigned char header_len_mcch = 0, header_len_msi =
-	0, header_len_mtch = 0, header_len_mtch_temp =
-	0, header_len_mcch_temp = 0, header_len_msi_temp = 0;
+  0, header_len_mtch = 0, header_len_mtch_temp =
+  0, header_len_mcch_temp = 0, header_len_msi_temp = 0;
     int ii = 0, msi_pos = 0;
     int mcch_mcs = -1;
     uint16_t TBS, j = -1, padding = 0, post_padding = 0;
@@ -1112,370 +1098,370 @@ schedule_MBMS(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
     //uint8_t l =0;
     unsigned char sdu_lcids[11], num_sdus = 0, offset = 0;
     uint16_t sdu_lengths[11], sdu_length_total = 0;
-    unsigned char mch_buffer[MAX_DLSCH_PAYLOAD_BYTES];	// check the max value, this is for dlsch only
+    unsigned char mch_buffer[MAX_DLSCH_PAYLOAD_BYTES];  // check the max value, this is for dlsch only
 
     COMMON_channels_t *cc = &RC.mac[module_idP]->common_channels[CC_id];
 
     cc->MCH_pdu.Pdu_size = 0;
 
     for (i = 0; i < cc->num_active_mbsfn_area; i++) {
-	// assume, that there is always a mapping
-	if ((j = get_mbsfn_sf_alloction(module_idP, CC_id, i)) == -1) {
-	    return 0;
-	}
-
-	mbsfn_period =
-	    1 << (cc->mbsfn_SubframeConfig[j]->radioframeAllocationPeriod);
-	mcch_period =
-	    32 << (cc->mbsfn_AreaInfo[i]->
-		   mcch_Config_r9.mcch_RepetitionPeriod_r9);
-	msi_pos = 0;
-	ii = 0;
-	LOG_D(MAC,
-	      "[eNB %d] CC_id %d Frame %d subframeP %d : Checking MBSFN Sync Area %d/%d with SF allocation %d/%d for MCCH and MTCH (mbsfn period %d, mcch period %d)\n",
-	      module_idP, CC_id, frameP, subframeP, i,
-	      cc->num_active_mbsfn_area, j, cc->num_sf_allocation_pattern,
-	      mbsfn_period, mcch_period);
-
-
-	switch (cc->mbsfn_AreaInfo[i]->mcch_Config_r9.signallingMCS_r9) {
-	case 0:
-	    mcch_mcs = 2;
-	    break;
-
-	case 1:
-	    mcch_mcs = 7;
-	    break;
-
-	case 2:
-	    mcch_mcs = 13;
-	    break;
-
-	case 3:
-	    mcch_mcs = 19;
-	    break;
-	}
-
-	// 1st: Check the MBSFN subframes from SIB2 info (SF allocation pattern i, max 8 non-overlapping patterns exist)
-	if (frameP % mbsfn_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {	// MBSFN frameP
-	    if (cc->mbsfn_SubframeConfig[j]->subframeAllocation.present == LTE_MBSFN_SubframeConfig__subframeAllocation_PR_oneFrame) {	// one-frameP format
-
-		//  Find the first subframeP in this MCH to transmit MSI
-		if (frameP % mch_scheduling_period ==
-		    cc->mbsfn_SubframeConfig[j]->
-		    radioframeAllocationOffset) {
-		    while (ii == 0) {
-			ii = cc->
-			    mbsfn_SubframeConfig[j]->subframeAllocation.
-			    choice.oneFrame.buf[0] & (0x80 >> msi_pos);
-			msi_pos++;
-		    }
-
-		    LOG_D(MAC,
-			  "[eNB %d] CC_id %d Frame %d subframeP %d : sync area %d sf allocation pattern %d sf alloc %x msi pos is %d \n",
-			  module_idP, CC_id, frameP, subframeP, i, j,
-			  cc->mbsfn_SubframeConfig[j]->
-			  subframeAllocation.choice.oneFrame.buf[0],
-			  msi_pos);
-		}
-		// Check if the subframeP is for MSI, MCCH or MTCHs and Set the correspoding flag to 1
-		switch (subframeP) {
-		case 1:
-		    if (cc->tdd_Config == NULL) {
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF1) ==
-			    MBSFN_FDD_SF1) {
-			    if (msi_pos == 1) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF1) ==
-				 MBSFN_FDD_SF1)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 2:
-		    if (cc->tdd_Config == NULL) {
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF2) ==
-			    MBSFN_FDD_SF2) {
-			    if (msi_pos == 2) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF2) ==
-				 MBSFN_FDD_SF2)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 3:
-		    if (cc->tdd_Config != NULL) {	// TDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_TDD_SF3) ==
-			    MBSFN_TDD_SF3) {
-			    if (msi_pos == 1) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_TDD_SF3) ==
-				 MBSFN_TDD_SF3)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    } else {	// FDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF3) ==
-			    MBSFN_FDD_SF3) {
-			    if (msi_pos == 3) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF3) ==
-				 MBSFN_FDD_SF3)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 4:
-		    if (cc->tdd_Config != NULL) {
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_TDD_SF4) ==
-			    MBSFN_TDD_SF4) {
-			    if (msi_pos == 2) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_TDD_SF4) ==
-				 MBSFN_TDD_SF4)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 6:
-		    if (cc->tdd_Config == NULL) {
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF6) ==
-			    MBSFN_FDD_SF6) {
-			    if (msi_pos == 4) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF6) ==
-				 MBSFN_FDD_SF6)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 7:
-		    if (cc->tdd_Config != NULL) {	// TDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_TDD_SF7) ==
-			    MBSFN_TDD_SF7) {
-			    if (msi_pos == 3) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_TDD_SF7) ==
-				 MBSFN_TDD_SF7)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    } else {	// FDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF7) ==
-			    MBSFN_FDD_SF7) {
-			    if (msi_pos == 5) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF7) ==
-				 MBSFN_FDD_SF7)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 8:
-		    if (cc->tdd_Config != NULL) {	//TDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_TDD_SF8) ==
-			    MBSFN_TDD_SF8) {
-			    if (msi_pos == 4) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_TDD_SF8) ==
-				 MBSFN_TDD_SF8)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    } else {	// FDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF8) ==
-			    MBSFN_FDD_SF8) {
-			    if (msi_pos == 6) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF8) ==
-				 MBSFN_FDD_SF8)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 9:
-		    if (cc->tdd_Config != NULL) {
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_TDD_SF9) ==
-			    MBSFN_TDD_SF9) {
-			    if (msi_pos == 5) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_TDD_SF9) ==
-				 MBSFN_TDD_SF9)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-		}		// end switch
-
-		// sf allocation is non-overlapping
-		if ((msi_flag == 1) || (mcch_flag == 1)
-		    || (mtch_flag == 1)) {
-		    LOG_D(MAC,
-			  "[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d\n",
-			  module_idP, CC_id, frameP, subframeP, i, j,
-			  msi_flag, mcch_flag, mtch_flag);
-		    break;
-		}
-	    } else {		// four-frameP format
-	    }
-	}
-    }				// end of for loop
+  // assume, that there is always a mapping
+  if ((j = get_mbsfn_sf_alloction(module_idP, CC_id, i)) == -1) {
+      return 0;
+  }
+
+  mbsfn_period =
+      1 << (cc->mbsfn_SubframeConfig[j]->radioframeAllocationPeriod);
+  mcch_period =
+      32 << (cc->mbsfn_AreaInfo[i]->
+       mcch_Config_r9.mcch_RepetitionPeriod_r9);
+  msi_pos = 0;
+  ii = 0;
+  LOG_D(MAC,
+        "[eNB %d] CC_id %d Frame %d subframeP %d : Checking MBSFN Sync Area %d/%d with SF allocation %d/%d for MCCH and MTCH (mbsfn period %d, mcch period %d)\n",
+        module_idP, CC_id, frameP, subframeP, i,
+        cc->num_active_mbsfn_area, j, cc->num_sf_allocation_pattern,
+        mbsfn_period, mcch_period);
+
+
+  switch (cc->mbsfn_AreaInfo[i]->mcch_Config_r9.signallingMCS_r9) {
+  case 0:
+      mcch_mcs = 2;
+      break;
+
+  case 1:
+      mcch_mcs = 7;
+      break;
+
+  case 2:
+      mcch_mcs = 13;
+      break;
+
+  case 3:
+      mcch_mcs = 19;
+      break;
+  }
+
+  // 1st: Check the MBSFN subframes from SIB2 info (SF allocation pattern i, max 8 non-overlapping patterns exist)
+  if (frameP % mbsfn_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {  // MBSFN frameP
+      if (cc->mbsfn_SubframeConfig[j]->subframeAllocation.present == LTE_MBSFN_SubframeConfig__subframeAllocation_PR_oneFrame) {  // one-frameP format
+
+    //  Find the first subframeP in this MCH to transmit MSI
+    if (frameP % mch_scheduling_period ==
+        cc->mbsfn_SubframeConfig[j]->
+        radioframeAllocationOffset) {
+        while (ii == 0) {
+      ii = cc->
+          mbsfn_SubframeConfig[j]->subframeAllocation.
+          choice.oneFrame.buf[0] & (0x80 >> msi_pos);
+      msi_pos++;
+        }
+
+        LOG_D(MAC,
+        "[eNB %d] CC_id %d Frame %d subframeP %d : sync area %d sf allocation pattern %d sf alloc %x msi pos is %d \n",
+        module_idP, CC_id, frameP, subframeP, i, j,
+        cc->mbsfn_SubframeConfig[j]->
+        subframeAllocation.choice.oneFrame.buf[0],
+        msi_pos);
+    }
+    // Check if the subframeP is for MSI, MCCH or MTCHs and Set the correspoding flag to 1
+    switch (subframeP) {
+    case 1:
+        if (cc->tdd_Config == NULL) {
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF1) ==
+          MBSFN_FDD_SF1) {
+          if (msi_pos == 1) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF1) ==
+         MBSFN_FDD_SF1)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 2:
+        if (cc->tdd_Config == NULL) {
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF2) ==
+          MBSFN_FDD_SF2) {
+          if (msi_pos == 2) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF2) ==
+         MBSFN_FDD_SF2)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 3:
+        if (cc->tdd_Config != NULL) {  // TDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_TDD_SF3) ==
+          MBSFN_TDD_SF3) {
+          if (msi_pos == 1) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_TDD_SF3) ==
+         MBSFN_TDD_SF3)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        } else {  // FDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF3) ==
+          MBSFN_FDD_SF3) {
+          if (msi_pos == 3) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF3) ==
+         MBSFN_FDD_SF3)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 4:
+        if (cc->tdd_Config != NULL) {
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_TDD_SF4) ==
+          MBSFN_TDD_SF4) {
+          if (msi_pos == 2) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_TDD_SF4) ==
+         MBSFN_TDD_SF4)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 6:
+        if (cc->tdd_Config == NULL) {
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF6) ==
+          MBSFN_FDD_SF6) {
+          if (msi_pos == 4) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF6) ==
+         MBSFN_FDD_SF6)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 7:
+        if (cc->tdd_Config != NULL) {  // TDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_TDD_SF7) ==
+          MBSFN_TDD_SF7) {
+          if (msi_pos == 3) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_TDD_SF7) ==
+         MBSFN_TDD_SF7)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        } else {  // FDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF7) ==
+          MBSFN_FDD_SF7) {
+          if (msi_pos == 5) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF7) ==
+         MBSFN_FDD_SF7)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 8:
+        if (cc->tdd_Config != NULL) {  //TDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_TDD_SF8) ==
+          MBSFN_TDD_SF8) {
+          if (msi_pos == 4) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_TDD_SF8) ==
+         MBSFN_TDD_SF8)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        } else {  // FDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF8) ==
+          MBSFN_FDD_SF8) {
+          if (msi_pos == 6) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF8) ==
+         MBSFN_FDD_SF8)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 9:
+        if (cc->tdd_Config != NULL) {
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_TDD_SF9) ==
+          MBSFN_TDD_SF9) {
+          if (msi_pos == 5) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_TDD_SF9) ==
+         MBSFN_TDD_SF9)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+    }    // end switch
+
+    // sf allocation is non-overlapping
+    if ((msi_flag == 1) || (mcch_flag == 1)
+        || (mtch_flag == 1)) {
+        LOG_D(MAC,
+        "[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d\n",
+        module_idP, CC_id, frameP, subframeP, i, j,
+        msi_flag, mcch_flag, mtch_flag);
+        break;
+    }
+      } else {    // four-frameP format
+      }
+  }
+    }        // end of for loop
 
     cc->msi_active = 0;
     cc->mcch_active = 0;
@@ -1483,9 +1469,9 @@ schedule_MBMS(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
 
     // Calculate the mcs
     if ((msi_flag == 1) || (mcch_flag == 1)) {
-	cc->MCH_pdu.mcs = mcch_mcs;
-    } else if (mtch_flag == 1) {	// only MTCH in this subframeP
-	cc->MCH_pdu.mcs = cc->pmch_Config[0]->dataMCS_r9;
+  cc->MCH_pdu.mcs = mcch_mcs;
+    } else if (mtch_flag == 1) {  // only MTCH in this subframeP
+  cc->MCH_pdu.mcs = cc->pmch_Config[0]->dataMCS_r9;
     }
 
 
@@ -1498,350 +1484,350 @@ schedule_MBMS(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
 
     // there is MSI (MCH Scheduling Info)
     if (msi_flag == 1) {
-	// Create MSI here
-	uint16_t msi_control_element[29], *msi_ptr;
-
-	msi_ptr = &msi_control_element[0];
-	//((MSI_ELEMENT *) msi_ptr)->lcid = MCCH_LCHANID;	//MCCH
-
-	//if (mcch_flag == 1) {
-	//    ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0;
-	//    ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0;
-	//} else {		// no mcch for this MSP
-	//    ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;	// stop value is 2047
-	//    ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xff;
-	//}
-
-	//msi_ptr += sizeof(MSI_ELEMENT);
-
-	//Header for MTCHs
-	num_mtch = cc->mbms_SessionList[0]->list.count;
-
-    	TBS =
-	get_TBS_DL(cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
-	//l=0;
-
-	for (k = 0; k < num_mtch; k++) {	// loop for all session in this MCH (MCH[0]) at this moment
-
-	    ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[0]->list.array[k]->logicalChannelIdentity_r9;	//mtch_lcid;
-
-	    if( msi_sfs != 0 )
-	    	msi_pmch_stop = msi_sfs-1;
-	    else 
-		msi_pmch_stop = msi_sfs;
-
-	    if( msi_pmch_stop > cc->pmch_Config[0]->sf_AllocEnd_r9)
-		   LOG_W(MAC,"e-MBMS Buffer Overflow\n"); 
-
-	    if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
-	        ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0;	// last subframeP of this mtch (only one mtch now) & stop_sf limited to 256
-	    	//((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = msi_pmch_stop;
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = (msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[0]->sf_AllocEnd_r9);
-		msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[0]->sf_AllocEnd_r9);
-	    }else{
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;	// last subframeP of this mtch (only one mtch now)
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
-		msi_pmch_stop=0;
-	    }
-
-	   
-	   
-	    msi_ptr += sizeof(MSI_ELEMENT);
-	}
-
-	msi_length = msi_ptr - msi_control_element;
-
-	if (msi_length < 128) {
-	    header_len_msi = 2;
-	} else {
-	    header_len_msi = 3;
-	}
-
-	LOG_W(MAC,
-	      "[eNB %d] CC_id %d Frame %d : MSI->MCH, length of MSI is %d bytes TBS %d, bytes in buffer %d stop_sf_LSB %d msi_sfs %d cc->pmch_Config[0]->sf_AllocEnd_r9 %ld\n",
-	      module_idP, CC_id, frameP, msi_length,TBS, bytes_in_buffer,msi_pmch_stop,msi_sfs,cc->pmch_Config[0]->sf_AllocEnd_r9);
-	    
-	msi_sfs = 0;
-
-	//LOG_D(MAC,"Scheduler: MSI is transmitted in this subframeP \n" );
-
-	//   LOG_D(MAC,"Scheduler: MSI length is %d bytes\n",msi_length);
-	// Store MSI data to mch_buffer[0]
-	memcpy((char *) &mch_buffer[sdu_length_total],
-	       msi_control_element, msi_length);
-
-	sdu_lcids[num_sdus] = MCH_SCHDL_INFO;
-	sdu_lengths[num_sdus] = msi_length;
-	sdu_length_total += sdu_lengths[num_sdus];
-	LOG_D(MAC, "[eNB %d] CC_id %d Create %d bytes for MSI\n",
-	      module_idP, CC_id, sdu_lengths[num_sdus]);
-	num_sdus++;
-	cc->msi_active = 1;
+  // Create MSI here
+  uint16_t msi_control_element[29], *msi_ptr;
+
+  msi_ptr = &msi_control_element[0];
+  //((MSI_ELEMENT *) msi_ptr)->lcid = MCCH_LCHANID;  //MCCH
+
+  //if (mcch_flag == 1) {
+  //    ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0;
+  //    ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0;
+  //} else {    // no mcch for this MSP
+  //    ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;  // stop value is 2047
+  //    ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xff;
+  //}
+
+  //msi_ptr += sizeof(MSI_ELEMENT);
+
+  //Header for MTCHs
+  num_mtch = cc->mbms_SessionList[0]->list.count;
+
+      TBS =
+  get_TBS_DL(cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
+  //l=0;
+
+  for (k = 0; k < num_mtch; k++) {  // loop for all session in this MCH (MCH[0]) at this moment
+
+      ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[0]->list.array[k]->logicalChannelIdentity_r9;  //mtch_lcid;
+
+      if( msi_sfs != 0 )
+        msi_pmch_stop = msi_sfs-1;
+      else 
+    msi_pmch_stop = msi_sfs;
+
+      if( msi_pmch_stop > cc->pmch_Config[0]->sf_AllocEnd_r9)
+       LOG_W(MAC,"e-MBMS Buffer Overflow\n"); 
+
+      if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
+          ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0;  // last subframeP of this mtch (only one mtch now) & stop_sf limited to 256
+        //((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = msi_pmch_stop;
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = (msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[0]->sf_AllocEnd_r9);
+    msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[0]->sf_AllocEnd_r9);
+      }else{
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;  // last subframeP of this mtch (only one mtch now)
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
+    msi_pmch_stop=0;
+      }
+
+     
+     
+      msi_ptr += sizeof(MSI_ELEMENT);
+  }
+
+  msi_length = msi_ptr - msi_control_element;
+
+  if (msi_length < 128) {
+      header_len_msi = 2;
+  } else {
+      header_len_msi = 3;
+  }
+
+  LOG_W(MAC,
+        "[eNB %d] CC_id %d Frame %d : MSI->MCH, length of MSI is %d bytes TBS %d, bytes in buffer %d stop_sf_LSB %d msi_sfs %d cc->pmch_Config[0]->sf_AllocEnd_r9 %ld\n",
+        module_idP, CC_id, frameP, msi_length,TBS, bytes_in_buffer,msi_pmch_stop,msi_sfs,cc->pmch_Config[0]->sf_AllocEnd_r9);
+      
+  msi_sfs = 0;
+
+  //LOG_D(MAC,"Scheduler: MSI is transmitted in this subframeP \n" );
+
+  //   LOG_D(MAC,"Scheduler: MSI length is %d bytes\n",msi_length);
+  // Store MSI data to mch_buffer[0]
+  memcpy((char *) &mch_buffer[sdu_length_total],
+         msi_control_element, msi_length);
+
+  sdu_lcids[num_sdus] = MCH_SCHDL_INFO;
+  sdu_lengths[num_sdus] = msi_length;
+  sdu_length_total += sdu_lengths[num_sdus];
+  LOG_D(MAC, "[eNB %d] CC_id %d Create %d bytes for MSI\n",
+        module_idP, CC_id, sdu_lengths[num_sdus]);
+  num_sdus++;
+  cc->msi_active = 1;
     }
     // there is MCCH
     if (mcch_flag == 1) {
-	LOG_D(MAC,
-	      "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE (area %d, sfAlloc %d)\n",
-	      module_idP, CC_id, frameP, subframeP, i, j);
+  LOG_D(MAC,
+        "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE (area %d, sfAlloc %d)\n",
+        module_idP, CC_id, frameP, subframeP, i, j);
 
-	mcch_sdu_length = mac_rrc_data_req(module_idP, CC_id, frameP, MCCH, 0xFFFC, 1, &cc->MCCH_pdu.payload[0], 
-					   i);	// this is the mbsfn sync area index
+  mcch_sdu_length = mac_rrc_data_req(module_idP, CC_id, frameP, MCCH, 0xFFFC, 1, &cc->MCCH_pdu.payload[0], 
+             i);  // this is the mbsfn sync area index
 
         mcch_sdu_length+=1; //RLC ?
 
-	if (mcch_sdu_length > 0) {
-	    LOG_D(MAC,
-		  "[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
-		  module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
-
-	    header_len_mcch = 2;
-
-	    if (cc->tdd_Config != NULL) {
-		LOG_D(MAC,
-		      "[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
-		      module_idP, CC_id, frameP, subframeP,
-		      mcch_sdu_length, mcch_mcs);
-	    } else {
-		LOG_D(MAC,
-		      "[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
-		      module_idP, CC_id, frameP, subframeP,
-		      mcch_sdu_length, mcch_mcs);
-	    }
-
-	    cc->mcch_active = 1;
-
-	    memcpy((char *) &mch_buffer[sdu_length_total]+1,
-		   &cc->MCCH_pdu.payload[0], mcch_sdu_length);
-	    sdu_lcids[num_sdus] = MCCH_LCHANID;
-	    sdu_lengths[num_sdus] = mcch_sdu_length;
-
-	    if (sdu_lengths[num_sdus] > 128) {
-		header_len_mcch = 3;
-	    }
-
-	    sdu_length_total += sdu_lengths[num_sdus];
-	    LOG_D(MAC,
-		  "[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
-		  module_idP, CC_id, sdu_lengths[num_sdus]);
-	    num_sdus++;
-	}
+  if (mcch_sdu_length > 0) {
+      LOG_D(MAC,
+      "[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
+      module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
+
+      header_len_mcch = 2;
+
+      if (cc->tdd_Config != NULL) {
+    LOG_D(MAC,
+          "[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
+          module_idP, CC_id, frameP, subframeP,
+          mcch_sdu_length, mcch_mcs);
+      } else {
+    LOG_D(MAC,
+          "[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
+          module_idP, CC_id, frameP, subframeP,
+          mcch_sdu_length, mcch_mcs);
+      }
+
+      cc->mcch_active = 1;
+
+      memcpy((char *) &mch_buffer[sdu_length_total]+1,
+       &cc->MCCH_pdu.payload[0], mcch_sdu_length);
+      sdu_lcids[num_sdus] = MCCH_LCHANID;
+      sdu_lengths[num_sdus] = mcch_sdu_length;
+
+      if (sdu_lengths[num_sdus] > 128) {
+    header_len_mcch = 3;
+      }
+
+      sdu_length_total += sdu_lengths[num_sdus];
+      LOG_D(MAC,
+      "[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
+      module_idP, CC_id, sdu_lengths[num_sdus]);
+      num_sdus++;
+  }
     }
 
     TBS =
-	get_TBS_DL(/*cc->pmch_Config[0]->dataMCS_r9*/cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
+  get_TBS_DL(/*cc->pmch_Config[0]->dataMCS_r9*/cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
     // do not let mcch and mtch multiplexing when relaying is active
     // for sync area 1, so not transmit data
     //if ((i == 0) && ((RC.mac[module_idP]->MBMS_flag != multicast_relay) || (RC.mac[module_idP]->mcch_active==0))) {
 
     // there is MTCHs, loop if there are more than 1
     if (mtch_flag == 1 ) {
-	// Calculate TBS
-	/* if ((msi_flag==1) || (mcch_flag==1)) {
-	   TBS = mac_xface->get_TBS(mcch_mcs, mac_xface->frame_parms->N_RB_DL);
-	   }
-	   else { // only MTCH in this subframeP
-	   TBS = mac_xface->get_TBS(RC.mac[module_idP]->pmch_Config[0]->dataMCS_r9, mac_xface->frame_parms->N_RB_DL);
-	   }
-
-	   // get MTCH data from RLC (like for DTCH)
-	   LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframe %d: Schedule MTCH (area %d, sfAlloc %d)\n",Mod_id,CC_id,frame,subframe,i,j);
-
-	   header_len_mtch = 3;
-	   LOG_D(MAC,"[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
-	   Mod_id,CC_id,frame,MTCH,TBS,
-	   TBS-header_len_mcch-header_len_msi-sdu_length_total-header_len_mtch);
-
-	   rlc_status = mac_rlc_status_ind(Mod_id,frame,1,RLC_MBMS_YES,MTCH+ (maxDRB + 3) * MAX_MOBILES_PER_RG,
-	   TBS-header_len_mcch-header_len_msi-sdu_length_total-header_len_mtch);
-	   printf("frame %d, subframe %d,  rlc_status.bytes_in_buffer is %d\n",frame,subframe, rlc_status.bytes_in_buffer);
-
-	 */
-
-	// get MTCH data from RLC (like for DTCH)
-	LOG_D(MAC,
-	      "[eNB %d] CC_id %d Frame %d subframeP %d: Schedule MTCH (area %d, sfAlloc %d)\n",
-	      module_idP, CC_id, frameP, subframeP, i, j);
-
-	header_len_mtch = 3;
-	LOG_D(MAC,
-	      "[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
-	      module_idP, CC_id, frameP, MTCH, TBS,
-	      TBS - header_len_mcch - header_len_msi - sdu_length_total -
-	      header_len_mtch);
-
-	mbms_rab_id = cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9;
-
-	rlc_status =
-	    mac_rlc_status_ind(module_idP, 0xfffd, frameP, subframeP,
-			       module_idP, ENB_FLAG_YES, MBMS_FLAG_YES,
-				cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9,
-			       //MTCH,
+  // Calculate TBS
+  /* if ((msi_flag==1) || (mcch_flag==1)) {
+     TBS = mac_xface->get_TBS(mcch_mcs, mac_xface->frame_parms->N_RB_DL);
+     }
+     else { // only MTCH in this subframeP
+     TBS = mac_xface->get_TBS(RC.mac[module_idP]->pmch_Config[0]->dataMCS_r9, mac_xface->frame_parms->N_RB_DL);
+     }
+
+     // get MTCH data from RLC (like for DTCH)
+     LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframe %d: Schedule MTCH (area %d, sfAlloc %d)\n",Mod_id,CC_id,frame,subframe,i,j);
+
+     header_len_mtch = 3;
+     LOG_D(MAC,"[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
+     Mod_id,CC_id,frame,MTCH,TBS,
+     TBS-header_len_mcch-header_len_msi-sdu_length_total-header_len_mtch);
+
+     rlc_status = mac_rlc_status_ind(Mod_id,frame,1,RLC_MBMS_YES,MTCH+ (maxDRB + 3) * MAX_MOBILES_PER_RG,
+     TBS-header_len_mcch-header_len_msi-sdu_length_total-header_len_mtch);
+     printf("frame %d, subframe %d,  rlc_status.bytes_in_buffer is %d\n",frame,subframe, rlc_status.bytes_in_buffer);
+
+   */
+
+  // get MTCH data from RLC (like for DTCH)
+  LOG_D(MAC,
+        "[eNB %d] CC_id %d Frame %d subframeP %d: Schedule MTCH (area %d, sfAlloc %d)\n",
+        module_idP, CC_id, frameP, subframeP, i, j);
+
+  header_len_mtch = 3;
+  LOG_D(MAC,
+        "[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
+        module_idP, CC_id, frameP, MTCH, TBS,
+        TBS - header_len_mcch - header_len_msi - sdu_length_total -
+        header_len_mtch);
+
+  mbms_rab_id = cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9;
+
+  rlc_status =
+      mac_rlc_status_ind(module_idP, 0xfffd, frameP, subframeP,
+             module_idP, ENB_FLAG_YES, MBMS_FLAG_YES,
+        cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9,
+             //MTCH,
                                      0, 0
                                     );
-	bytes_in_buffer = rlc_status.bytes_in_buffer;
+  bytes_in_buffer = rlc_status.bytes_in_buffer;
 
 
-	msi_sfs = rlc_status.bytes_in_buffer/TBS+(rlc_status.bytes_in_buffer%TBS?1:0);
+  msi_sfs = rlc_status.bytes_in_buffer/TBS+(rlc_status.bytes_in_buffer%TBS?1:0);
 
-	LOG_D(MAC,
-	      "e-MBMS log channel %u frameP %d, subframeP %d,  rlc_status.bytes_in_buffer is %d TBS %d pmch_stop %d msi_sfs %d\n",
-	      MTCH, frameP, subframeP, rlc_status.bytes_in_buffer,TBS,msi_pmch_stop,msi_sfs);
+  LOG_D(MAC,
+        "e-MBMS log channel %u frameP %d, subframeP %d,  rlc_status.bytes_in_buffer is %d TBS %d pmch_stop %d msi_sfs %d\n",
+        MTCH, frameP, subframeP, rlc_status.bytes_in_buffer,TBS,msi_pmch_stop,msi_sfs);
 
-	if (rlc_status.bytes_in_buffer > 0 ||  msi_pmch_stop > 0  /*msi_pmch_stop>=num_sf_alloc*/ ) {
-	    //if(rlc_status.bytes_in_buffer > 0){
-	    LOG_I(MAC,
-		  "[eNB %d][MBMS USER-PLANE], CC_id %d, Frame %d, MTCH->MCH, Requesting %d bytes from RLC (header len mtch %d) rlc_status.bytes_in_buffer %d\n",
-		  module_idP, CC_id, frameP,
-		  TBS - header_len_mcch - header_len_msi -
-		  sdu_length_total - header_len_mtch, header_len_mtch, rlc_status.bytes_in_buffer);
+  if (rlc_status.bytes_in_buffer > 0 ||  msi_pmch_stop > 0  /*msi_pmch_stop>=num_sf_alloc*/ ) {
+      //if(rlc_status.bytes_in_buffer > 0){
+      LOG_I(MAC,
+      "[eNB %d][MBMS USER-PLANE], CC_id %d, Frame %d, MTCH->MCH, Requesting %d bytes from RLC (header len mtch %d) rlc_status.bytes_in_buffer %d\n",
+      module_idP, CC_id, frameP,
+      TBS - header_len_mcch - header_len_msi -
+      sdu_length_total - header_len_mtch, header_len_mtch, rlc_status.bytes_in_buffer);
 
       sdu_lengths[num_sdus] = mac_rlc_data_req(module_idP, 0xfffd, module_idP, frameP, ENB_FLAG_YES, MBMS_FLAG_YES,cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9,
                                                TBS - header_len_mcch - header_len_msi - sdu_length_total - header_len_mtch,
-						     (char *)
-						     &mch_buffer[sdu_length_total]
+                 (char *)
+                 &mch_buffer[sdu_length_total]
                                 ,0,
                                  0
                                  );
-	
-	    //sdu_lengths[num_sdus] = mac_rlc_data_req(module_idP,frameP, MBMS_FLAG_NO,  MTCH+(MAX_NUM_RB*(MAX_MOBILES_PER_ENB+1)), (char*)&mch_buffer[sdu_length_total]);
-	    LOG_I(MAC,
-		  "[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_sfs %d sdu_lengths[num_sdus] %d\n",
-		  module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs, sdu_lengths[num_sdus]);
-	    cc->mtch_active = 1;
-	    sdu_lcids[num_sdus] = cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9/*MTCH*/;
-	    sdu_length_total += sdu_lengths[num_sdus];
-
-	    if (msi_pmch_stop != 0)
-	    	msi_pmch_stop--;
-
-
-	    if (sdu_lengths[num_sdus] < 128) {
-		header_len_mtch = 2;
-	    }
-
-	    num_sdus++;
-	  //}
-	} 
-	else {
-	//    LOG_E(MAC,
-	//	  "[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_buffer %d msi_sfs %ld msi_buffer_act %ld  sdu_lengths[num_sdus] %d\n",
-	//	  module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs,msi_buffer_act, sdu_lengths[num_sdus]);
-
-	    header_len_mtch = 0;
-	}
+  
+      //sdu_lengths[num_sdus] = mac_rlc_data_req(module_idP,frameP, MBMS_FLAG_NO,  MTCH+(MAX_NUM_RB*(MAX_MOBILES_PER_ENB+1)), (char*)&mch_buffer[sdu_length_total]);
+      LOG_I(MAC,
+      "[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_sfs %d sdu_lengths[num_sdus] %d\n",
+      module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs, sdu_lengths[num_sdus]);
+      cc->mtch_active = 1;
+      sdu_lcids[num_sdus] = cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9/*MTCH*/;
+      sdu_length_total += sdu_lengths[num_sdus];
+
+      if (msi_pmch_stop != 0)
+        msi_pmch_stop--;
+
+
+      if (sdu_lengths[num_sdus] < 128) {
+    header_len_mtch = 2;
+      }
+
+      num_sdus++;
+    //}
+  } 
+  else {
+  //    LOG_E(MAC,
+  //    "[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_buffer %d msi_sfs %ld msi_buffer_act %ld  sdu_lengths[num_sdus] %d\n",
+  //    module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs,msi_buffer_act, sdu_lengths[num_sdus]);
+
+      header_len_mtch = 0;
+  }
     }
     //  }
 
     // FINAL STEP: Prepare and multiplexe MSI, MCCH and MTCHs
     if ((sdu_length_total + header_len_msi + header_len_mcch +
-	 header_len_mtch) > 0) {
-	// Adjust the last subheader
-	/*                                 if ((msi_flag==1) || (mcch_flag==1)) {
-	   RC.mac[module_idP]->MCH_pdu.mcs = mcch_mcs;
-	   }
-	   else if (mtch_flag == 1) { // only MTCH in this subframeP
-	   RC.mac[module_idP]->MCH_pdu.mcs = RC.mac[module_idP]->pmch_Config[0]->dataMCS_r9;
-	   }
-	 */
-	header_len_mtch_temp = header_len_mtch;
-	header_len_mcch_temp = header_len_mcch;
-	header_len_msi_temp = header_len_msi;
-
-	if (header_len_mtch > 0) {
-	    header_len_mtch = 1;	// remove Length field in the  subheader for the last PDU
-	} else if (header_len_mcch > 0) {
-	    header_len_mcch = 1;
-	} else {
-	    header_len_msi = 1;
-	}
-
-	// Calculate the padding
-	if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
-	     sdu_length_total) < 0) {
-	    LOG_E(MAC, "Error in building MAC PDU, TBS %d < PDU %d \n",
-		  TBS,
-		  header_len_mtch + header_len_mcch + header_len_msi +
-		  sdu_length_total);
-	    return 0;
-	} else
-	    if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
-		 sdu_length_total) <= 2) {
-	    padding =
-		(TBS - header_len_mtch - header_len_mcch - header_len_msi -
-		 sdu_length_total);
-	    post_padding = 0;
-	} else {		// using post_padding, give back the Length field of subheader  for the last PDU
-	    padding = 0;
-
-	    if (header_len_mtch > 0) {
-		header_len_mtch = header_len_mtch_temp;
-	    } else if (header_len_mcch > 0) {
-		header_len_mcch = header_len_mcch_temp;
-	    } else {
-		header_len_msi = header_len_msi_temp;
-	    }
-
-	    post_padding =
-		TBS - sdu_length_total - header_len_msi - header_len_mcch -
-		header_len_mtch;
-	}
-
-	// Generate the MAC Header for MCH
-	// here we use the function for DLSCH because DLSCH & MCH have the same Header structure
-	offset = generate_dlsch_header((unsigned char *) cc->MCH_pdu.payload, num_sdus, sdu_lengths, sdu_lcids, 255,	// no drx
-				       31,	// no timing advance
-				       NULL,	// no contention res id
-				       padding, post_padding);
-
-	cc->MCH_pdu.Pdu_size = TBS;
-	cc->MCH_pdu.sync_area = i;
-	cc->MCH_pdu.msi_active = cc->msi_active;
-	cc->MCH_pdu.mcch_active = cc->mcch_active;
-	cc->MCH_pdu.mtch_active = cc->mtch_active;
-	LOG_D(MAC,
-	      " MCS for this sf is %d (mcch active %d, mtch active %d)\n",
-	      cc->MCH_pdu.mcs, cc->MCH_pdu.mcch_active,
-	      cc->MCH_pdu.mtch_active);
-	LOG_D(MAC,
-	      "[eNB %d][MBMS USER-PLANE ] CC_id %d Generate header : sdu_length_total %d, num_sdus %d, sdu_lengths[0] %d, sdu_lcids[0] %d => payload offset %d,padding %d,post_padding %d (mcs %d, TBS %d), header MTCH %d, header MCCH %d, header MSI %d\n",
-	      module_idP, CC_id, sdu_length_total, num_sdus,
-	      sdu_lengths[0], sdu_lcids[0], offset, padding, post_padding,
-	      cc->MCH_pdu.mcs, TBS, header_len_mtch, header_len_mcch,
-	      header_len_msi);
-	// copy SDU to mch_pdu after the MAC Header
-	memcpy(&cc->MCH_pdu.payload[offset], mch_buffer, sdu_length_total);
-
-	// filling remainder of MCH with random data if necessery
-	for (j = 0; j < (TBS - sdu_length_total - offset); j++) {
-	    cc->MCH_pdu.payload[offset + sdu_length_total + j] =
-		(char) (taus() & 0xff);
-	}
-
-	/* Tracing of PDU is done on UE side */
-	//if (opt_enabled == 1) {
-	    trace_pdu(DIRECTION_DOWNLINK, (uint8_t *) cc->MCH_pdu.payload, TBS, module_idP, WS_M_RNTI , 0xffff,	// M_RNTI = 6 in wirehsark
-		      RC.mac[module_idP]->frame,
-		      RC.mac[module_idP]->subframe, 0, 0);
-	    LOG_D(OPT,
-		  "[eNB %d][MCH] CC_id %d Frame %d : MAC PDU with size %d\n",
-		  module_idP, CC_id, frameP, TBS);
-	//}
-
-	/*
-	   for (j=0;j<sdu_length_total;j++)
-	   printf("%2x.",RC.mac[module_idP]->MCH_pdu.payload[j+offset]);
-	   printf(" \n"); */
-	return 1;
+   header_len_mtch) > 0) {
+  // Adjust the last subheader
+  /*                                 if ((msi_flag==1) || (mcch_flag==1)) {
+     RC.mac[module_idP]->MCH_pdu.mcs = mcch_mcs;
+     }
+     else if (mtch_flag == 1) { // only MTCH in this subframeP
+     RC.mac[module_idP]->MCH_pdu.mcs = RC.mac[module_idP]->pmch_Config[0]->dataMCS_r9;
+     }
+   */
+  header_len_mtch_temp = header_len_mtch;
+  header_len_mcch_temp = header_len_mcch;
+  header_len_msi_temp = header_len_msi;
+
+  if (header_len_mtch > 0) {
+      header_len_mtch = 1;  // remove Length field in the  subheader for the last PDU
+  } else if (header_len_mcch > 0) {
+      header_len_mcch = 1;
+  } else {
+      header_len_msi = 1;
+  }
+
+  // Calculate the padding
+  if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
+       sdu_length_total) < 0) {
+      LOG_E(MAC, "Error in building MAC PDU, TBS %d < PDU %d \n",
+      TBS,
+      header_len_mtch + header_len_mcch + header_len_msi +
+      sdu_length_total);
+      return 0;
+  } else
+      if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
+     sdu_length_total) <= 2) {
+      padding =
+    (TBS - header_len_mtch - header_len_mcch - header_len_msi -
+     sdu_length_total);
+      post_padding = 0;
+  } else {    // using post_padding, give back the Length field of subheader  for the last PDU
+      padding = 0;
+
+      if (header_len_mtch > 0) {
+    header_len_mtch = header_len_mtch_temp;
+      } else if (header_len_mcch > 0) {
+    header_len_mcch = header_len_mcch_temp;
+      } else {
+    header_len_msi = header_len_msi_temp;
+      }
+
+      post_padding =
+    TBS - sdu_length_total - header_len_msi - header_len_mcch -
+    header_len_mtch;
+  }
+
+  // Generate the MAC Header for MCH
+  // here we use the function for DLSCH because DLSCH & MCH have the same Header structure
+  offset = generate_dlsch_header((unsigned char *) cc->MCH_pdu.payload, num_sdus, sdu_lengths, sdu_lcids, 255,  // no drx
+               31,  // no timing advance
+               NULL,  // no contention res id
+               padding, post_padding);
+
+  cc->MCH_pdu.Pdu_size = TBS;
+  cc->MCH_pdu.sync_area = i;
+  cc->MCH_pdu.msi_active = cc->msi_active;
+  cc->MCH_pdu.mcch_active = cc->mcch_active;
+  cc->MCH_pdu.mtch_active = cc->mtch_active;
+  LOG_D(MAC,
+        " MCS for this sf is %d (mcch active %d, mtch active %d)\n",
+        cc->MCH_pdu.mcs, cc->MCH_pdu.mcch_active,
+        cc->MCH_pdu.mtch_active);
+  LOG_D(MAC,
+        "[eNB %d][MBMS USER-PLANE ] CC_id %d Generate header : sdu_length_total %d, num_sdus %d, sdu_lengths[0] %d, sdu_lcids[0] %d => payload offset %d,padding %d,post_padding %d (mcs %d, TBS %d), header MTCH %d, header MCCH %d, header MSI %d\n",
+        module_idP, CC_id, sdu_length_total, num_sdus,
+        sdu_lengths[0], sdu_lcids[0], offset, padding, post_padding,
+        cc->MCH_pdu.mcs, TBS, header_len_mtch, header_len_mcch,
+        header_len_msi);
+  // copy SDU to mch_pdu after the MAC Header
+  memcpy(&cc->MCH_pdu.payload[offset], mch_buffer, sdu_length_total);
+
+  // filling remainder of MCH with random data if necessery
+  for (j = 0; j < (TBS - sdu_length_total - offset); j++) {
+      cc->MCH_pdu.payload[offset + sdu_length_total + j] =
+    (char) (taus() & 0xff);
+  }
+
+  /* Tracing of PDU is done on UE side */
+  //if (opt_enabled == 1) {
+      trace_pdu(DIRECTION_DOWNLINK, (uint8_t *) cc->MCH_pdu.payload, TBS, module_idP, WS_M_RNTI , 0xffff,  // M_RNTI = 6 in wirehsark
+          RC.mac[module_idP]->frame,
+          RC.mac[module_idP]->subframe, 0, 0);
+      LOG_D(OPT,
+      "[eNB %d][MCH] CC_id %d Frame %d : MAC PDU with size %d\n",
+      module_idP, CC_id, frameP, TBS);
+  //}
+
+  /*
+     for (j=0;j<sdu_length_total;j++)
+     printf("%2x.",RC.mac[module_idP]->MCH_pdu.payload[j+offset]);
+     printf(" \n"); */
+  return 1;
     } else {
-	cc->MCH_pdu.Pdu_size = 0;
-	cc->MCH_pdu.sync_area = 0;
-	cc->MCH_pdu.msi_active = 0;
-	cc->MCH_pdu.mcch_active = 0;
-	cc->MCH_pdu.mtch_active = 0;
-	// for testing purpose, fill with random data
-	//for (j=0;j<(TBS-sdu_length_total-offset);j++)
-	//  RC.mac[module_idP]->MCH_pdu.payload[offset+sdu_length_total+j] = (char)(taus()&0xff);
-	return 0;
+  cc->MCH_pdu.Pdu_size = 0;
+  cc->MCH_pdu.sync_area = 0;
+  cc->MCH_pdu.msi_active = 0;
+  cc->MCH_pdu.mcch_active = 0;
+  cc->MCH_pdu.mtch_active = 0;
+  // for testing purpose, fill with random data
+  //for (j=0;j<(TBS-sdu_length_total-offset);j++)
+  //  RC.mac[module_idP]->MCH_pdu.payload[offset+sdu_length_total+j] = (char)(taus()&0xff);
+  return 0;
     }
 
     //this is for testing
@@ -1856,7 +1842,7 @@ schedule_MBMS(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
 }
 
 MCH_PDU *get_mch_sdu(module_id_t module_idP, int CC_id, frame_t frameP,
-		     sub_frame_t subframeP)
+         sub_frame_t subframeP)
 {
     //  RC.mac[module_idP]->MCH_pdu.mcs=0;
     //LOG_D(MAC," MCH_pdu.mcs is %d\n", RC.mac[module_idP]->MCH_pdu.mcs);
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_primitives.c b/openair2/LAYER2/MAC/eNB_scheduler_primitives.c
index d53e0cadd3..7a9c3305ba 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_primitives.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_primitives.c
@@ -38,6 +38,9 @@
 #include "common/utils/LOG/log.h"
 #include "nfapi/oai_integration/vendor_ext.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 #include "UTIL/OPT/opt.h"
 #include "OCG.h"
 #include "OCG_extern.h"
@@ -3983,6 +3986,9 @@ extract_harq(module_id_t mod_idP,
                     subframe_tx,
                     harq_pid,
                     sched_ctl->round[CC_idP][harq_pid]);
+#if LATSEQ
+              LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d.fm%d.subfm%d", 0, UE_id, harq_pid, frame_tx, subframe_tx);
+#endif
             } else { //nack
               if (sched_ctl->round[CC_idP][harq_pid] < 8) sched_ctl->round[CC_idP][harq_pid]++;
 
@@ -3998,6 +4004,9 @@ extract_harq(module_id_t mod_idP,
                     subframe_tx,
                     harq_pid,
                     sched_ctl->round[CC_idP][harq_pid]);
+#if LATSEQ
+              LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d.fm%d.subfm%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid, frame_tx, subframe_tx);
+#endif
 
               if (sched_ctl->round[CC_idP][harq_pid] == 8) {
                 for (uint8_t ra_i = 0; ra_i < NB_RA_PROC_MAX; ra_i++) {
@@ -4141,9 +4150,14 @@ extract_harq(module_id_t mod_idP,
             sched_ctl->tbcnt[CC_idP][harq_pid] = 0;
             /* CDRX: PUCCH gives an ACK, so reset corresponding HARQ RTT */
             sched_ctl->harq_rtt_timer[CC_idP][harq_pid] = 0;
+#if LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", 0, UE_id, harq_pid);
+#endif
           } else if (pdu[0] == 2 || pdu[0] == 4) {  // NAK (treat DTX as NAK)
             sched_ctl->round[CC_idP][harq_pid]++; // increment round
-
+#if LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
               sched_ctl->round[CC_idP][harq_pid] = 8; // release HARQ process
               sched_ctl->tbcnt[CC_idP][harq_pid] = 0;
@@ -4173,6 +4187,9 @@ extract_harq(module_id_t mod_idP,
           if (num_ack_nak == 2 && sched_ctl->round[CC_idP][harq_pid] < 8 && sched_ctl->tbcnt[CC_idP][harq_pid] == 1 && pdu[0] == 1 && pdu[1] == 1) {
             sched_ctl->round[CC_idP][harq_pid] = 8;
             sched_ctl->tbcnt[CC_idP][harq_pid] = 0;
+#if LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", 0, UE_id, harq_pid);
+#endif
             /* CDRX: PUCCH gives an ACK, so reset corresponding HARQ RTT */
             sched_ctl->harq_rtt_timer[CC_idP][harq_pid] = 0;
           }
@@ -4182,6 +4199,9 @@ extract_harq(module_id_t mod_idP,
               && (sched_ctl->tbcnt[CC_idP][harq_pid] == 1)
               && (pdu[0] == 2) && (pdu[1] == 2)) {
             sched_ctl->round[CC_idP][harq_pid]++;
+#if LATSEQ
+              LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
 
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
               sched_ctl->round[CC_idP][harq_pid] = 8;     // release HARQ process
@@ -4198,6 +4218,9 @@ extract_harq(module_id_t mod_idP,
                          && (sched_ctl->tbcnt[CC_idP][harq_pid] == 2)
                          && (pdu[0] == 2) && (pdu[1] == 1))) {
             sched_ctl->round[CC_idP][harq_pid]++;
+#if LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
             sched_ctl->tbcnt[CC_idP][harq_pid] = 1;
 
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
@@ -4211,6 +4234,9 @@ extract_harq(module_id_t mod_idP,
                      && (sched_ctl->tbcnt[CC_idP][harq_pid] == 2)
                      && (pdu[0] == 2) && (pdu[1] == 2)) {
             sched_ctl->round[CC_idP][harq_pid]++;
+#if LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
 
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
               sched_ctl->round[CC_idP][harq_pid] = 8;     // release HARQ process
@@ -4837,6 +4863,9 @@ extract_pusch_csi(module_id_t mod_idP,
       }
 
       sched_ctl->dl_cqi[CC_idP] = sched_ctl->aperiodic_wideband_cqi0[CC_idP];
+#if LATSEQ
+      LATSEQ_P("I phy.srs", "dcqi%d:ru%d.ue%d:", sched_ctl->dl_cqi[CC_idP], CC_idP, UE_id);
+#endif
       break;
 
     case LTE_CQI_ReportModeAperiodic_rm31:
@@ -5053,6 +5082,9 @@ SR_indication(module_id_t mod_idP,
 
       UE_info->UE_template[cc_idP][UE_id].ul_SR = 1;
       UE_info->UE_template[cc_idP][UE_id].ul_active = TRUE;
+#if LATSEQ
+      LATSEQ_P("I mac.ind", "sr%d:ue%d:fm%d.subfm%d", 1, UE_id, frameP, subframeP);
+#endif
       VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_SR_INDICATION, 1);
       VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_SR_INDICATION, 0);
     }
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c b/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c
index d4f486f761..30a11b7c03 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c
@@ -60,6 +60,9 @@
 #include "common/utils/lte/prach_utils.h"
 
 #include "T.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "common/ran_context.h"
 extern RAN_CONTEXT_t RC;
@@ -169,6 +172,11 @@ rx_sdu(const module_id_t enb_mod_idP,
        * lte_est_timing_advance_pusch, maybe it's not necessary?
        * maybe it's even not correct at all?
        */
+
+#if LATSEQ
+      LATSEQ_P("I phy.srs", "ucqi%d:ru%d.ue%d:", ul_cqi, CC_idP, UE_id);
+#endif
+
       UE_scheduling_control->ta_update_f = ((double)UE_scheduling_control->ta_update_f * 3 + (double)timing_advance) / 4;
       UE_scheduling_control->ta_update = (int)UE_scheduling_control->ta_update_f;
       int tmp_snr = (5 * ul_cqi - 640) / 10;
@@ -444,7 +452,9 @@ rx_sdu(const module_id_t enb_mod_idP,
           if (UE_template_ptr->phr_info > 40) {
             UE_template_ptr->phr_info = 40;
           }
-
+#if LATSEQ
+          LATSEQ_P("I mac.ind", "phr%d:ue%d:", UE_template_ptr->phr_info, UE_id);
+#endif
           LOG_D(MAC, "[eNB %d] CC_id %d MAC CE_LCID %d : Received PHR PH = %d (db)\n",
                 enb_mod_idP,
                 CC_idP,
@@ -594,6 +604,9 @@ rx_sdu(const module_id_t enb_mod_idP,
           int bsr = 0;
           bsr = payload_ptr[0] & 0x3f;
           lcgid_updated[lcgid] = 1;
+#if LATSEQ
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr, BSR_TABLE[bsr], UE_id, lcgid);
+#endif
           /* Update buffer info */
           UE_template_ptr->ul_buffer_info[lcgid] = BSR_TABLE[bsr];
           UE_template_ptr->estimated_ul_buffer =
@@ -646,6 +659,12 @@ rx_sdu(const module_id_t enb_mod_idP,
             UE_template_ptr->ul_buffer_info[LCGID1] +
             UE_template_ptr->ul_buffer_info[LCGID2] +
             UE_template_ptr->ul_buffer_info[LCGID3];
+#if LATSEQ
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr0, BSR_TABLE[bsr0], UE_id, 0);
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr1, BSR_TABLE[bsr1], UE_id, 1);
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr2, BSR_TABLE[bsr2], UE_id, 2);
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr3, BSR_TABLE[bsr3], UE_id, 3);
+#endif
           LOG_D(MAC, "[eNB %d] CC_id %d MAC CE_LCID %d: Received long BSR. Size is LCGID0 = %u LCGID1 = %u LCGID2 = %u LCGID3 = %u\n",
                 enb_mod_idP,
                 CC_idP,
@@ -965,6 +984,9 @@ rx_sdu(const module_id_t enb_mod_idP,
               }
             }
 
+#if LATSEQ
+              LATSEQ_P("U mac.harq.up--mac.demux", "len%d:rnti%d:ue%d.lcid%d.fm%d.subfm%d", rx_lengths[i], current_rnti, UE_id, rx_lcids[i], frameP, subframeP);
+#endif
               mac_rlc_data_ind(enb_mod_idP, current_rnti, enb_mod_idP, frameP, ENB_FLAG_YES, MBMS_FLAG_NO, rx_lcids[i], (char *) payload_ptr, rx_lengths[i], 1, NULL);
               UE_info->eNB_UE_stats[CC_idP][UE_id].num_pdu_rx[rx_lcids[i]] += 1;
               UE_info->eNB_UE_stats[CC_idP][UE_id].num_bytes_rx[rx_lcids[i]] += rx_lengths[i];
@@ -1481,8 +1503,8 @@ schedule_ulsch_rnti(module_id_t   module_idP,
                 rnti);
 
     /* Seems unused, only for debug */
-    RC.eNB[module_idP][CC_id]->pusch_stats_BO[UE_id][(frameP * 10) + subframeP] =
-        UE_template_ptr->estimated_ul_buffer;
+//    RC.eNB[module_idP][CC_id]->pusch_stats_BO[UE_id][(frameP * 10) + subframeP] = 
+//      UE_template_ptr->estimated_ul_buffer;
     VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_UE0_BO,
                                             UE_template_ptr->estimated_ul_buffer);
 
@@ -1646,6 +1668,27 @@ schedule_ulsch_rnti(module_id_t   module_idP,
 
       UE_info->eNB_UE_stats[CC_id][UE_id].ulsch_mcs2 = mcs;
 
+      uint8_t reserved_rb = 5;
+      uint8_t available_rb = 0;
+      switch (to_prb(cc[CC_id].ul_Bandwidth)) {
+        case 25:
+          available_rb = 25 - reserved_rb;
+          break;
+
+        case 50:
+          available_rb = 50 - reserved_rb;
+          break;
+
+        case 100:
+          available_rb = 100 - reserved_rb;
+          break;
+
+        default:
+          LOG_E(MAC, "RBs setting not handled. Todo.\n");
+          exit(1);
+      }
+      while (rb_table[rb_table_index] > available_rb && rb_table_index > 0)
+        rb_table_index--;
 
       UE_template_ptr->TBS_UL[harq_pid] = get_TBS_UL(mcs, rb_table[rb_table_index]);
       UE_info->eNB_UE_stats[CC_id][UE_id].total_rbs_used_rx += rb_table[rb_table_index];
@@ -1662,6 +1705,9 @@ schedule_ulsch_rnti(module_id_t   module_idP,
         T_INT(rb_table[rb_table_index]),
         T_INT(UE_template_ptr->TBS_UL[harq_pid]),
         T_INT(ndi));
+#if LATSEQ
+      LATSEQ_P("I mac.sched.up", "mcs%d.tbs%d.nrb%d:ue%d:fm%d.subfm%d", mcs, UE_info->eNB_UE_stats[CC_id][UE_id].ulsch_TBS, rb_table[rb_table_index], UE_id, frameP, subframeP);
+#endif
       /* Store information for possible retransmission */
       UE_template_ptr->nb_rb_ul[harq_pid] = rb_table[rb_table_index];
       UE_template_ptr->first_rb_ul[harq_pid] = UE_template_ptr->pre_first_nb_rb_ul;
diff --git a/openair2/LAYER2/PDCP_v10.1.0/pdcp.c b/openair2/LAYER2/PDCP_v10.1.0/pdcp.c
index 108a5dbe91..65847d05ce 100644
--- a/openair2/LAYER2/PDCP_v10.1.0/pdcp.c
+++ b/openair2/LAYER2/PDCP_v10.1.0/pdcp.c
@@ -82,6 +82,11 @@ hash_table_t  *pdcp_coll_p = NULL;
   static int mbms_socket = -1;
 #endif
 
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
+
 uint32_t Pdcp_stats_tx_window_ms[MAX_eNB][MAX_MOBILES_PER_ENB];
 uint32_t Pdcp_stats_tx_bytes[MAX_eNB][MAX_MOBILES_PER_ENB][NB_RB_MAX];
 uint32_t Pdcp_stats_tx_bytes_w[MAX_eNB][MAX_MOBILES_PER_ENB][NB_RB_MAX];
@@ -114,6 +119,7 @@ int pdcp_pc5_sockfd;
 struct sockaddr_in prose_ctrl_addr;
 struct sockaddr_in prose_pdcp_addr;
 struct sockaddr_in pdcp_sin;
+
 /* pdcp module parameters and related functions*/
 static pdcp_params_t pdcp_params= {0,NULL};
 rnti_t                 pdcp_UE_UE_module_id_to_rnti[MAX_MOBILES_PER_ENB];
@@ -424,6 +430,13 @@ boolean_t pdcp_data_req(
         VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_PDCP_DATA_REQ,VCD_FUNCTION_OUT);
         return FALSE;
       }
+#if LATSEQ
+      if (!srb_flagP) {
+        uint16_t ipid = sdu_buffer_pP[4] << 8 | sdu_buffer_pP[5];
+        LATSEQ_P("D pdcp.in--pdcp.tx","len%d:rnti%d:ipid0x%x.drb%d.gsn%d.psn%d", sdu_buffer_sizeP, ctxt_pP->rnti, ipid, rb_idP, 0, current_sn);
+      }
+#endif
+
 
       LOG_D(PDCP, "Sequence number %d is assigned to current PDU\n", current_sn);
       /* Then append data... */
@@ -1042,6 +1055,7 @@ pdcp_data_ind(
     return TRUE;
   }
 
+
   // XXX Decompression would be done at this point
   /*
    * After checking incoming sequence number PDCP header
@@ -1068,6 +1082,10 @@ pdcp_data_ind(
       GTPV1U_ENB_TUNNEL_DATA_REQ(message_p).offset       = GTPU_HEADER_OVERHEAD_MAX;
       GTPV1U_ENB_TUNNEL_DATA_REQ(message_p).rnti         = ctxt_pP->rnti;
       GTPV1U_ENB_TUNNEL_DATA_REQ(message_p).rab_id       = rb_id + 4;
+#if LATSEQ
+      uint16_t ipid = gtpu_buffer_p[GTPU_HEADER_OVERHEAD_MAX+4] << 8 | gtpu_buffer_p[GTPU_HEADER_OVERHEAD_MAX+5];
+      LATSEQ_P("U pdcp.rx--gtp.out","len%d:rnti%d:drb%d.psn%d.ipid0x%x", sdu_buffer_sizeP, ctxt_pP->rnti, rb_id, sequence_number, ipid);
+#endif
       itti_send_msg_to_task(TASK_GTPV1_U, INSTANCE_DEFAULT, message_p);
       packet_forwarded = TRUE;
     }
@@ -1147,11 +1165,18 @@ pdcp_data_ind(
       memcpy(pdcpHead+1,
              &sdu_buffer_pP->data[payload_offset],
              sdu_buffer_sizeP - payload_offset);
+
       if( LOG_DEBUGFLAG(DEBUG_PDCP) )
-	log_dump(PDCP, pdcpHead+1, min(sdu_buffer_sizeP - payload_offset,30) , LOG_DUMP_CHAR,
-	         "Printing first bytes of PDCP SDU before adding it to the list: \n");
+        log_dump(PDCP, pdcpHead+1, min(sdu_buffer_sizeP - payload_offset,30) , LOG_DUMP_CHAR,
+        "Printing first bytes of PDCP SDU before adding it to the list: \n");
+#if LATSEQ
+      if (srb_flagP == FALSE) {
+        LATSEQ_P("U pdcp.rx--pdcp.out","len%d:rnti%d:drb%d.lid%d.psn%d.fm%d",(sdu_buffer_sizeP - payload_offset), ctxt_pP->rnti, rb_id, pdcpHead->destinationL2Id, sequence_number, ctxt_pP->frame);
+      }
+#endif
       pushNotifiedFIFO(&pdcp_sdu_list, new_sdu_p); 
 
+
     /* Print octets of incoming data in hexadecimal form */
       LOG_D(PDCP, "Following content has been received from RLC (%d,%d)(PDCP header has already been removed):\n",
           sdu_buffer_sizeP  - payload_offset + (int)sizeof(pdcp_data_ind_header_t),
diff --git a/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c b/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c
index f6a61330d0..ed28d93799 100644
--- a/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c
+++ b/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c
@@ -57,6 +57,9 @@ extern int otg_enabled;
 #include "UTIL/OTG/otg_tx.h"
 #include "nfapi/oai_integration/vendor_ext.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 #include "platform_constants.h"
 #include "pdcp.h"
 
@@ -127,20 +130,31 @@ int pdcp_fifo_flush_sdus(const protocol_ctxt_t *const  ctxt_pP) {
         }
        else
        {
-	 if( LOG_DEBUGFLAG(DEBUG_PDCP) ) 
-	   log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
-	 ret = write(nas_sock_fd[pdcpHead->inst], pdcpData,pdcpHead->data_size );
-	 LOG_T(PDCP,"[UE PDCP_FIFOS] ret %d TRIED TO PUSH DATA TO rb_id %d handle %d sizeToWrite %d\n",
-	       ret,rb_id,nas_sock_fd[pdcpHead->inst],pdcpHead->data_size);
+    if( LOG_DEBUGFLAG(DEBUG_PDCP) ) {
+      log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
+    }
+
+      ret = write(nas_sock_fd[pdcpHead->inst], pdcpData,pdcpHead->data_size );
+      LOG_T(PDCP,"[UE PDCP_FIFOS] ret %d TRIED TO PUSH DATA TO rb_id %d handle %d sizeToWrite %d\n",
+         ret,rb_id,nas_sock_fd[pdcpHead->inst],pdcpHead->data_size);
        }
     } else if (ENB_NAS_USE_TUN) {
-      if( LOG_DEBUGFLAG(DEBUG_PDCP) ) 
-	log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
+
+      if( LOG_DEBUGFLAG(DEBUG_PDCP) ) {
+        log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
+      }
+#if LATSEQ
+      LATSEQ_P("U pdcp.out.nas--ip.out", "len%d:rnti%d:drb%d.sock%d.lid%d.fm%d", pdcpHead->data_size, ctxt_pP->rnti, rb_id, nas_sock_fd[0], pdcpHead->destinationL2Id, ctxt_pP->frame);
+#endif
       ret = write(nas_sock_fd[0], pdcpData, pdcpHead->data_size);
        LOG_T(PDCP,"[NB PDCP_FIFOS] ret %d TRIED TO PUSH DATA TO rb_id %d handle %d sizeToWrite %d\n",ret,rb_id,nas_sock_fd[0],pdcpHead->data_size);
     } else if (PDCP_USE_NETLINK) {
       int sizeToWrite= sizeof (pdcp_data_ind_header_t) + pdcpHead->data_size;
+#if LATSEQ
+      LATSEQ_P("U pdcp.out.nl--ip.out", "len%d:rnti%d:drb%d.sock%d.lid%d.fm%d", sizeToWrite, ctxt_pP->rnti, rb_id, nas_sock_fd[0], pdcpHead->destinationL2Id, ctxt_pP->frame);
+#endif
       memcpy(NLMSG_DATA(nas_nlh_tx), (uint8_t *) pdcpHead,  sizeToWrite);
+
       nas_nlh_tx->nlmsg_len = sizeToWrite;
       ret = sendmsg(nas_sock_fd[0],&nas_msg_tx,0);
     }  //  PDCP_USE_NETLINK
@@ -272,7 +286,9 @@ int pdcp_fifo_read_input_sdus_fromtun (const protocol_ctxt_t *const  ctxt_pP) {
       LOG_D(PDCP, "[FRAME %5u][UE][IP][INSTANCE %ld][RB %ld][--- PDCP_DATA_REQ / %d Bytes --->][PDCP][MOD %u][UE %04x][RB %ld]\n",
             ctxt.frame, ctxt.instance, rab_id, len, ctxt.module_id,
             ctxt.rnti, rab_id);
-
+#if LATSEQ
+      LATSEQ_P("D ip.in--pdcp.in.tun", "len%d:rnti%d:drb%d", len, ctxt.rnti, rab_id);
+#endif
 #if defined  ENABLE_PDCP_PAYLOAD_DEBUG
       LOG_I(PHY, "TUN interface output received from PDCP: \n");
       for (int i = 0; i < 128; i++) {
@@ -400,7 +416,6 @@ int pdcp_fifo_read_input_sdus_fromnetlinksock (const protocol_ctxt_t *const  ctx
     VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PDCP_FIFO_READ_BUFFER, 1 );
     len = recvmsg(nas_sock_fd[0], &nas_msg_rx, 0);
     VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PDCP_FIFO_READ_BUFFER, 0 );
-
     if (len > 0) {
       for (nas_nlh_rx = (struct nlmsghdr *) nl_rx_buf;
            NLMSG_OK (nas_nlh_rx, len);
@@ -463,6 +478,9 @@ int pdcp_fifo_read_input_sdus_fromnetlinksock (const protocol_ctxt_t *const  ctx
                       ctxt.module_id,
                       ctxt.rnti,
                       rab_id);
+#if LATSEQ
+                LATSEQ_P("D ip--pdcp.in.nl", "len%d:rnti%d:drb%d", pdcp_read_header_g.data_size, ctxt.rnti, rab_id);
+#endif
                 pdcp_data_req(&ctxt,
                               SRB_FLAG_NO,
                               rab_id,
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c
index 4eb0907046..29ee5b93e1 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c
@@ -38,6 +38,9 @@
 #include "common/utils/LOG/log.h"
 #include "LTE_UL-AM-RLC.h"
 #include "LTE_DL-AM-RLC.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 uint32_t
@@ -645,6 +648,10 @@ rlc_am_mac_data_request (
             LOG_UI(RLC,"%s\n",message_string);
           } /* LOG_DEBUGFLAG(DEBUG_RLC) */
         }
+#if LATSEQ
+    LATSEQ_P("D rlc.seg.am--mac.mux","len%d:rnti%d:drb%d.lcid%d.rsn%d.reqfm%d", tb_size_in_bytes, ctxt_pP->rnti, l_rlc_p->rb_id, l_rlc_p->channel_id, pdu_info.sn , ctxt_pP->frame);
+    //.so%d : pdu_info.so
+#endif
       } else {
         if (rlc_am_get_control_pdu_infos(rlc_am_pdu_sn_10_p, &tb_size_in_bytes, &l_rlc_p->control_pdu_info) >= 0) {
           tb_size_in_bytes   = ((struct mac_tb_req *) (tb_p->data))->tb_size; //tb_size_in_bytes modified by rlc_am_get_control_pdu_infos!
@@ -885,7 +892,13 @@ rlc_am_data_req (
       message_string_size += sprintf(&message_string[message_string_size], " |\n");
       LOG_UI(RLC, "%s\n", message_string);
     } /* LOG_DEBUGFLAG(RLC) */
-
+#if LATSEQ
+    // Not necessary to detect userplane, because if it is the case
+    // then a rebuilding, no user data at input point
+    // but input point may belongs to userplane only
+    uint8_t seqnum = ((uint8_t *)(&sdu_pP->data[data_offset]))[1];
+    LATSEQ_P("D pdcp.tx--rlc.tx.am","len%d:rnti%d:drb%d.psn%d.lcid%d.rsdu%d", ((struct rlc_am_data_req *) (sdu_pP->data))->data_size, ctxt_pP->rnti, l_rlc_p->rb_id, seqnum, l_rlc_p->channel_id, l_rlc_p->next_sdu_index);
+#endif
     l_rlc_p->stat_tx_pdcp_sdu   += 1;
     l_rlc_p->stat_tx_pdcp_bytes += data_size;
     l_rlc_p->input_sdus[l_rlc_p->next_sdu_index].mui      = mui;
@@ -907,6 +920,9 @@ rlc_am_data_req (
     l_rlc_p->input_sdus[l_rlc_p->next_sdu_index].flags.no_new_sdu_segmented_in_last_pdu = 0;
     //l_rlc_p->input_sdus[l_rlc_p->next_sdu_index].li_index_for_discard = -1;
     l_rlc_p->next_sdu_index = (l_rlc_p->next_sdu_index + 1) % RLC_AM_SDU_CONTROL_BUFFER_SIZE;
+#if LATSEQ
+    LATSEQ_P("I rlc.am.txbuf","occ%d:drb%d", l_rlc_p->sdu_buffer_occupancy, l_rlc_p->rb_id);
+#endif
 
     if (l_rlc_p->channel_id <3) {
       LOG_I(RLC, PROTOCOL_RLC_AM_CTXT_FMT" RLC_AM_DATA_REQ size %d Bytes,  NB SDU %d current_sdu_index=%d next_sdu_index=%d conf %d mui %d vtA %d vtS %d\n",
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c
index 0957c20bdf..145217799f 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c
@@ -30,6 +30,10 @@
 #include "list.h"
 //#include "LAYER2/MAC/extern.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 
 //-----------------------------------------------------------------------------
 inline void
@@ -151,6 +155,20 @@ rlc_am_send_sdu (
 #if !ENABLE_ITTI
       RLC_AM_MUTEX_UNLOCK(&rlc_pP->lock_input_sdus);
 #endif
+
+#if LATSEQ
+      //there is 2 cases for pdcp sn lenght. Put the 2 possibilities...
+      // Copied from these functions
+      // pdcp_get_sequence_number_of_pdu_with_short_sn
+      // pdcp_get_sequence_number_of_pdu_with_long_sn
+
+      uint8_t psn_short = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x7F;
+      uint16_t psn_long = 0x00;
+      psn_long = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x0F;
+      psn_long <<= 8;
+      psn_long |= (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[1] & 0xFF;
+      LATSEQ_P("U rlc.rx.am--pdcp.rx","len%d:rnti%d:drb%d.lcid%d.rsn%d.psn%d.psn%d.fm%d", rlc_pP->output_sdu_size_to_write, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->vr_r, psn_short, psn_long, ctxt_pP->frame);
+#endif
       rlc_data_ind (ctxt_pP,
                     BOOL_NOT(rlc_pP->is_data_plane),
                     MBMS_FLAG_NO,
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c
index 916d1513b0..9537db7463 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c
@@ -29,7 +29,9 @@
 #include "list.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
-
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 signed int
@@ -345,6 +347,7 @@ rlc_am_receive_process_data_pdu (
             rlc_pP->vr_ms,
             rlc_pP->vr_x);
 
+
       pdu_status = rlc_am_rx_list_check_duplicate_insert_pdu(ctxt_pP, rlc_pP,tb_pP);
       if (pdu_status != RLC_AM_DATA_PDU_STATUS_OK) {
         rlc_pP->stat_rx_data_pdu_dropped     += 1;
@@ -521,7 +524,11 @@ if( (((rlc_am_rx_pdu_management_t*)(tb_pP->data))->all_segments_received) == (pd
       LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU]  PDU DISCARDED BAD HEADER FORMAT SN=%d\n",
             PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_info_p->sn);
   }
-
+#if LATSEQ
+  // rlc_pP->vr_r fix pas terrible mais qui fera l'affaire pour l'instant
+  if (pdu_status == RLC_AM_DATA_PDU_STATUS_OK)
+    LATSEQ_P("U mac.demux--rlc.rx.am", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.fm%d", tb_size_in_bytesP, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->vr_r, pdu_info_p->so, ctxt_pP->frame);
+#endif
   if (pdu_status != RLC_AM_DATA_PDU_STATUS_OK) {
 	  /* Discard received block if out of window, duplicate or header error */
       free_mem_block (tb_pP, __func__);
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c
index 4a06553901..cc1c64a0b1 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c
@@ -453,8 +453,8 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
               LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT SN=%d SOSTART=%d] PDU SEGMENT INSERTED AFTER PDU SEGMENT WITH SOEND=%d\n",
                           PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn,so_start_segment,
 						  pdu_info_previous_cursor_p->so + pdu_info_previous_cursor_p->payload_size - 1);
-
 			  list2_insert_after_element(tb_pP, previous_cursor_p, &rlc_pP->receiver_buffer);
+
 			  return RLC_AM_DATA_PDU_STATUS_OK;
 		  }
 
@@ -538,7 +538,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
               LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT SN=%d SOSTART=%d SOEND=%d] PDU SEGMENT INSERTED BEFORE PDU SEGMENT WITH SOSTART=%d\n",
                             PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn,so_start_segment,so_end_segment,
 							pdu_info_cursor_p->so);
-
 			  list2_insert_before_element(tb_pP, cursor_p, &rlc_pP->receiver_buffer);
 			  return RLC_AM_DATA_PDU_STATUS_OK;
 		  }
@@ -606,7 +605,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
 	              LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT SN=%d SOSTART=%d] PDU SEGMENT INSERTED AFTER PDU SEGMENT WITH SOEND=%d\n",
 	                          PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn,so_start_segment,
 							  pdu_info_previous_cursor_p->so + pdu_info_previous_cursor_p->payload_size - 1);
-
 				  list2_insert_after_element(tb_pP, previous_cursor_p, &rlc_pP->receiver_buffer);
 				  return RLC_AM_DATA_PDU_STATUS_OK;
 			  }
@@ -705,7 +703,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
 	  if (trunc_segment != NULL) {
 		  LOG_I(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT]  CREATE SEGMENT FROM SEGMENT OFFSET=%d DATA LENGTH=%d SN=%d\n",
 						  PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),so_start_segment - pdu_rx_info_p->so,so_end_segment - so_start_segment + 1,pdu_rx_info_p->sn);
-
 		  if (previous_cursor_p != NULL) {
 			  list2_insert_after_element(trunc_segment, previous_cursor_p, &rlc_pP->receiver_buffer);
 		  }
@@ -779,7 +776,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu(
                             pdu_info_cursor_p->sn);
 	          list2_insert_before_element(tb_pP, cursor_p, &rlc_pP->receiver_buffer);
 	      }
-
 		  return pdu_status;
 	  }
 
@@ -811,14 +807,12 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu(
 
 	      LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU]  PDU REPLACES STORED PDU SEGMENTS SN=%d\n",
 	              PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn);
-
 	      if (previous_cursor_p != NULL) {
 	          list2_insert_after_element(tb_pP, previous_cursor_p, &rlc_pP->receiver_buffer);
 	      }
 	      else {
 	          list2_insert_before_element(tb_pP, cursor_next_p, &rlc_pP->receiver_buffer);
 	      }
-
 		  return pdu_status;
 	  } // End SN != vrR or SO != 0
 	  else {
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c
index ed81e119ac..c618b0ce3b 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c
@@ -30,6 +30,9 @@
 #include "rlc_am.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 void rlc_am_pdu_polling (
@@ -549,6 +552,11 @@ void rlc_am_segment_10 (
     pdu_mngt_p->flags.transmitted = 1;
     pdu_mngt_p->sn = RLC_AM_PREV_SN(rlc_pP->vt_s);
 
+#if LATSEQ
+    for (int i=0; i < pdu_mngt_p->nb_sdus; i++) {
+      LATSEQ_P("D rlc.tx.am--rlc.seg.am","len%d:rnti%d:drb%d.lcid%d.rsdu%d.rsn%d", pdu_mngt_p->header_and_payload_size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, pdu_mngt_p->sdus_index[i], pdu_mngt_p->sn);
+    }
+#endif
 
     //TBC: What for resetting local pointers at the end ??
     pdu_p = NULL;
diff --git a/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c b/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c
index 4e3fffe176..b98379825d 100644
--- a/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c
+++ b/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c
@@ -30,6 +30,9 @@
 #include "rlc_primitives.h"
 #include "list.h"
 #include "LAYER2/MAC/mac_extern.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 //-----------------------------------------------------------------------------
 void
 rlc_tm_send_sdu (
@@ -67,7 +70,20 @@ rlc_tm_send_sdu (
 #endif
 
     memcpy (&rlc_pP->output_sdu_in_construction->data[rlc_pP->output_sdu_size_to_write], srcP, length_in_bytes);
-
+#if LATSEQ
+    if (rlc_pP->is_data_plane) {
+      //there is 2 cases for pdcp sn lenght. Put the 2 possibilities...
+      // Copied from these functions
+      // pdcp_get_sequence_number_of_pdu_with_short_sn
+      // pdcp_get_sequence_number_of_pdu_with_long_sn
+      uint8_t psn_short = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x7F;
+      uint16_t psn_long = 0x00;
+      psn_long = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x0F;
+      psn_long <<= 8;
+      psn_long |= (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[1] & 0xFF;
+      LATSEQ_P("U mac.demux--pdcp.rx","len%d:rnti%d:drb%d.lcid%d.psn%d.psn%d.fm%d", length_in_bytes, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, psn_short, psn_long, ctxt_pP->frame);
+    }
+#endif
     rlc_data_ind (
       ctxt_pP,
       BOOL_NOT(rlc_pP->is_data_plane),
@@ -114,12 +130,14 @@ rlc_tm_no_segment (
     ((struct mac_tb_req *) (pdu_p->data))->first_bit = 0;
     ((struct mac_tb_req *) (pdu_p->data))->tb_size = rlc_pP->rlc_pdu_size >> 3;
     list_add_tail_eurecom (pdu_p, &rlc_pP->pdus_to_mac_layer);
-
     rlc_pP->buffer_occupancy -= (sdu_mngt_p->sdu_size >> 3);
     free_mem_block (rlc_pP->input_sdus[rlc_pP->current_sdu_index], __func__);
     rlc_pP->input_sdus[rlc_pP->current_sdu_index] = NULL;
     rlc_pP->current_sdu_index = (rlc_pP->current_sdu_index + 1) % rlc_pP->size_input_sdus_buffer;
     rlc_pP->nb_sdu -= 1;
+#if LATSEQ
+    LATSEQ_P("D rlc.tx.tm--mac.mux","len%d:rnti%d:drb%d.lcid%d.rsdu%d.fm%d", sdu_mngt_p->sdu_size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->current_sdu_index, ctxt_pP->frame);
+#endif
   }
 }
 //-----------------------------------------------------------------------------
@@ -223,7 +241,13 @@ rlc_tm_data_req (
          rlc_p->current_sdu_index,
          rlc_p->next_sdu_index);
 #endif
-
+#if LATSEQ
+  // Not necessary to detect userplane, because if it is the case
+  // then a rebuilding, no user data at input point
+  // but input point may belongs to userplane only
+  uint8_t seqnum = (uint8_t)((unsigned char *)&sdu_pP->data)[1];
+  LATSEQ_P("D pdcp.tx--rlc.tx.tm","len%d:rnti%d:drb%d.lcid%d.psn%d.rsdu%d", ((struct rlc_um_data_req *) (sdu_pP->data))->data_size, ctxt_pP->rnti, rlc_p->rb_id, rlc_p->channel_id, seqnum, rlc_p->current_sdu_index);
+#endif
   // not in 3GPP specification but the buffer may be full if not correctly configured
   if (rlc_p->input_sdus[rlc_p->next_sdu_index] == NULL) {
     ((struct rlc_tm_tx_sdu_management *) (sdu_pP->data))->sdu_size = ((struct rlc_tm_data_req *) (sdu_pP->data))->data_size;
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c
index 1d40b12cc8..cf736dc3e0 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c
@@ -36,7 +36,9 @@
 #include "mac_primitives.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
-
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "rlc_um_very_simple_test.h"
 
@@ -477,6 +479,7 @@ rlc_um_mac_data_request (const protocol_ctxt_t *const ctxt_pP, void *rlc_pP,cons
            */
         }
 
+
         /*
          * Append enough spaces and put final pipe
          */
@@ -486,8 +489,11 @@ rlc_um_mac_data_request (const protocol_ctxt_t *const ctxt_pP, void *rlc_pP,cons
 
         message_string_size += sprintf(&message_string[message_string_size], " |\n");
         LOG_UI(RLC, "%s\n", message_string);
-      } /* LOG_DEBUGFLAG(DEBUG_RLC) */
 
+      } /* LOG_DEBUGFLAG(DEBUG_RLC) */
+#if LATSEQ
+      LATSEQ_P("D rlc.seg.um--mac.mux","len%d:rnti%d:drb%d.lcid%d.rsn%d.fm%d", tb_size_in_bytes, ctxt_pP->rnti, l_rlc_p->rb_id,l_rlc_p->channel_id, pdu_info.sn, ctxt_pP->frame);
+#endif
       tb_p = tb_p->next;
     } /* while (tb_p != NULL) */
   } /* if (data_req.data.nb_elements > 0) */
@@ -566,9 +572,21 @@ rlc_um_data_req (const protocol_ctxt_t *const ctxt_pP, void *rlc_pP, mem_block_t
 
     LOG_UI(RLC, "%s|\n", message_string);
   }
+#if LATSEQ
+  // Not necessary to detect userplane, because if it is the case
+  // then a rebuilding, no user data at input point
+  // but input point may belongs to userplane only
+  uint8_t seqnum = ((uint8_t *)(&sdu_pP->data[sizeof (struct rlc_um_data_req_alloc)]))[1];
+  uint16_t ssize = ((struct rlc_um_tx_sdu_management *) (sdu_pP->data))->sdu_size;
+  LATSEQ_P("D pdcp.tx--rlc.tx.um","len%d:rnti%d:drb%d.psn%d.lcid%d.rsdu%d", ssize, ctxt_pP->rnti, rlc_p->rb_id, seqnum, rlc_p->channel_id, ssize);
+#endif
+
 
   RLC_UM_MUTEX_LOCK(&rlc_p->lock_input_sdus, ctxt_pP, rlc_p);
   rlc_p->buffer_occupancy += ((struct rlc_um_tx_sdu_management *) (sdu_pP->data))->sdu_size;
+#if LATSEQ
+  LATSEQ_P("I rlc.um.txbuf","occ%d:drb%d", rlc_p->buffer_occupancy, rlc_p->rb_id);
+#endif
   list_add_tail_eurecom(sdu_pP, &rlc_p->input_sdus);
   RLC_UM_MUTEX_UNLOCK(&rlc_p->lock_input_sdus);
 
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c
index 6d2380d4ff..73bd9eeeb3 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c
@@ -31,6 +31,10 @@
 #include "list.h"
 #include "common/utils/LOG/log.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 //-----------------------------------------------------------------------------
 signed int rlc_um_get_pdu_infos(
   const protocol_ctxt_t* const ctxt_pP,
@@ -338,7 +342,10 @@ rlc_um_try_reassembly(
         }
         continue;
       }
-
+#if LATSEQ
+      if (rlc_pP->is_data_plane)
+        LATSEQ_P("U rlc.rx.um--rlc.unseg.um","len%d:rnti%d:drb%d.lcid%d.rsn%d.fm%d", size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->last_reassemblied_sn, ctxt_pP->frame);
+#endif
       if (e == RLC_E_FIXED_PART_DATA_FIELD_FOLLOW) {
         switch (fi) {
         case RLC_FI_1ST_BYTE_DATA_IS_1ST_BYTE_SDU_LAST_BYTE_DATA_IS_LAST_BYTE_SDU:
@@ -1040,6 +1047,7 @@ rlc_um_receive_process_dar (
     return;
   }
 
+
   RLC_UM_MUTEX_LOCK(&rlc_pP->lock_dar_buffer, ctxt_pP, rlc_pP);
 
   in_window = rlc_um_in_window(ctxt_pP, rlc_pP, rlc_pP->vr_uh - rlc_pP->rx_um_window_size, sn, rlc_pP->vr_ur);
@@ -1099,7 +1107,9 @@ rlc_um_receive_process_dar (
     mem_block_t *pdu = rlc_um_remove_pdu_from_dar_buffer(ctxt_pP, rlc_pP, sn);
     free_mem_block(pdu, __func__);
   }
-
+#if LATSEQ
+  LATSEQ_P("U mac.demux--rlc.rx.um","len%d:rnti%d:drb%d.lcid%d.rsn%d.fm%d", tb_sizeP, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, sn, ctxt_pP->frame);
+#endif
   rlc_um_store_pdu_in_dar_buffer(ctxt_pP, rlc_pP, pdu_mem_pP, sn);
 
 
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c
index ca43dab667..02219d8d36 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c
@@ -35,6 +35,10 @@
 #include "list.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 
 //-----------------------------------------------------------------------------
 inline void
@@ -126,6 +130,20 @@ rlc_um_send_sdu (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP)
       rlc_um_v9_3_0_test_data_ind (rlc_pP->module_id, rlc_pP->rb_id, rlc_pP->output_sdu_size_to_write, rlc_pP->output_sdu_in_construction);
 #else
       // msg("[RLC] DATA IND ON MOD_ID %d RB ID %d, size %d\n",rlc_pP->module_id, rlc_pP->rb_id, ctxt_pP->frame,rlc_pP->output_sdu_size_to_write);
+#if LATSEQ
+      //there is 2 cases for pdcp sn lenght. Put the 2 possibilities...
+      // Copied from these functions
+      // pdcp_get_sequence_number_of_pdu_with_short_sn
+      // pdcp_get_sequence_number_of_pdu_with_long_sn
+      //if (rlc_pP->is_data_plane) {
+      uint8_t psn_short = (uint8_t)((unsigned char *)(rlc_pP->output_sdu_in_construction)->data)[0] & 0x7F;
+      uint16_t psn_long = 0x00;
+      psn_long = (uint8_t)((unsigned char *)(rlc_pP->output_sdu_in_construction)->data)[0] & 0x0F;
+      psn_long <<= 8;
+      psn_long |= (uint8_t)((unsigned char *)(rlc_pP->output_sdu_in_construction)->data)[1] & 0xFF;
+      LATSEQ_P("U rlc.unseg.um--pdcp.rx","len%d:rnti%d:drb%d.lcid%d.rsn%d.psn%d.psn%d.fm%d", rlc_pP->output_sdu_size_to_write, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->last_reassemblied_sn, psn_short, psn_long, ctxt_pP->frame);
+      //}
+#endif
       rlc_data_ind (
         ctxt_pP,
         BOOL_NOT(rlc_pP->is_data_plane),
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c
index 4c047e3d92..3e87342e1b 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c
@@ -31,6 +31,9 @@
 #include "rlc_um.h"
 #include "rlc_primitives.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 void
@@ -252,6 +255,9 @@ rlc_um_segment_10 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP
       }
 
       data_sdu_p = (char *) &(sdu_in_buffer->data[sizeof (struct rlc_um_tx_sdu_management) + sdu_mngt_p->sdu_segmented_size]);
+#if LATSEQ
+      LATSEQ_P("D rlc.tx.um--rlc.seg.um","len%d:rnti%d:drb%d.lcid%d.rsdu%d.rsn%d.rso%d", sdu_mngt_p->sdu_size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, sdu_mngt_p->sdu_size, rlc_pP->vt_us, sdu_mngt_p->sdu_segmented_size);
+#endif
 
       if (sdu_mngt_p->sdu_remaining_size > pdu_remaining_size) {
 #if TRACE_RLC_UM_SEGMENT
@@ -367,6 +373,7 @@ rlc_um_segment_10 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP
 //#if !EXMIMO
 //        assert(1!=1);
 //#endif
+
         memcpy(data, data_sdu_p, sdu_mngt_p->sdu_remaining_size);
         // reduce the size of the PDU
         continue_fill_pdu_with_sdu = 0;
@@ -623,6 +630,7 @@ rlc_um_segment_5 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP)
       fi_first_byte_pdu_is_first_byte_sdu = 1;
     }
 
+    // While a new sdu_in_buffer (input_sdus not empty) or continue_fill_pdu_with_sdu (means we have to continue filling a mac pdu)
     while ((sdu_in_buffer) && (continue_fill_pdu_with_sdu > 0)) {
       sdu_mngt_p = ((struct rlc_um_tx_sdu_management *) (sdu_in_buffer->data));
 
@@ -645,6 +653,12 @@ rlc_um_segment_5 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP)
 
       data_sdu_p = (char*) &(sdu_in_buffer->data[sizeof (struct rlc_um_tx_sdu_management) + sdu_mngt_p->sdu_segmented_size]);
 
+      //LATSEQ : first place for rlc.tx.um--rlc.seg.um
+
+#if LATSEQ
+      LATSEQ_P("D rlc.tx.um--rlc.seg.um","len%d:drb%d.rnti%d.fm%d:lcid%d.rsdu%d.rsn%d.rso%d", sdu_mngt_p->sdu_size, rlc_pP->rb_id, ctxt_pP->rnti, ctxt_pP->frame, rlc_pP->channel_id, sdu_mngt_p->sdu_creation_time, rlc_pP->vt_us, sdu_mngt_p->sdu_segmented_size);
+#endif
+
       if (sdu_mngt_p->sdu_remaining_size > pdu_remaining_size) {
 #if TRACE_RLC_UM_SEGMENT
         LOG_D(RLC, PROTOCOL_RLC_UM_CTXT_FMT" Filling all remaining PDU with %d bytes\n",
diff --git a/openair2/LAYER2/RLC/rlc_mac.c b/openair2/LAYER2/RLC/rlc_mac.c
index 89cbe4c406..2749188563 100644
--- a/openair2/LAYER2/RLC/rlc_mac.c
+++ b/openair2/LAYER2/RLC/rlc_mac.c
@@ -37,7 +37,6 @@
 #include "hashtable.h"
 #include "assertions.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
-
 //#define DEBUG_MAC_INTERFACE 1
 
 //-----------------------------------------------------------------------------
@@ -74,9 +73,11 @@ struct mac_data_ind mac_rlc_deserialize_tb (
       LOG_T(RLC, "[MAC-RLC] DUMP RX PDU(%d bytes):\n", tb_sizeP);
       rlc_util_print_hex_octets(RLC, ((struct mac_tb_ind *) (tb_p->data))->data_ptr, tb_sizeP);
 #endif
+
       nb_tb_read = nb_tb_read + 1;
       tbs_size   = tbs_size   + tb_sizeP;
       list_add_tail_eurecom(tb_p, &data_ind.data);
+      
     }
 
     num_tbP = num_tbP - 1;
@@ -218,6 +219,7 @@ tbs_size_t mac_rlc_data_req(
     T(T_ENB_RLC_MAC_DL, T_INT(module_idP), T_INT(rntiP), T_INT(channel_idP), T_INT(ret_tb_size));
 
 #endif
+
   VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_MAC_RLC_DATA_REQ,VCD_FUNCTION_OUT);
   return ret_tb_size;
 }
@@ -282,6 +284,7 @@ void mac_rlc_data_ind     (
     rlc_mode = RLC_MODE_NONE;
     //AssertFatal (0 , "%s RLC not configured lcid %u ! (h_rc %d)\n", __FUNCTION__,channel_idP,h_rc);
   }
+/*
 
   struct mac_data_ind data_ind = mac_rlc_deserialize_tb(buffer_pP, tb_sizeP, num_tbP, crcs_pP);
 
diff --git a/openair2/LAYER2/RLC/rlc_rrc.c b/openair2/LAYER2/RLC/rlc_rrc.c
index 4313f379fe..5ba8526b00 100644
--- a/openair2/LAYER2/RLC/rlc_rrc.c
+++ b/openair2/LAYER2/RLC/rlc_rrc.c
@@ -576,7 +576,7 @@ rlc_union_t *rrc_rlc_add_rlc   (
   hash_key_t             key         = HASHTABLE_NOT_A_KEY_VALUE;
   hashtable_rc_t         h_rc;
   hash_key_t             key_lcid    = HASHTABLE_NOT_A_KEY_VALUE;
-  hashtable_rc_t         h_lcid_rc;
+  hashtable_rc_t         h_lcid_rc   = HASH_TABLE_NONE;
   rlc_union_t           *rlc_union_p = NULL;
   rlc_mbms_id_t         *mbms_id_p  = NULL;
   logical_chan_id_t      lcid            = 0;
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity.c b/openair2/LAYER2/rlc_v2/rlc_entity.c
index d774e2b7e1..a1c6c8ee4e 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity.c
+++ b/openair2/LAYER2/rlc_v2/rlc_entity.c
@@ -46,7 +46,9 @@ rlc_entity_t *new_rlc_entity_am(
     int t_poll_retransmit,
     int poll_pdu,
     int poll_byte,
-    int max_retx_threshold)
+    int max_retx_threshold,
+    unsigned int channel_id,
+    int ue_rnti)
 {
   rlc_entity_am_t *ret;
 
@@ -87,6 +89,8 @@ rlc_entity_t *new_rlc_entity_am(
   ret->poll_pdu           = poll_pdu;
   ret->poll_byte          = poll_byte;
   ret->max_retx_threshold = max_retx_threshold;
+  ret->channel_id         = channel_id;
+  ret->ue_rnti            = ue_rnti;
 
   return (rlc_entity_t *)ret;
 }
@@ -98,7 +102,9 @@ rlc_entity_t *new_rlc_entity_um(
                       char *buf, int size),
     void *deliver_sdu_data,
     int t_reordering,
-    int sn_field_length)
+    int sn_field_length,
+    unsigned int channel_id,
+    int ue_rnti)
 {
   rlc_entity_um_t *ret;
 
@@ -129,6 +135,8 @@ rlc_entity_t *new_rlc_entity_um(
   ret->rx_maxsize         = rx_maxsize;
   ret->tx_maxsize         = tx_maxsize;
   ret->t_reordering       = t_reordering;
+  ret->channel_id         = channel_id;
+  ret->ue_rnti            = ue_rnti;
 
   if (sn_field_length == 5)
     ret->sn_modulus = 32;
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity.h b/openair2/LAYER2/rlc_v2/rlc_entity.h
index c9b35204f0..50178b551a 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity.h
+++ b/openair2/LAYER2/rlc_v2/rlc_entity.h
@@ -24,6 +24,8 @@
 
 #include <stdint.h>
 
+#include "platform_types.h"
+
 #define SDU_MAX 16000   /* maximum PDCP SDU size is 8188, let's take more */
 
 typedef struct {
@@ -34,10 +36,10 @@ typedef struct {
 
 typedef struct rlc_entity_t {
   /* functions provided by the RLC module */
-  void (*recv_pdu)(struct rlc_entity_t *entity, char *buffer, int size);
+  void (*recv_pdu)(struct rlc_entity_t *entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
   rlc_entity_buffer_status_t (*buffer_status)(
       struct rlc_entity_t *entity, int maxsize);
-  int (*generate_pdu)(struct rlc_entity_t *entity, char *buffer, int size);
+  int (*generate_pdu)(struct rlc_entity_t *entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 
   void (*recv_sdu)(struct rlc_entity_t *entity, char *buffer, int size,
                    int sdu_id);
@@ -83,7 +85,9 @@ rlc_entity_t *new_rlc_entity_am(
     int t_poll_retransmit,
     int poll_pdu,
     int poll_byte,
-    int max_retx_threshold);
+    int max_retx_threshold,
+    unsigned int channel_id,
+    int ue_rnti);
 
 rlc_entity_t *new_rlc_entity_um(
     int rx_maxsize,
@@ -92,6 +96,8 @@ rlc_entity_t *new_rlc_entity_um(
                       char *buf, int size),
     void *deliver_sdu_data,
     int t_reordering,
-    int sn_field_length);
+    int sn_field_length,
+    unsigned int channel_id,
+    int ue_rnti);
 
 #endif /* _RLC_ENTITY_H_ */
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_am.c b/openair2/LAYER2/rlc_v2/rlc_entity_am.c
index 710f22855e..87c7f28ef6 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_am.c
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_am.c
@@ -26,6 +26,9 @@
 #include <string.h>
 
 #include "LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 /*************************************************************************/
 /* PDU RX functions                                                      */
@@ -196,6 +199,14 @@ static void rlc_am_reassemble(rlc_entity_am_t *entity)
        */
       if (r->data_pos != r->start->size ||
           (r->fi & 1) == 0) {
+#if LATSEQ
+        uint8_t psn_short = (uint8_t)r->sdu[0] & 0x7F;
+        uint16_t psn_long = 0x00;
+        psn_long = (uint8_t)r->sdu[0] & 0x0F;
+        psn_long <<= 8;
+        psn_long |= (uint8_t)r->sdu[1] & 0xFF;
+        LATSEQ_P("U rlc.reas.am--pdcp.rx", "len%d:rnti%d:drb%d.rsn%d.rso%d.psn%d.psn%d", r->sdu_pos, entity->ue_rnti, entity->channel_id, r->sn, r->so, psn_short, psn_long);
+#endif
         /* SDU is full - deliver to higher layer */
         entity->common.deliver_sdu(entity->common.deliver_sdu_data,
                                    (rlc_entity_t *)entity,
@@ -357,6 +368,9 @@ static void consider_retransmission(rlc_entity_am_t *entity,
    * for the RLC code to keep going with this segment (we only remove
    * a segment that was ACKed)
    */
+#if LATSEQ
+  LATSEQ_P("D rlc.seg.am--rlc.retx.am", "len%d:rnti%d:drb%d.rsn%d.rso%d.rretx%d",cur->data_size, entity->ue_rnti, entity->channel_id, cur->sn, cur->so, cur->retx_count);
+#endif
   entity->retransmit_list = rlc_tx_pdu_list_add(sn_compare_tx, entity,
                                                 entity->retransmit_list, cur);
 }
@@ -569,7 +583,7 @@ static void finalize_ack_nack_processing(rlc_entity_am_t *entity)
   cleanup_sdu_list(entity);
 }
 
-void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
+void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
 #define R(d) do { if (rlc_pdu_decoder_in_error(&d)) goto err; } while (0)
   rlc_entity_am_t *entity = (rlc_entity_am_t *)_entity;
@@ -617,6 +631,10 @@ void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
   e  = rlc_pdu_decoder_get_bits(&decoder, 1); R(decoder);
   sn = rlc_pdu_decoder_get_bits(&decoder, 10); R(decoder);
 
+#if LATSEQ
+  LATSEQ_P("I rlc.rxbuf.am", "occ%d:rnti%d:drb%d", entity->rx_size + size, entity->ue_rnti, entity->channel_id);
+#endif
+
   /* dicard PDU if rx buffer is full */
   if (entity->rx_size + size > entity->rx_maxsize) {
     LOG_D(RLC, "%s:%d:%s: warning: discard PDU, RX buffer full\n",
@@ -638,7 +656,9 @@ void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
     lsf = 1;
     so = 0;
   }
-
+#if LATSEQ
+  LATSEQ_P("U mac.demux--rlc.rx.am", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.rfi%d.fm%d", size, entity->ue_rnti, entity->channel_id, channel_id, sn, so, fi, frame);
+#endif
   packet_count = 1;
 
   /* go to start of data */
@@ -693,6 +713,10 @@ void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
 
   /* put in pdu reception list */
   entity->rx_size += size;
+  //entity->rx_num += 1;
+#if LATSEQ
+  LATSEQ_P("U rlc.rx.am--rlc.reas.am", "len%d:rnti%d:drb%d.rsn%d.rso%d.rfi%d", size, entity->ue_rnti, entity->channel_id, sn, so, fi);
+#endif
   pdu_segment = rlc_rx_new_pdu_segment(sn, so, size, lsf, buffer, data_start);
   entity->rx_list = rlc_rx_pdu_segment_list_add(sn_compare_rx, entity,
                                                 entity->rx_list, pdu_segment);
@@ -1268,6 +1292,9 @@ static int serialize_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize,
     li = sdu->size - sdu_start_byte;
     if (outpos + li >= pdu->data_size)
       li = pdu->data_size - outpos;
+#if LATSEQ
+    LATSEQ_P("D rlc.tx.am--rlc.seg.am", "len%d:rnti%d:drb%d.sdu%d.rsn%d.rfi%d", sdu->size, entity->ue_rnti, entity->channel_id, sdu->sdu_num, pdu->sn, fi);
+#endif
     memcpy(out+outpos, sdu->data + sdu_start_byte, li);
     outpos += li;
     sdu_start_byte = 0;
@@ -1279,7 +1306,7 @@ static int serialize_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize,
   return header_size + pdu->data_size;
 }
 
-static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
+static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize, int *sn, int *so)
 {
   int                  vt_ms;
   tx_pdu_size_t        pdu_size;
@@ -1302,6 +1329,7 @@ static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
   pdu = rlc_tx_new_pdu();
 
   pdu->sn = entity->vt_s;
+  *sn = pdu->sn;
   entity->vt_s = (entity->vt_s + 1) % 1024;
 
   /* go to first SDU (skip those already fully processed) */
@@ -1321,6 +1349,7 @@ static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
    * segment goes to retransmit list)
    */
   pdu->retx_count = -1;
+  *so = pdu->so;
 
   /* reserve SDU bytes */
   cursize = 0;
@@ -1333,6 +1362,9 @@ static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
   }
 
   pdu->data_size = cursize;
+// #if LATSEQ
+//   LATSEQ_P("D rlc.tx.am--rlc.seg.am", "len%d:rnti%d:drb%d.sdu%d.rsn%d.rso%d", cursize, entity->ue_rnti, entity->channel_id, ((rlc_sdu_t*)(pdu->start_sdu))->sdu_num, pdu->sn, pdu->so);
+// #endif
 
   /* put PDU at the end of the wait list */
   entity->wait_list = rlc_tx_pdu_list_append(entity->wait_list, pdu);
@@ -1409,7 +1441,7 @@ static void resegment(rlc_tx_pdu_segment_t *pdu, int size)
   pdu->next = new_pdu;
 }
 
-static int generate_retx_pdu(rlc_entity_am_t *entity, char *buffer, int size)
+static int generate_retx_pdu(rlc_entity_am_t *entity, char *buffer, int size, int *sn, int *so)
 {
   rlc_tx_pdu_segment_t *pdu;
   int orig_size;
@@ -1438,7 +1470,8 @@ static int generate_retx_pdu(rlc_entity_am_t *entity, char *buffer, int size)
     p = 1;
     entity->force_poll = 0;
   }
-
+  *sn = pdu->sn;
+  *so = pdu->so;
   return serialize_pdu(entity, buffer, orig_size, pdu, p);
 }
 
@@ -1502,10 +1535,12 @@ rlc_entity_buffer_status_t rlc_entity_am_buffer_status(
   return ret;
 }
 
-int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
+int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
   rlc_entity_am_t *entity = (rlc_entity_am_t *)_entity;
   int ret;
+  int pdu_sn=0;
+  int pdu_so=0;
 
   if (status_to_report(entity)) {
     ret = generate_status(entity, buffer, size);
@@ -1514,12 +1549,19 @@ int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
   }
 
   if (entity->retransmit_list != NULL) {
-    ret = generate_retx_pdu(entity, buffer, size);
+    ret = generate_retx_pdu(entity, buffer, size, &pdu_sn, &pdu_so);
     if (ret != 0)
+#if LATSEQ
+      LATSEQ_P("D rlc.retx.am--mac.mux", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.fm%d", ret, entity->ue_rnti, entity->channel_id, channel_id, pdu_sn, pdu_so, frame);
+#endif
       return ret;
   }
 
-  return generate_tx_pdu(entity, buffer, size);
+  ret = generate_tx_pdu(entity, buffer, size, &pdu_sn, &pdu_so);
+#if LATSEQ
+  LATSEQ_P("D rlc.seg.am--mac.mux", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.reqfm%d", ret, entity->ue_rnti, entity->channel_id, channel_id, pdu_sn, pdu_so, frame);
+#endif
+  return ret;
 }
 
 /*************************************************************************/
@@ -1541,13 +1583,28 @@ void rlc_entity_am_recv_sdu(rlc_entity_t *_entity, char *buffer, int size,
   if (entity->tx_size + size > entity->tx_maxsize) {
     LOG_D(RLC, "%s:%d:%s: warning: SDU rejected, SDU buffer full\n",
           __FILE__, __LINE__, __FUNCTION__);
+#if LATSEQ
+    uint16_t seqnum = 0x00;
+    seqnum = buffer[0] & 0x0F;
+    seqnum <<= 8;
+    seqnum |= buffer[1] & 0xFF;
+    LATSEQ_P("D pdcp.tx--rlc.drop.am", "len%d:rnti%d:drb%d.psn%d", size, entity->ue_rnti, entity->channel_id, seqnum);
+#endif
     return;
   }
 
   entity->tx_size += size;
-
-  sdu = rlc_new_sdu(buffer, size, sdu_id);
+  entity->tx_num += 1;
+  sdu = rlc_new_sdu(buffer, size, sdu_id, entity->tx_num);
   rlc_sdu_list_add(&entity->tx_list, &entity->tx_end, sdu);
+#if LATSEQ
+  uint16_t seqnum = 0x00;
+  seqnum = buffer[0] & 0x0F;
+  seqnum <<= 8;
+  seqnum |= buffer[1] & 0xFF;
+  LATSEQ_P("D pdcp.tx--rlc.tx.am", "len%d:rnti%d:drb%d.psn%d.sdu%d", size, entity->ue_rnti, entity->channel_id, seqnum, entity->tx_num);
+  LATSEQ_P("I rlc.txbuf.am", "occ%d:rnti%d:drb%d", entity->tx_size, entity->ue_rnti, entity->channel_id);
+#endif
 }
 
 /*************************************************************************/
@@ -1765,6 +1822,7 @@ static void clear_entity(rlc_entity_am_t *entity)
   entity->tx_list = NULL;
   entity->tx_end = NULL;
   entity->tx_size = 0;
+  entity->tx_num = 0;
 
   free_pdu_segment_list(entity->wait_list);
   free_pdu_segment_list(entity->retransmit_list);
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_am.h b/openair2/LAYER2/rlc_v2/rlc_entity_am.h
index 0437f17ad8..9f89ef7d09 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_am.h
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_am.h
@@ -24,6 +24,7 @@
 
 #include <stdint.h>
 
+#include "platform_types.h"
 #include "rlc_entity.h"
 #include "rlc_pdu.h"
 #include "rlc_sdu.h"
@@ -226,6 +227,8 @@ typedef struct {
   int poll_pdu;              /* -1 means infinity */
   int poll_byte;             /* -1 means infinity */
   int max_retx_threshold;
+  unsigned int channel_id;
+  int ue_rnti;
 
   /* runtime rx */
   int vr_r;
@@ -255,6 +258,7 @@ typedef struct {
   rlc_rx_pdu_segment_t *rx_list;
   int                  rx_size;
   int                  rx_maxsize;
+  //int                  rx_num;
 
   /* reassembly management */
   rlc_am_reassemble_t    reassemble;
@@ -264,6 +268,7 @@ typedef struct {
   rlc_sdu_t *tx_end;
   int       tx_size;
   int       tx_maxsize;
+  int       tx_num;
 
   rlc_tx_pdu_segment_t *wait_list;
   rlc_tx_pdu_segment_t *retransmit_list;
@@ -273,10 +278,10 @@ typedef struct {
 
 void rlc_entity_am_recv_sdu(rlc_entity_t *entity, char *buffer, int size,
                             int sdu_id);
-void rlc_entity_am_recv_pdu(rlc_entity_t *entity, char *buffer, int size);
+void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 rlc_entity_buffer_status_t rlc_entity_am_buffer_status(
     rlc_entity_t *entity, int maxsize);
-int rlc_entity_am_generate_pdu(rlc_entity_t *entity, char *buffer, int size);
+int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 void rlc_entity_am_set_time(rlc_entity_t *entity, uint64_t now);
 void rlc_entity_am_discard_sdu(rlc_entity_t *entity, int sdu_id);
 void rlc_entity_am_reestablishment(rlc_entity_t *entity);
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_um.c b/openair2/LAYER2/rlc_v2/rlc_entity_um.c
index 54707875a0..137291e9a8 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_um.c
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_um.c
@@ -26,6 +26,9 @@
 #include <string.h>
 
 #include "LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 /*************************************************************************/
 /* PDU RX functions                                                      */
@@ -228,7 +231,7 @@ static void rlc_um_reception_actions(rlc_entity_um_t *entity,
   }
 }
 
-void rlc_entity_um_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
+void rlc_entity_um_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
 #define R(d) do { if (rlc_pdu_decoder_in_error(&d)) goto err; } while (0)
   rlc_entity_um_t *entity = (rlc_entity_um_t *)_entity;
@@ -420,7 +423,7 @@ rlc_entity_buffer_status_t rlc_entity_um_buffer_status(
   return ret;
 }
 
-int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
+int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
   rlc_entity_um_t      *entity = (rlc_entity_um_t *)_entity;
   tx_pdu_size_t        pdu_size;
@@ -537,9 +540,11 @@ int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
   }
   if (entity->tx_list == NULL)
     entity->tx_end = NULL;
-
   /* update VT(US) */
   entity->vt_us = (entity->vt_us + 1) % entity->sn_modulus;
+#if LATSEQ
+  LATSEQ_P("D rlc.tx.um--rlc.seg.um", "len%d:rnti%d:drb%d.lcid%d.rtime%d.rsn%d", pdu_size.header_size + pdu_size.data_size, entity->ue_rnti, entity->channel_id , entity->channel_id, entity->t_current, entity->vt_us);
+#endif
 
   return pdu_size.header_size + pdu_size.data_size;
 }
@@ -567,8 +572,9 @@ void rlc_entity_um_recv_sdu(rlc_entity_t *_entity, char *buffer, int size,
   }
 
   entity->tx_size += size;
-
-  sdu = rlc_new_sdu(buffer, size, sdu_id);
+  entity->tx_num += 1;
+// no access to ctxt_pP ???
+  sdu = rlc_new_sdu(buffer, size, sdu_id, entity->tx_num);
   rlc_sdu_list_add(&entity->tx_list, &entity->tx_end, sdu);
 }
 
@@ -689,6 +695,7 @@ static void clear_entity(rlc_entity_um_t *entity)
   entity->tx_list = NULL;
   entity->tx_end = NULL;
   entity->tx_size = 0;
+  entity->tx_num = 0;
 }
 
 void rlc_entity_um_reestablishment(rlc_entity_t *_entity)
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_um.h b/openair2/LAYER2/rlc_v2/rlc_entity_um.h
index 02c5141a7a..8275a20cd3 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_um.h
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_um.h
@@ -22,6 +22,7 @@
 #ifndef _RLC_ENTITY_UM_H_
 #define _RLC_ENTITY_UM_H_
 
+#include "platform_types.h"
 #include "rlc_entity.h"
 #include "rlc_pdu.h"
 #include "rlc_sdu.h"
@@ -43,6 +44,8 @@ typedef struct {
   /* configuration */
   int t_reordering;
   int sn_field_length;
+  unsigned int channel_id;
+  int ue_rnti;
 
   int sn_modulus;        /* 1024 for sn_field_length == 10, 32 for 5 */
   int window_size;       /* 512 for sn_field_length == 10, 16 for 5 */
@@ -74,17 +77,18 @@ typedef struct {
   rlc_sdu_t *tx_end;
   int       tx_size;
   int       tx_maxsize;
+  int       tx_num;
 } rlc_entity_um_t;
 
 void rlc_entity_um_recv_sdu(rlc_entity_t *_entity, char *buffer, int size,
                             int sdu_id);
-void rlc_entity_um_recv_pdu(rlc_entity_t *entity, char *buffer, int size);
+void rlc_entity_um_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 rlc_entity_buffer_status_t rlc_entity_um_buffer_status(
     rlc_entity_t *entity, int maxsize);
-int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size);
+int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 void rlc_entity_um_set_time(rlc_entity_t *entity, uint64_t now);
 void rlc_entity_um_discard_sdu(rlc_entity_t *entity, int sdu_id);
 void rlc_entity_um_reestablishment(rlc_entity_t *entity);
 void rlc_entity_um_delete(rlc_entity_t *entity);
 
-#endif /* _RLC_ENTITY_UM_H_ */
+#endif /* _RLC_ENTITY_UM_H_ */
\ No newline at end of file
diff --git a/openair2/LAYER2/rlc_v2/rlc_oai_api.c b/openair2/LAYER2/rlc_v2/rlc_oai_api.c
index 2a6f00c13c..294a1f85bf 100644
--- a/openair2/LAYER2/rlc_v2/rlc_oai_api.c
+++ b/openair2/LAYER2/rlc_v2/rlc_oai_api.c
@@ -95,7 +95,7 @@ void mac_rlc_data_ind     (
 
   if (rb != NULL) {
     rb->set_time(rb, rlc_current_time);
-    rb->recv_pdu(rb, buffer_pP, tb_sizeP);
+    rb->recv_pdu(rb, buffer_pP, tb_sizeP, channel_idP, frameP);
   } else {
     LOG_E(RLC, "%s:%d:%s: fatal: no RB found (rnti %d channel ID %d)\n",
           __FILE__, __LINE__, __FUNCTION__, rnti, channel_id);
@@ -127,9 +127,16 @@ tbs_size_t mac_rlc_data_req(
   rlc_manager_lock(rlc_ue_manager);
   ue = rlc_manager_get_ue(rlc_ue_manager, rntiP);
 
+  logical_chan_id_t lcid;
   switch (channel_idP) {
-  case 1 ... 2: rb = ue->srb[channel_idP - 1]; break;
-  case 3 ... 7: rb = ue->drb[channel_idP - 3]; break;
+  case 1 ... 2:
+    lcid = channel_idP - 1;
+    rb = ue->srb[lcid]; 
+    break;
+  case 3 ... 7:
+    lcid = channel_idP - 3;
+    rb = ue->drb[lcid];
+    break;
   default:      rb = NULL;                     break;
   }
 
@@ -144,7 +151,7 @@ tbs_size_t mac_rlc_data_req(
   if (rb != NULL) {
     rb->set_time(rb, rlc_current_time);
     maxsize = tb_sizeP;
-    ret = rb->generate_pdu(rb, buffer_pP, maxsize);
+    ret = rb->generate_pdu(rb, buffer_pP, maxsize, channel_idP, frameP);
   } else {
     LOG_E(RLC, "%s:%d:%s: fatal: data req for unknown RB\n", __FILE__, __LINE__, __FUNCTION__);
     exit(1);
@@ -152,7 +159,6 @@ tbs_size_t mac_rlc_data_req(
   }
 
   rlc_manager_unlock(rlc_ue_manager);
-
   if (enb_flagP)
     T(T_ENB_RLC_MAC_DL, T_INT(module_idP), T_INT(rntiP),
       T_INT(channel_idP), T_INT(ret));
@@ -654,7 +660,8 @@ static void add_srb(int rnti, int module_id, struct LTE_SRB_ToAddMod *s)
                                max_retx_reached, ue,
                                t_reordering, t_status_prohibit,
                                t_poll_retransmit,
-                               poll_pdu, poll_byte, max_retx_threshold);
+                               poll_pdu, poll_byte, max_retx_threshold, srb_id,
+                               rnti);
     rlc_ue_add_srb_rlc_entity(ue, srb_id, rlc_am);
 
     LOG_D(RLC, "%s:%d:%s: added SRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, srb_id, rnti);
@@ -731,7 +738,8 @@ static void add_drb_am(int rnti, int module_id, struct LTE_DRB_ToAddMod *s)
                                max_retx_reached, ue,
                                t_reordering, t_status_prohibit,
                                t_poll_retransmit,
-                               poll_pdu, poll_byte, max_retx_threshold);
+                               poll_pdu, poll_byte, max_retx_threshold, drb_id,
+                               rnti);
     rlc_ue_add_drb_rlc_entity(ue, drb_id, rlc_am);
 
     LOG_D(RLC, "%s:%d:%s: added DRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, drb_id, rnti);
@@ -801,7 +809,9 @@ static void add_drb_um(int rnti, int module_id, struct LTE_DRB_ToAddMod *s)
                                1000000,
                                deliver_sdu, ue,
                                t_reordering,
-                               sn_field_length);
+                               sn_field_length,
+                               drb_id,
+                               rnti);
     rlc_ue_add_drb_rlc_entity(ue, drb_id, rlc_um);
 
     LOG_D(RLC, "%s:%d:%s: added DRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, drb_id, rnti);
@@ -917,8 +927,9 @@ rlc_op_status_t rrc_rlc_config_asn1_req (const protocol_ctxt_t   * const ctxt_pP
                                      1000000,
                                      deliver_sdu, ue,
                                      0,//LTE_T_Reordering_ms0,//t_reordering,
-                                     5//LTE_SN_FieldLength_size5//sn_field_length
-                                    );
+                                     5,//LTE_SN_FieldLength_size5//sn_field_length
+                                     drb_id,
+                                     mbms_rnti);
           rlc_ue_add_drb_rlc_entity(ue, drb_id, rlc_um);
 
           LOG_D(RLC, "%s:%d:%s: added DRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, (int)drb_id, mbms_rnti);
diff --git a/openair2/LAYER2/rlc_v2/rlc_sdu.c b/openair2/LAYER2/rlc_v2/rlc_sdu.c
index 16465a9ff1..05bcc2c6fe 100644
--- a/openair2/LAYER2/rlc_v2/rlc_sdu.c
+++ b/openair2/LAYER2/rlc_v2/rlc_sdu.c
@@ -26,13 +26,14 @@
 
 #include "LOG/log.h"
 
-rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id)
+rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id, int sdu_num)
 {
   rlc_sdu_t *ret = calloc(1, sizeof(rlc_sdu_t));
   if (ret == NULL)
     goto oom;
 
   ret->upper_layer_id = upper_layer_id;
+  ret->sdu_num = sdu_num;
 
   ret->data = malloc(size);
   if (ret->data == NULL)
diff --git a/openair2/LAYER2/rlc_v2/rlc_sdu.h b/openair2/LAYER2/rlc_v2/rlc_sdu.h
index 2c678956ee..e93701741b 100644
--- a/openair2/LAYER2/rlc_v2/rlc_sdu.h
+++ b/openair2/LAYER2/rlc_v2/rlc_sdu.h
@@ -24,6 +24,7 @@
 
 typedef struct rlc_sdu_t {
   int upper_layer_id;
+  int sdu_num;
   char *data;
   int size;
   /* next_byte indicates the starting byte to use to construct a new PDU */
@@ -32,7 +33,7 @@ typedef struct rlc_sdu_t {
   struct rlc_sdu_t *next;
 } rlc_sdu_t;
 
-rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id);
+rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id, int sdu_num);
 void rlc_free_sdu(rlc_sdu_t *sdu);
 void rlc_sdu_list_add(rlc_sdu_t **list, rlc_sdu_t **end, rlc_sdu_t *sdu);
 
diff --git a/openair2/LAYER2/rlc_v2/tests/test.c b/openair2/LAYER2/rlc_v2/tests/test.c
index 734e85f1f5..4469eb0c6c 100644
--- a/openair2/LAYER2/rlc_v2/tests/test.c
+++ b/openair2/LAYER2/rlc_v2/tests/test.c
@@ -213,7 +213,7 @@ int test_main(void)
                                   successful_delivery_enb, NULL,
                                   max_retx_reached_enb, NULL,
                                   test[pos+3], test[pos+4], test[pos+5],
-                                  test[pos+6], test[pos+7], test[pos+8]);
+                                  test[pos+6], test[pos+7], test[pos+8],0,0);
           pos += 9;
           break;
         case UE_AM:
@@ -222,19 +222,19 @@ int test_main(void)
                                  successful_delivery_ue, NULL,
                                  max_retx_reached_ue, NULL,
                                  test[pos+3], test[pos+4], test[pos+5],
-                                 test[pos+6], test[pos+7], test[pos+8]);
+                                 test[pos+6], test[pos+7], test[pos+8],0,0);
           pos += 9;
           break;
         case ENB_UM:
           enb = new_rlc_entity_um(test[pos+1], test[pos+2],
                                   deliver_sdu_enb_um, NULL,
-                                  test[pos+3], test[pos+4]);
+                                  test[pos+3], test[pos+4],0);
           pos += 5;
           break;
         case UE_UM:
           ue = new_rlc_entity_um(test[pos+1], test[pos+2],
                                  deliver_sdu_ue_um, NULL,
-                                 test[pos+3], test[pos+4]);
+                                 test[pos+3], test[pos+4],0);
           pos += 5;
           break;
         case ENB_SDU:
diff --git a/openair2/RRC/LTE/rrc_eNB_S1AP.c b/openair2/RRC/LTE/rrc_eNB_S1AP.c
index f24c9ab1b6..e8721c03b0 100644
--- a/openair2/RRC/LTE/rrc_eNB_S1AP.c
+++ b/openair2/RRC/LTE/rrc_eNB_S1AP.c
@@ -70,6 +70,7 @@ static const uint16_t S1AP_ENCRYPTION_EEA2_MASK = 0x4000;
 /* Masks for S1AP Integrity algorithms, EIA0 is always supported (not coded) */
 static const uint16_t S1AP_INTEGRITY_EIA1_MASK = 0x8000;
 static const uint16_t S1AP_INTEGRITY_EIA2_MASK = 0x4000;
+static const uint16_t S1AP_INTEGRITY_EIA3_MASK = 0x2000;
 
 #define INTEGRITY_ALGORITHM_NONE LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia0_v920
 
@@ -386,6 +387,15 @@ static LTE_CipheringAlgorithm_r12_t rrc_eNB_select_ciphering(uint16_t algorithms
  *\return the selected algorithm.
  */
 static e_LTE_SecurityAlgorithmConfig__integrityProtAlgorithm rrc_eNB_select_integrity(uint16_t algorithms) {
+  if (algorithms & S1AP_INTEGRITY_EIA3_MASK) {  // not sure on mask
+    /* TEMPORARY patch to fallback in eia2 instead of unsupported by eNB eia3*/
+    if (algorithms & S1AP_INTEGRITY_EIA2_MASK) {
+      return LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia2;
+    }
+    else {
+      return LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia3_v1130;
+    }
+  }
   if (algorithms & S1AP_INTEGRITY_EIA2_MASK) {
     return LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia2;
   }
diff --git a/openair3/NAS/UE/EMM/SecurityModeControl.c b/openair3/NAS/UE/EMM/SecurityModeControl.c
index f9a02b1a70..a48f1bcf97 100644
--- a/openair3/NAS/UE/EMM/SecurityModeControl.c
+++ b/openair3/NAS/UE/EMM/SecurityModeControl.c
@@ -163,6 +163,7 @@ int emm_proc_security_mode_command(nas_user_t *user, int native_ksi, int ksi,
   if ( (reea != eea) || (reia != eia) ) {
     LOG_TRACE(WARNING, "EMM-PROC  - Replayed UE security capabilities "
               "rejected");
+    //printf("EMM_CAUSE_UE_SECURITY_MISMATCH : eai = %hhu reia = %hhu\n", eia, reia);
     emm_cause = EMM_CAUSE_UE_SECURITY_MISMATCH;
 
     /* XXX - For testing purpose UE always accepts EIA0
diff --git a/openair3/ocp-gtpu/gtp_itf.cpp b/openair3/ocp-gtpu/gtp_itf.cpp
index 7b8ba308bf..1145e52824 100644
--- a/openair3/ocp-gtpu/gtp_itf.cpp
+++ b/openair3/ocp-gtpu/gtp_itf.cpp
@@ -19,6 +19,9 @@ extern "C" {
 #include <openair2/LAYER2/PDCP_v10.1.0/pdcp.h>
 #include "openair2/SDAP/nr_sdap/nr_sdap.h"
 //#include <openair1/PHY/phy_extern.h>
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 static boolean_t is_gnb = false;
 
@@ -225,6 +228,10 @@ static void gtpv1uSend(instance_t instance, gtpv1u_enb_tunnel_data_req_t *req, b
   // copy to release the mutex
   gtpv1u_bearer_t tmp=ptr2->second;
   pthread_mutex_unlock(&globGtp.gtp_lock);
+#if LATSEQ
+  uint16_t ipid = buffer[4] << 8 | buffer[5];
+  LATSEQ_P("U gtp.out--ip.out","len%d:rnti%d:drb%d.teid%d.gsn%d.npdu%d.ipid0x%x", length, rnti, rab_id - 4, tmp.teid_outgoing, tmp.seqNum, tmp.npduNum, ipid);
+#endif
   gtpv1uCreateAndSendMsg(compatInst(instance),
                          tmp.outgoing_ip_addr,
                          tmp.outgoing_port,
@@ -895,7 +902,11 @@ static int Gtpv1uHandleGpdu(int h,
   const uint32_t sourceL2Id=0;
   const uint32_t destinationL2Id=0;
   pthread_mutex_unlock(&globGtp.gtp_lock);
-
+#if LATSEQ
+  uint16_t ipid = sdu_buffer[4] << 8 | sdu_buffer[5];
+  //auto teid = inst->ue2te_mapping.find(ntohl(msgHdr->teid))->second.teid_incoming;
+  LATSEQ_P("D ip.in--pdcp.in", "len%d:rnti%u:ipid0x%x.drb%u", sdu_buffer_size, tunnel->second.rnti, ipid, rb_id);
+#endif
   if(is_gnb && qfi){
     if ( !tunnel->second.callBackSDAP(&ctxt,
                                       srb_flag,
diff --git a/openair3/ocp-gtpu/gtpv1u_eNB_task.h b/openair3/ocp-gtpu/gtpv1u_eNB_task.h
index e764eb143b..d4f285d73d 100644
--- a/openair3/ocp-gtpu/gtpv1u_eNB_task.h
+++ b/openair3/ocp-gtpu/gtpv1u_eNB_task.h
@@ -85,6 +85,27 @@ gtpv1u_new_data_req(
   uint32_t buf_len,
   uint32_t buf_offset);*/
 
+
+// typedef struct gtpv1u_data_s {
+//  /* nwgtpv1u stack internal data */
+//  NwGtpv1uStackHandleT  gtpv1u_stack;
+//
+//  /* RB tree of UEs */
+//  hash_table_t         *ue_mapping;   // PDCP->GTPV1U
+//  hash_table_t         *teid_mapping; // GTPV1U -> PDCP
+//
+//  //RB_HEAD(gtpv1u_ue_map, gtpv1u_ue_data_s) gtpv1u_ue_map_head;
+//  /* Local IP address to use */
+//  in_addr_t             enb_ip_address_for_S1u_S12_S4_up;
+//  /* UDP internal data */
+//  //udp_data_t            udp_data;
+//
+//  uint16_t              seq_num;
+//  uint16_t              tx_seq_num;
+//  uint8_t               restart_counter;
+//
+//} gtpv1u_data_t;
+
 int   gtpv1u_eNB_init(void);
 void *gtpv1u_eNB_process_itti_msg(void *);
 void *gtpv1u_eNB_task(void *args);
diff --git a/targets/RT/USER/lte-ru.c b/targets/RT/USER/lte-ru.c
index 571551cee9..4bffa04618 100644
--- a/targets/RT/USER/lte-ru.c
+++ b/targets/RT/USER/lte-ru.c
@@ -73,6 +73,10 @@ static int DEFBFW[] = {0x00007fff};
 #include "SIMULATION/ETH_TRANSPORT/proto.h"
 
 #include "T.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 
 #include "executables/softmodem-common.h"
 
@@ -704,6 +708,10 @@ void rx_rf(RU_t *ru,
   //LOG_I(PHY,"timestamp_rx %lu, frame %d(%d), subframe %d(%d)\n",ru->timestamp_rx,proc->frame_rx,frame,proc->tti_rx,subframe);
   VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME( VCD_SIGNAL_DUMPER_VARIABLES_TRX_TS, proc->timestamp_rx&0xffffffff );
 
+#if LATSEQ
+  LATSEQ_P("U phy.in.ant--phy.in.proc","len%d::fm%d.subfm%d", rxs, proc->frame_rx, proc->tti_rx);
+#endif
+
   if (rxs != fp->samples_per_tti) {
 #if defined(USRP_REC_PLAY)
     exit_fun("Exiting IQ record/playback");
@@ -768,6 +776,10 @@ void tx_rf(RU_t *ru,
     sf_extension = (sf_extension)&0xfffffffc;
 #endif
 
+#if LATSEQ
+    LATSEQ_P("D phy.out.proc--phy.out.ant","len%d::fm%d.subfm%d",siglen, frame, subframe);
+#endif
+
     for (i=0; i<ru->nb_tx; i++)
       txp[i] = (void *)&ru->common.txdata[i][(subframe*fp->samples_per_tti)-sf_extension];
 
diff --git a/targets/RT/USER/lte-softmodem.c b/targets/RT/USER/lte-softmodem.c
index 5d17cc17bb..496847e8ad 100644
--- a/targets/RT/USER/lte-softmodem.c
+++ b/targets/RT/USER/lte-softmodem.c
@@ -76,6 +76,13 @@ unsigned short config_frames[4] = {2,9,11,13};
 #include "UTIL/OPT/opt.h"
 #include "enb_config.h"
 
+#ifndef OPENAIR2
+  #include "UTIL/OTG/otg_vars.h"
+#endif
+
+#if LATSEQ
+  #include <common/utils/LATSEQ/latseq.h>
+#endif
 
 #include "create_tasks.h"
 
@@ -536,6 +543,7 @@ int main ( int argc, char **argv )
 #if T_TRACER
   T_Config_Init();
 #endif
+
   //randominit (0);
   set_taus_seed (0);
   printf("configuring for RAU/RRU\n");
@@ -545,6 +553,9 @@ int main ( int argc, char **argv )
   }
 
   cpuf=get_cpu_freq_GHz();
+#if LATSEQ
+  init_latseq("/tmp/lte_softmodem", (uint64_t)(cpuf*1000000000LL));
+#endif
   printf("ITTI init, useMME: %i\n",EPC_MODE_ENABLED);
   itti_init(TASK_MAX, tasks_info);
 
@@ -738,7 +749,12 @@ int main ( int argc, char **argv )
   LOG_I(ENB_APP,"oai_exit=%d\n",oai_exit);
   // stop threads
 
+#if LATSEQ
+  close_latseq(); //close before end of threads
+#endif
+
   #if 0 //Disable clean up because this tends to crash (and unnecessary)
+
   if (RC.nb_inst == 0 || !NODE_IS_CU(node_type)) {
     if(IS_SOFTMODEM_DOSCOPE)
       end_forms();
diff --git a/targets/TEST/LATSEQ/Makefile b/targets/TEST/LATSEQ/Makefile
new file mode 100644
index 0000000000..04bb510fe3
--- /dev/null
+++ b/targets/TEST/LATSEQ/Makefile
@@ -0,0 +1,60 @@
+#################################################################################
+# Software Name : LatSeq
+# Version: 1.0
+# SPDX-FileCopyrightText: Copyright (c) 2020-2021 Orange Labs
+# SPDX-License-Identifier: BSD-3-Clause
+#
+# This software is distributed under the BSD 3-clause,
+# the text of which is available at https://opensource.org/licenses/BSD-3-Clause
+# or see the "license.txt" file for more details.
+#
+# Author: Flavien Ronteix--Jacquet
+# Software description: tests makefile
+#################################################################################
+
+
+TEST_DIR	= $(shell pwd)
+OPENAIR_DIR 	= $(TEST_DIR)/../../..
+OPENAIR2_COMMON = $(OPENAIR_DIR)/openair2/COMMON
+UTILS_DIR 	= $(OPENAIR_DIR)/common/utils
+LATSEQ_DIR	= $(UTILS_DIR)/LATSEQ
+
+CC = gcc
+
+#CFLAGS += -m32 -DPHYSIM -DNB_ANTENNAS_RX=2 -DNB_ANTENNAS_TX=2 -I/usr/include/X11
+#CFLAGS += -I/usr/include/libxml2 -L/usr/local/lib -I/usr/include/atlas -L/usr/X11R6/lib 
+CFLAGS += -std=gnu99 # to be compiled in c99 like all oai
+CFLAGS += -Wall -Wconversion
+CFLAGS += -g
+#CFLAGS += -pg
+#CFLAGS += -O3
+CFLAGS += -DLATSEQ
+#CFLAGS += -DLATSEQ_DEBUG
+CFLAGS += -DTEST_LATSEQ
+CFLAGS += -I$(OPENAIR_DIR) -I$(OPENAIR2_COMMON) -I$(UTILS_DIR)  -I$(LATSEQ_DIR)
+
+LDLIBS = -lpthread
+
+VPATH += $(LATSEQ_DIR)
+VPATH += $(MEAS_DIR)
+
+EXE = test_latseq
+SRCS = test_latseq.c latseq.c
+OBJS = $(SRCS:.c=.o)
+
+all: $(EXE)
+
+$(EXE): $(OBJS)
+	@echo "Compiling test_latseq"
+	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LDLIBS)
+
+run: $(EXE)
+	@echo "Run test_latseq"
+	./test_latseq a
+
+run-parsing: $(LATSEQ_DIR)/lseq_stats/lseqlogs.py
+	cd $(LATSEQ_DIR)/lseq_stats/;\
+	      	./lseqlogs.py -l $(TEST_DIR)/test1.lseq
+
+clean:
+	rm -f core gmon.out $(EXE) *.o test.*.lseq
diff --git a/targets/TEST/LATSEQ/README.txt b/targets/TEST/LATSEQ/README.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/targets/TEST/LATSEQ/test_latseq.c b/targets/TEST/LATSEQ/test_latseq.c
new file mode 100644
index 0000000000..aebfc0ca12
--- /dev/null
+++ b/targets/TEST/LATSEQ/test_latseq.c
@@ -0,0 +1,365 @@
+/*
+ * Software Name : LatSeq
+ * Version: 1.0
+ * SPDX-FileCopyrightText: Copyright (c) 2020-2021 Orange Labs
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * This software is distributed under the BSD 3-clause,
+ * the text of which is available at https://opensource.org/licenses/BSD-3-Clause
+ * or see the "license.txt" file for more details.
+ *
+ * Author: Flavien Ronteix--Jacquet
+ * Software description: LatSeq measurement part core
+ */
+
+/*! \file test_latseq.c
+* \brief latency sequence tool test program
+* \author Flavien Ronteix--Jacquet
+* \date 2020
+* \version 1.0
+* @ingroup util
+*/
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <unistd.h>
+#include <pthread.h>
+#include "latseq.h"
+
+double cpuf;
+const char * test_log = "test";
+
+volatile int  oai_exit = 1; //Emulate global variable used by oai to indicate that oai is running
+
+void print_usage(void) 
+{
+  printf("help test_latseq\n");
+  printf("h \t: Help\n");
+  printf("a \t: test_full() \t: a full unit test\n");
+  printf("i \t: test_init_and_close() \t: test a simple init/close case\n");
+  printf("t \t: test_multi_thread() \t: test multi-producers in different thread case\n");
+  printf("m \t: measure_log_measure() \t: measure time took by log_measure\n");
+  printf("n \t: measure_log_n() \t: measure time took by log_measure with n varargs\n");
+  printf("w \t: measure_writer() \t: measure time to write\n");
+}
+
+int test_init_and_close() 
+{
+  oai_exit = 0;
+  printf("[TEST] %s\n",__func__);
+  if(!init_latseq(test_log, 0)) {
+    printf("[ERROR] : init_latseq()\n");
+    exit(EXIT_FAILURE);
+  }
+  sleep(1);
+  if(!close_latseq()) {
+    printf("[ERROR] : close_latseq()\n");
+    exit(EXIT_FAILURE);
+  }
+
+  return 0;
+}
+
+int test_full() 
+{
+  oai_exit = 0;
+  printf("[TEST] %s\n",__func__);
+  if(!init_latseq(test_log, 0)) {
+    printf("[ERROR] : init_latseq()\n");
+    exit(EXIT_FAILURE);
+  }
+  //int num = 1000000;
+  int num = 1;
+  int i;
+  for (i=0; i < num; i++){
+    LATSEQ_P("full3 D", "ip%d", 0);
+    //sleep(1);
+    usleep(1);
+    LATSEQ_P("full2 D", "ip%d.mac%d", 0, 1);
+  }
+  printf("sizeof latseq_element : %ld\n", sizeof(struct latseq_element_t));
+  oai_exit = 1;
+  if(!close_latseq()) {
+    printf("[ERROR] : close_latseq()\n");
+    exit(EXIT_FAILURE);
+  }
+  return 0;
+}
+
+void thread_test1(void)
+{
+  pthread_t thId = pthread_self();
+  printf("[TEST] [%ld] thread started\n", thId);
+  int i = 0;
+  while(!oai_exit) {
+    if (!i) {
+      LATSEQ_P("full3 D", "ip%d", 0);
+      usleep(11000);
+      LATSEQ_P("full2 D", "ip%d.mac%d", 0, 1);
+      i = 1;
+      continue;
+    }
+  }
+  pthread_exit(NULL);
+}
+
+void thread_test2(void)
+{
+  pthread_t thId = pthread_self();
+  printf("[TEST] [%ld] thread started\n", thId);
+  int i = 0;
+  while(!oai_exit) {
+    if (!i) {
+      LATSEQ_P("full3 D", "ip%d", 1);
+      usleep(1000);
+      LATSEQ_P("full2 D", "ip%d.mac%d", 1, 1);
+      usleep(9000);
+      LATSEQ_P("full1 D", "ip%d.mac%d.phy%d", 1, 1, 4);
+      i = 1;
+      continue;
+    }
+  }
+  printf("[TEST] [%ld] thread stopped\n", thId);
+  pthread_exit(NULL);
+}
+
+int test_multithread() 
+{
+  oai_exit = 0;
+  printf("[TEST] %s\n",__func__);
+  if(!init_latseq(test_log, 0)) {
+    printf("[ERROR] : init_latseq()\n");
+    exit(EXIT_FAILURE);
+  }
+  pthread_t th1;
+  pthread_t th2;
+  pthread_create(&th1, NULL, (void *) &thread_test1, NULL);
+  pthread_create(&th2, NULL, (void *) &thread_test2, NULL);
+  usleep(25000);
+  oai_exit = 1;
+  pthread_join(th1, NULL);
+  pthread_join(th2, NULL);
+
+  if(!close_latseq()) {
+    printf("[ERROR] : close_latseq()\n");
+    exit(EXIT_FAILURE);
+  }
+  return 0;
+}
+
+// Repeat experiment 3 times for i in {1..3}; do ./test_latseq m | awk '{print $6}' | sed -r '/^\s*$/d' >> measurement_res.txt; done
+
+int measure_log_measure()
+{
+  oai_exit = 0;
+  printf("[TEST] %s\n",__func__);
+  if(!init_latseq(test_log, 0)) {
+    printf("[ERROR] : init_latseq()\n");
+    exit(EXIT_FAILURE);
+  }
+#ifdef TEST_LATSEQ
+  struct timeval begin, end;
+  gettimeofday(&begin, NULL);
+#endif
+  const uint32_t num_call = 1000000;
+  for (int i = 0; i < num_call; i++)
+  {
+    //LATSEQ_P("meas", "call.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d", i,i,i,i,i,i,i,i,i,i);
+    LATSEQ_P("meas", "call.%d.%d.%d.%d.%d.%d.%d", i,i,i,i,i,i,i);
+    //LATSEQ_P("meas", "call.%d.%d.%d.%d.%d", i,i,i,i,i);
+    //LATSEQ_P("meas", "call.%d", i);
+    //usleep(1);
+  }
+
+#ifdef TEST_LATSEQ
+  gettimeofday(&end, NULL);
+#endif
+  oai_exit = 1;
+  //sleep(1);
+  
+  if(!close_latseq()) {
+    printf("[ERROR] : close_latseq()\n");
+    exit(EXIT_FAILURE);
+  }
+#ifdef TEST_LATSEQ
+  printf("[LATSEQ] %d log_measure took : %lu us\n", num_call, (end.tv_usec - begin.tv_usec)); //at 23-03, 0.0328usec
+#endif
+
+  return 0;
+}
+
+int measure_log_n() 
+{
+  oai_exit = 0;
+  printf("[TEST] %s\n",__func__);
+  if(!init_latseq(test_log, 0)) {
+    printf("[ERROR] : init_latseq()\n");
+    exit(EXIT_FAILURE);
+  }
+  //usleep(10000); //TODO : with this, generate a corrupted size vs. prev_size
+#ifdef TEST_LATSEQ
+  struct timeval begin, end;
+  gettimeofday(&begin, NULL);
+  long t1, t2, t3, t5, t10;
+#endif
+  const uint32_t num_call = 1000;
+  int i;
+  for (i = 0; i < num_call; i++)
+  {
+    LATSEQ_P("meas1", "call.%d", i);
+  }
+#ifdef TEST_LATSEQ
+  gettimeofday(&end, NULL);
+  t1 = end.tv_usec - begin.tv_usec;
+  gettimeofday(&begin, NULL);
+#endif
+  //test n=2
+  for (i = 0; i < num_call; i++)
+  {
+    LATSEQ_P("meas2", "call.%d.%d", i,0);
+  }
+#ifdef TEST_LATSEQ
+  gettimeofday(&end, NULL);
+  t2 = end.tv_usec - begin.tv_usec;
+  gettimeofday(&begin, NULL);
+#endif
+  //test n=3
+  for (i = 0; i < num_call; i++)
+  {
+    LATSEQ_P("meas3", "call.%d.%d.%d", i,0,1);
+  }
+#ifdef TEST_LATSEQ
+  gettimeofday(&end, NULL);
+  t3 = end.tv_usec - begin.tv_usec;
+  gettimeofday(&begin, NULL);
+#endif
+  //test n=5
+  for (i = 0; i < num_call; i++)
+  {
+    LATSEQ_P("meas3", "call.%d.%d.%d.%d.%d", i,0,1,2,3);
+  }
+#ifdef TEST_LATSEQ
+  gettimeofday(&end, NULL);
+  t5 = end.tv_usec - begin.tv_usec;
+  gettimeofday(&begin, NULL);
+#endif
+  //test n=10 (max given by NB_DATA_IDENTIFIERS)
+  for (i = 0; i < num_call; i++)
+  {
+    LATSEQ_P("meas4", "call.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d",i,0,1,2,3,4,5,7,8,9);
+  }
+#ifdef TEST_LATSEQ
+  gettimeofday(&end, NULL);
+  t10 = end.tv_usec - begin.tv_usec;
+#endif
+  oai_exit = 1;
+  sleep(1);
+  
+  if(!close_latseq()) {
+    printf("[ERROR] : close_latseq()\n");
+    exit(EXIT_FAILURE);
+  }
+#ifdef TEST_LATSEQ
+  printf("[LATSEQ] log_measure took :\n"); //at 23-03, 32.8ns
+  printf("\tvar_args=1 : %.1f ns/call\n", 1000*(double)t1/num_call); // mean : 19ns at 23-03
+  printf("\tvar_args=2 : %.1f ns/call\n", 1000*(double)t2/num_call); // mean : 22ns at 23-03
+  printf("\tvar_args=3 : %.1f ns/call\n", 1000*(double)t3/num_call); // mean : 25ns at 23-03
+  printf("\tvar_args=5 : %.1f ns/call\n", 1000*(double)t5/num_call); // mean : 32ns at 23-03
+  printf("\tvar_args=10 : %.1f ns/call\n", 1000*(double)t10/num_call); // mean : 61ns at 23-03
+#endif
+  return 0;
+}
+
+void test_writer(FILE * f, char * tmps, int i)
+{
+  sprintf(tmps, "a%d.b%d", i, i+1);
+  fprintf(f, "%d.%06d %s %s\n", 1, 234567, "D write", tmps);
+}
+
+/*
+ * Compiler avec -pg
+ * résultats au 6-04-2020
+ * %   cumulative   self              self     * total           
+ * time   seconds   seconds    calls  ms/call  ms/call  name    
+ * 71.46      0.05     0.05        1    50.02    70.03  measure_writer
+ * 28.58      0.07     0.02 10000000     0.00     0.00  test_writer
+ */
+int measure_writer()
+{
+  oai_exit = 0;
+  printf("[TEST] %s\n",__func__);
+  FILE * fout = fopen("test1.lseq", "w");
+  //write header
+  char hdr[] = "# LatSeq format\n# By Alexandre Ferrieux and Flavien Ronteix Jacquet\n# timestamp\tU/D\tsrc--dest\tdataId\n#funcId ip.entry sdap.mapping sdap.header pdcp.txbuf pdcp.rohc pdcp.intcipher pdcp.header pdcp.routing rlc.am.txbuf rlc.am.seg rlc.am.header rlc.am.retbuf mac.mux mac.harq.[0-7] phy.crc phy.cbseg phy.msc phy.mod phy.map phy.ant\n";
+  fwrite(hdr, sizeof(char), sizeof(hdr) - 1, fout);
+  const int num_call = 1000000;
+  char * tmps;
+  tmps = calloc(2*10, sizeof(char));
+
+#ifdef TEST_LATSEQ
+  struct timeval begin, end;
+  gettimeofday(&begin, NULL);
+#endif
+  for (int i = 0; i < num_call; i++) {
+    test_writer(fout, tmps, i);
+  }
+#ifdef TEST_LATSEQ
+  gettimeofday(&end, NULL);
+  printf("[LATSEQ] measure_write took : "); //at 23-03, 32.8ns
+  printf("%d writes : %.1ld us\n", num_call, (end.tv_usec - begin.tv_usec));
+#endif
+  fclose(fout);
+  free(tmps);
+  oai_exit = 1;
+  return 0;
+}
+
+int main (int argc, char **argv) 
+{
+  #ifdef LATSEQ
+    printf("[TEST] #ifdef LATSEQ\n");
+  #endif
+  if (argc != 2) {
+    print_usage();
+    exit(-1);
+  }
+  char opt = (char)argv[1][0];
+  switch (opt)
+  {
+  case 'h':
+    print_usage();
+    break;
+
+  case 'i':
+    (void)test_init_and_close();
+    break;
+  
+  case 'a':
+    (void)test_full();
+    break;
+
+  case 't':
+    (void)test_multithread();
+    break;
+  
+  case 'm':
+    (void)measure_log_measure();
+    break;
+
+  case 'n':
+    (void)measure_log_n();
+    break;
+  
+  case 'w':
+    (void)measure_writer();
+    break;
+  
+  default:
+    print_usage();
+    break;
+  }
+  
+  //#endif
+  oai_exit = 1;
+  return 0;
+}
