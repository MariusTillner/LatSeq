diff --git a/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c b/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c
index b5bcb0848d..3dfaee2560 100644
--- a/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c
+++ b/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c
@@ -40,6 +40,9 @@
 #include "SCHED/sched_eNB.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 #include "targets/RT/USER/lte-softmodem.h"
 #include <syscall.h>
 #include "targets/RT/USER/rt_wrapper.h"
@@ -374,8 +377,16 @@ int dlsch_encoding(PHY_VARS_eNB *eNB,
     //    printf("CRC %x (A %d)\n",crc,A);
     hadlsch->B = A+24;
     //    hadlsch->b = a;
+    // LATSEQ
+/*
+#if LATSEQ
+    LATSEQ_P_TEST("D mac.txreq--mac.harq","rnti%d:harq%d.fm%d.subfm%d",dlsch->rnti, harq_pid, frame, subframe);
+#endif
+*/
+
+    // END_LATSEQ
     memcpy(hadlsch->b,a,(A/8)+4);
-    
+
     if (lte_segmentation(hadlsch->b,
                          hadlsch->c,
                          hadlsch->B,
diff --git a/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c b/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c
index ae8c666d18..8b98c043dd 100644
--- a/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c
+++ b/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c
@@ -43,6 +43,10 @@
 #include "transport_proto.h"
 #include <executables/split_headers.h>
 
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 extern WORKER_CONF_t get_thread_worker_conf(void);
 extern volatile int oai_exit;
 
@@ -357,6 +361,9 @@ int ulsch_decoding_data(PHY_VARS_eNB *eNB, L1_rxtx_proc_t *proc,
     int sz=Kr_bytes - Fbytes - ((ulsch_harq->C>1)?3:0);
     pushTpool(proc->threadPool,req);
     proc->nbDecode++;
+#ifdef LATSEQ
+    LATSEQ_P("U phy.in.proc--mac.harq.up", "len%d::ue%d.cbseg%d.fm%d.subfm%d", sz, rdata->UEid, r, rdata->frame, rdata->subframe);
+#endif
     LOG_D(PHY,"Added a block to decode, in pipe: %d\n",proc->nbDecode);
     r_offset+=E;
     offset+=sz;	    
diff --git a/openair1/SCHED/fapi_l1.c b/openair1/SCHED/fapi_l1.c
index ecfec02193..468216bed0 100644
--- a/openair1/SCHED/fapi_l1.c
+++ b/openair1/SCHED/fapi_l1.c
@@ -37,6 +37,9 @@
 #include "nfapi/oai_integration/vendor_ext.h"
 #include "nfapi_pnf_interface.h"
 #include "fapi_l1.h"
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "common/ran_context.h"
 extern RAN_CONTEXT_t RC;
@@ -231,6 +234,12 @@ void handle_nfapi_dlsch_pdu(PHY_VARS_eNB *eNB,int frame,int subframe,L1_rxtx_pro
     LOG_E(PHY,"illegal harq_pid %d %s:%d\n", harq_pid, __FILE__, __LINE__);
     return;
   }
+#ifdef LATSEQ
+  if (rel8->rnti != 0xFFFF) {
+    uint16_t sfn_sf = (uint16_t)((frame << 4 ) | subframe);
+    LATSEQ_P("D mac.txreq--mac.harq.down", "len%d:rnti%d:txreq%d.harq%d.sfn%d", rel8->length, rel8->rnti, rel8->pdu_index, harq_pid, sfn_sf);
+  }
+#endif
 
   dlsch0_harq     = dlsch0->harq_processes[harq_pid];
   dlsch1_harq     = dlsch1->harq_processes[harq_pid];
diff --git a/openair1/SCHED/phy_procedures_lte_eNb.c b/openair1/SCHED/phy_procedures_lte_eNb.c
index 973c921d23..55705e5bd0 100644
--- a/openair1/SCHED/phy_procedures_lte_eNb.c
+++ b/openair1/SCHED/phy_procedures_lte_eNb.c
@@ -41,6 +41,9 @@
 #include <common/utils/system.h>
 #include "common/utils/LOG/vcd_signal_dumper.h"
 #include <nfapi/oai_integration/nfapi_pnf.h>
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "assertions.h"
 #include "msc.h"
@@ -683,6 +686,13 @@ void phy_procedures_eNB_TX(PHY_VARS_eNB *eNB,
                 dlsch0->harq_ids[frame%2][6],
                 dlsch0->harq_ids[frame%2][7]);
       } else {
+
+#if LATSEQ
+//dci is always 1
+        if(dlsch0->rnti != 0xFFFF)  // Corresponds to a broadcast rnti
+          LATSEQ_P("D mac.harq.down--phy.out.proc","len%d:rnti%d:harq%d.fm%d.subfm%d", dlsch0->harq_processes[harq_pid]->TBS/8,dlsch0->rnti, harq_pid, frame, subframe);
+#endif
+
         if (dlsch_procedures(eNB,
                              proc,
                              harq_pid,
@@ -1333,76 +1341,82 @@ void postDecode(L1_rxtx_proc_t *proc, notifiedFIFO_elt_t *req) {
       proc->nbDecode-=nb;
       LOG_D(PHY,"uplink segment error %d/%d, aborted %d segments\n",rdata->segment_r,rdata->nbSegments, nb);
       AssertFatal(ulsch_harq->processedSegments+nb == rdata->nbSegments,"processed: %d, aborted: %d, total %d\n",
-		  ulsch_harq->processedSegments, nb, rdata->nbSegments);
+      ulsch_harq->processedSegments, nb, rdata->nbSegments);
       ulsch_harq->processedSegments=rdata->nbSegments;
     }
   }
 
   // if this UE segments are all done
   if ( rdata->nbSegments == ulsch_harq->processedSegments) {
-      //compute the expected ULSCH RX power (for the stats)
-      int i=rdata->UEid;
-      ulsch_harq->delta_TF = get_hundred_times_delta_IF_eNB(eNB,i,rdata->harq_pid, 0); // 0 means bw_factor is not considered
-      if (RC.mac != NULL) { /* ulsim does not use RC.mac context. */
-	if (ulsch_harq->cqi_crc_status == 1) {
-	  fill_ulsch_cqi_indication(eNB,rdata->frame,rdata->subframe,ulsch_harq,ulsch->rnti);
-	  RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
-	} else {
-	  if(RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag & (1 << rdata->subframe) ) {
-	    RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
-	    RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_timer=30;
-	    LOG_D(PHY,"Frame %d,Subframe %d, We're supposed to get a cqi here. Set cqi_req_timer to 30.\n",rdata->frame,rdata->subframe);
-	  }
-	}
+    //compute the expected ULSCH RX power (for the stats)
+    int i=rdata->UEid;
+    ulsch_harq->delta_TF = get_hundred_times_delta_IF_eNB(eNB,i,rdata->harq_pid, 0); // 0 means bw_factor is not considered
+    if (RC.mac != NULL) { /* ulsim does not use RC.mac context. */
+      if (ulsch_harq->cqi_crc_status == 1) {
+        fill_ulsch_cqi_indication(eNB,rdata->frame,rdata->subframe,ulsch_harq,ulsch->rnti);
+        RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
+      } else {
+        if(RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag & (1 << rdata->subframe) ) {
+          RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
+          RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_timer=30;
+          LOG_D(PHY,"Frame %d,Subframe %d, We're supposed to get a cqi here. Set cqi_req_timer to 30.\n",rdata->frame,rdata->subframe);
+        }
       }
-	
-      if (!decodeSucess) {
-        T(T_ENB_PHY_ULSCH_UE_NACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti),
-          T_INT(rdata->harq_pid));
-	fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,1); // indicate NAK to MAC
-	fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
-	LOG_D(PHY,"[eNB %d][PUSCH %d] frame %d subframe %d UE %d Error receiving ULSCH, round %d/%d (ACK %d,%d)\n",
-	      eNB->Mod_id,rdata->harq_pid,
-	      rdata->frame,rdata->subframe, i,
-	      ulsch_harq->round,
-	      ulsch->Mlimit,
-	      ulsch_harq->o_ACK[0],
-	      ulsch_harq->o_ACK[1]);
-	  
-	if (ulsch_harq->round >= 3)  {
-	  ulsch_harq->status  = SCH_IDLE;
-	  ulsch_harq->handled = 0;
-	  ulsch->harq_mask   &= ~(1 << rdata->harq_pid);
-	  ulsch_harq->round   = 0;
-	}
-	/* Mark the HARQ process to release it later if max transmission reached
-	 * (see below).
-	 * MAC does not send the max transmission count, we have to deal with it
-	 * locally in PHY.
-	 */
-	ulsch_harq->handled = 1;
-      }  // ulsch in error
-      else if(ulsch_harq->repetition_number == ulsch_harq->total_number_of_repetitions){
-	fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,0); // indicate ACK to MAC
-	fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
-	ulsch_harq->status = SCH_IDLE;
-	ulsch->harq_mask &= ~(1 << rdata->harq_pid);
-	for (int j=0;j<NUMBER_OF_ULSCH_MAX;j++) 
-           if (eNB->ulsch_stats[j].rnti == ulsch->rnti) {
-              eNB->ulsch_stats[j].total_bytes_rx+=ulsch_harq->TBS;
-              for (int aa=0;aa<eNB->frame_parms.nb_antennas_rx;aa++) {
-                eNB->ulsch_stats[j].ulsch_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_power[aa]);
-                eNB->ulsch_stats[j].ulsch_noise_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_noise_power[aa]); 
-              }
-              break;
-           }
-        T (T_ENB_PHY_ULSCH_UE_ACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti),
-           T_INT(rdata->harq_pid));
-      }  // ulsch not in error
-	
-      if (ulsch_harq->O_ACK>0)
-	fill_ulsch_harq_indication(eNB,ulsch_harq,ulsch->rnti,rdata->frame,rdata->subframe,ulsch->bundling);
-  } 
+    }
+
+    if (!decodeSucess) {
+      T(T_ENB_PHY_ULSCH_UE_NACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti), T_INT(rdata->harq_pid));
+#ifdef LATSEQ
+      LATSEQ_P("I mac.harq.up", "nack%d:ue%d:harq%d.fm%d.subfm%d", ulsch_harq->round, rdata->UEid, rdata->harq_pid, rdata->frame, rdata->subframe);
+#endif
+      fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,1); // indicate NAK to MAC
+      fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
+
+      LOG_D(PHY,"[eNB %d][PUSCH %d] frame %d subframe %d UE %d Error receiving ULSCH, round %d/%d (ACK %d,%d)\n",
+            eNB->Mod_id,rdata->harq_pid,
+            rdata->frame,rdata->subframe, i,
+            ulsch_harq->round,
+            ulsch->Mlimit,
+            ulsch_harq->o_ACK[0],
+            ulsch_harq->o_ACK[1]);
+        
+      if (ulsch_harq->round >= 3)  {
+        ulsch_harq->status  = SCH_IDLE;
+        ulsch_harq->handled = 0;
+        ulsch->harq_mask   &= ~(1 << rdata->harq_pid);
+        ulsch_harq->round   = 0;
+      }
+      /* Mark the HARQ process to release it later if max transmission reached
+        * (see below).
+        * MAC does not send the max transmission count, we have to deal with it
+        * locally in PHY.
+        */
+      ulsch_harq->handled = 1;
+    }  // ulsch in error
+    else if(ulsch_harq->repetition_number == ulsch_harq->total_number_of_repetitions) {
+#ifdef LATSEQ
+      LATSEQ_P("I mac.harq.up", "nack%d:ue%d:harq%d.fm%d.subfm%d", 0, rdata->UEid, rdata->harq_pid, rdata->frame, rdata->subframe);
+#endif
+      fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,0); // indicate ACK to MAC
+      fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
+      ulsch_harq->status = SCH_IDLE;
+      ulsch->harq_mask &= ~(1 << rdata->harq_pid);
+      for (int j=0;j<NUMBER_OF_ULSCH_MAX;j++) {
+        if (eNB->ulsch_stats[j].rnti == ulsch->rnti) {
+          eNB->ulsch_stats[j].total_bytes_rx+=ulsch_harq->TBS;
+          for (int aa=0;aa<eNB->frame_parms.nb_antennas_rx;aa++) {
+            eNB->ulsch_stats[j].ulsch_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_power[aa]);
+            eNB->ulsch_stats[j].ulsch_noise_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_noise_power[aa]); 
+          }
+          break;
+        }
+      }
+      T (T_ENB_PHY_ULSCH_UE_ACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti), T_INT(rdata->harq_pid));
+    }  // ulsch not in error
+
+    if (ulsch_harq->O_ACK>0)
+      fill_ulsch_harq_indication(eNB,ulsch_harq,ulsch->rnti,rdata->frame,rdata->subframe,ulsch->bundling);
+  }
 }
 
 void pusch_procedures(PHY_VARS_eNB *eNB,L1_rxtx_proc_t *proc) {
@@ -1498,13 +1512,20 @@ void pusch_procedures(PHY_VARS_eNB *eNB,L1_rxtx_proc_t *proc) {
       ulsch->harq_mask &= ~(1 << harq_pid);
       LOG_W (PHY, "Removing stale ULSCH config for UE %x harq_pid %d (harq_mask is now 0x%2.2x)\n", ulsch->rnti, harq_pid, ulsch->harq_mask);
     }
+/*
+#if LATSEQ
+    LATSEQ_P_TEST("U phy.in.proc--mac.demux","ue%d.rnti%d.fm%d:harq%d.round%d.subfm%d",i, ulsch->rnti, frame, harq_pid, ulsch_harq->round, subframe);
+#endif
+*/
   }   //   for (i=0; i<NUMBER_OF_ULSCH_MAX; i++)
+
   
   while (proc->nbDecode > 0) {
     notifiedFIFO_elt_t *req=pullTpool(proc->respDecode, proc->threadPool);
     postDecode(proc, req);
     delNotifiedFIFO_elt(req);
   }
+
 }
 
 extern int      oai_exit;
diff --git a/openair2/COMMON/gtpv1_u_messages_types.h b/openair2/COMMON/gtpv1_u_messages_types.h
index 75df3253f6..5c0f9a8ff1 100644
--- a/openair2/COMMON/gtpv1_u_messages_types.h
+++ b/openair2/COMMON/gtpv1_u_messages_types.h
@@ -127,6 +127,7 @@ typedef struct gtpv1u_enb_tunnel_data_req_s {
   uint32_t               offset;               ///< start of message offset in buffer
   rnti_t                 rnti;
   rb_id_t                rab_id;
+  uint32_t               seqnum;
 } gtpv1u_enb_tunnel_data_req_t;
 
 typedef struct gtpv1u_enb_data_forwarding_req_s {
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c b/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c
index 596d978a98..c694c218c6 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c
@@ -58,6 +58,9 @@
 #include <dlfcn.h>
 
 #include "T.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #define ENABLE_MAC_PAYLOAD_DEBUG
 //#define DEBUG_eNB_SCHEDULER 1
@@ -753,7 +756,6 @@ schedule_ue_spec(module_id_t module_idP,
                   round_DL,
                   ue_template->oldmcs1[harq_pid]);
           }
-
           dl_req->tl.tag = NFAPI_DL_CONFIG_REQUEST_BODY_TAG;
           eNB->DL_req[CC_id].sfn_sf = frameP<<4 | subframeP;
           eNB->DL_req[CC_id].header.message_id = NFAPI_DL_CONFIG_REQUEST;
@@ -947,6 +949,9 @@ schedule_ue_spec(module_id_t module_idP,
 
         LOG_D(MAC, "dlsch_mcs before and after the rate matching = (%d, %d), TBS %d, nb_rb %d\n",
               eNB_UE_stats->dlsch_mcs1, mcs, TBS, nb_rb);
+#ifdef LATSEQ
+        LATSEQ_P("I mac.sched.down", "mcs%d.tbs%d.nrb%d:rnti%d:lcid%d", eNB_UE_stats->dlsch_mcs1, TBS, nb_rb, rnti, sdu_lcids[0]);
+#endif
 
         int post_padding = TBS - header_length_total - sdu_length_total - ta_len > 2;
         int padding = post_padding ? 0 : TBS - header_length_total - sdu_length_total - ta_len;
@@ -1186,6 +1191,9 @@ schedule_ue_spec(module_id_t module_idP,
                                     dlsch_pdu->payload[0]);
         LOG_D(MAC, "Filled NFAPI configuration for DCI/DLSCH/TXREQ %d, new SDU\n",
               eNB->pdu_index[CC_id]);
+#if LATSEQ
+        LATSEQ_P("D mac.mux--mac.txreq","len%d:rnti%d:lcid%d.txreq%d.reqfm%d.harq%d.sfn%d", TBS, rnti, sdu_lcids[0], eNB->pdu_index[CC_id], frameP, harq_pid, eNB->TX_req[CC_id].sfn_sf);
+#endif
         eNB->pdu_index[CC_id]++;
         program_dlsch_acknak(module_idP,
                              CC_id,
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c b/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c
index e9f0b807c4..67d83e2008 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c
@@ -49,6 +49,9 @@
 #include "rlc.h"
 #include "common/utils/lte/prach_utils.h"
 #include "T.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 
 #ifdef PHY_TX_THREAD
@@ -2066,6 +2069,9 @@ schedule_ue_spec_fairRR(module_id_t module_idP,
                                     0, //number of PRBs treated as one subband, not used here
                                     0 // number of beamforming vectors, not used here
                                    );
+#if LATSEQ
+            LATSEQ_P("D mac.mux--mac.txreq","len%d:rnti%d:lcid%d.txreq%d.reqfm%d.harq%d.sfn%d", TBS, rnti, sdu_lcids[0], eNB->pdu_index[CC_id], frameP, harq_pid, eNB->TX_req[CC_id].sfn_sf);
+#endif
             dl_req->number_pdu++;
             eNB->TX_req[CC_id].sfn_sf = fill_nfapi_tx_req(&eNB->TX_req[CC_id].tx_request_body,
                                         (frameP*10)+subframeP,
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_primitives.c b/openair2/LAYER2/MAC/eNB_scheduler_primitives.c
index bd3c428828..5ed0c19f30 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_primitives.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_primitives.c
@@ -38,6 +38,9 @@
 #include "common/utils/LOG/log.h"
 #include "nfapi/oai_integration/vendor_ext.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 #include "UTIL/OPT/opt.h"
 #include "OCG.h"
 #include "OCG_extern.h"
@@ -3980,6 +3983,9 @@ extract_harq(module_id_t mod_idP,
                     subframe_tx,
                     harq_pid,
                     sched_ctl->round[CC_idP][harq_pid]);
+#ifdef LATSEQ
+              LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d.fm%d.subfm%d", 0, UE_id, harq_pid, frame_tx, subframe_tx);
+#endif
             } else { //nack
               if (sched_ctl->round[CC_idP][harq_pid] < 8) sched_ctl->round[CC_idP][harq_pid]++;
 
@@ -3995,6 +4001,9 @@ extract_harq(module_id_t mod_idP,
                     subframe_tx,
                     harq_pid,
                     sched_ctl->round[CC_idP][harq_pid]);
+#ifdef LATSEQ
+              LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d.fm%d.subfm%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid, frame_tx, subframe_tx);
+#endif
 
               if (sched_ctl->round[CC_idP][harq_pid] == 8) {
                 for (uint8_t ra_i = 0; ra_i < NB_RA_PROC_MAX; ra_i++) {
@@ -4138,9 +4147,14 @@ extract_harq(module_id_t mod_idP,
             sched_ctl->tbcnt[CC_idP][harq_pid] = 0;
             /* CDRX: PUCCH gives an ACK, so reset corresponding HARQ RTT */
             sched_ctl->harq_rtt_timer[CC_idP][harq_pid] = 0;
+#ifdef LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", 0, UE_id, harq_pid);
+#endif
           } else if (pdu[0] == 2 || pdu[0] == 4) {  // NAK (treat DTX as NAK)
             sched_ctl->round[CC_idP][harq_pid]++; // increment round
-
+#ifdef LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
               sched_ctl->round[CC_idP][harq_pid] = 8; // release HARQ process
               sched_ctl->tbcnt[CC_idP][harq_pid] = 0;
@@ -4170,6 +4184,9 @@ extract_harq(module_id_t mod_idP,
           if (num_ack_nak == 2 && sched_ctl->round[CC_idP][harq_pid] < 8 && sched_ctl->tbcnt[CC_idP][harq_pid] == 1 && pdu[0] == 1 && pdu[1] == 1) {
             sched_ctl->round[CC_idP][harq_pid] = 8;
             sched_ctl->tbcnt[CC_idP][harq_pid] = 0;
+#ifdef LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", 0, UE_id, harq_pid);
+#endif
             /* CDRX: PUCCH gives an ACK, so reset corresponding HARQ RTT */
             sched_ctl->harq_rtt_timer[CC_idP][harq_pid] = 0;
           }
@@ -4179,6 +4196,9 @@ extract_harq(module_id_t mod_idP,
               && (sched_ctl->tbcnt[CC_idP][harq_pid] == 1)
               && (pdu[0] == 2) && (pdu[1] == 2)) {
             sched_ctl->round[CC_idP][harq_pid]++;
+#ifdef LATSEQ
+              LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
 
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
               sched_ctl->round[CC_idP][harq_pid] = 8;     // release HARQ process
@@ -4195,6 +4215,9 @@ extract_harq(module_id_t mod_idP,
                          && (sched_ctl->tbcnt[CC_idP][harq_pid] == 2)
                          && (pdu[0] == 2) && (pdu[1] == 1))) {
             sched_ctl->round[CC_idP][harq_pid]++;
+#ifdef LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
             sched_ctl->tbcnt[CC_idP][harq_pid] = 1;
 
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
@@ -4208,6 +4231,9 @@ extract_harq(module_id_t mod_idP,
                      && (sched_ctl->tbcnt[CC_idP][harq_pid] == 2)
                      && (pdu[0] == 2) && (pdu[1] == 2)) {
             sched_ctl->round[CC_idP][harq_pid]++;
+#ifdef LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
 
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
               sched_ctl->round[CC_idP][harq_pid] = 8;     // release HARQ process
@@ -4834,6 +4860,9 @@ extract_pusch_csi(module_id_t mod_idP,
       }
 
       sched_ctl->dl_cqi[CC_idP] = sched_ctl->aperiodic_wideband_cqi0[CC_idP];
+#ifdef LATSEQ
+      LATSEQ_P("I phy.srs", "dcqi%d:ru%d.ue%d:", sched_ctl->dl_cqi[CC_idP], CC_idP, UE_id);
+#endif
       break;
 
     case LTE_CQI_ReportModeAperiodic_rm31:
@@ -5050,6 +5079,9 @@ SR_indication(module_id_t mod_idP,
 
       UE_info->UE_template[cc_idP][UE_id].ul_SR = 1;
       UE_info->UE_template[cc_idP][UE_id].ul_active = TRUE;
+#ifdef LATSEQ
+      LATSEQ_P("I mac.ind", "sr%d:ue%d:fm%d.subfm%d", 1, UE_id, frameP, subframeP);
+#endif
       VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_SR_INDICATION, 1);
       VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_SR_INDICATION, 0);
     }
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c b/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c
index d4f486f761..f5eede58ca 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c
@@ -60,6 +60,9 @@
 #include "common/utils/lte/prach_utils.h"
 
 #include "T.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "common/ran_context.h"
 extern RAN_CONTEXT_t RC;
@@ -169,6 +172,11 @@ rx_sdu(const module_id_t enb_mod_idP,
        * lte_est_timing_advance_pusch, maybe it's not necessary?
        * maybe it's even not correct at all?
        */
+
+#ifdef LATSEQ
+      LATSEQ_P("I phy.srs", "ucqi%d:ru%d.ue%d:", ul_cqi, CC_idP, UE_id);
+#endif
+
       UE_scheduling_control->ta_update_f = ((double)UE_scheduling_control->ta_update_f * 3 + (double)timing_advance) / 4;
       UE_scheduling_control->ta_update = (int)UE_scheduling_control->ta_update_f;
       int tmp_snr = (5 * ul_cqi - 640) / 10;
@@ -444,7 +452,9 @@ rx_sdu(const module_id_t enb_mod_idP,
           if (UE_template_ptr->phr_info > 40) {
             UE_template_ptr->phr_info = 40;
           }
-
+#ifdef LATSEQ
+          LATSEQ_P("I mac.ind", "phr%d:ue%d:", UE_template_ptr->phr_info, UE_id);
+#endif
           LOG_D(MAC, "[eNB %d] CC_id %d MAC CE_LCID %d : Received PHR PH = %d (db)\n",
                 enb_mod_idP,
                 CC_idP,
@@ -594,6 +604,9 @@ rx_sdu(const module_id_t enb_mod_idP,
           int bsr = 0;
           bsr = payload_ptr[0] & 0x3f;
           lcgid_updated[lcgid] = 1;
+#ifdef LATSEQ
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr, BSR_TABLE[bsr], UE_id, lcgid);
+#endif
           /* Update buffer info */
           UE_template_ptr->ul_buffer_info[lcgid] = BSR_TABLE[bsr];
           UE_template_ptr->estimated_ul_buffer =
@@ -646,6 +659,12 @@ rx_sdu(const module_id_t enb_mod_idP,
             UE_template_ptr->ul_buffer_info[LCGID1] +
             UE_template_ptr->ul_buffer_info[LCGID2] +
             UE_template_ptr->ul_buffer_info[LCGID3];
+#ifdef LATSEQ
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr0, BSR_TABLE[bsr0], UE_id, 0);
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr1, BSR_TABLE[bsr1], UE_id, 1);
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr2, BSR_TABLE[bsr2], UE_id, 2);
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr3, BSR_TABLE[bsr3], UE_id, 3);
+#endif
           LOG_D(MAC, "[eNB %d] CC_id %d MAC CE_LCID %d: Received long BSR. Size is LCGID0 = %u LCGID1 = %u LCGID2 = %u LCGID3 = %u\n",
                 enb_mod_idP,
                 CC_idP,
@@ -965,6 +984,9 @@ rx_sdu(const module_id_t enb_mod_idP,
               }
             }
 
+#if LATSEQ
+              LATSEQ_P("U mac.harq.up--mac.demux", "len%d:rnti%d:ue%d.lcid%d.fm%d.subfm%d", rx_lengths[i], current_rnti, UE_id, rx_lcids[i], frameP, subframeP);
+#endif
               mac_rlc_data_ind(enb_mod_idP, current_rnti, enb_mod_idP, frameP, ENB_FLAG_YES, MBMS_FLAG_NO, rx_lcids[i], (char *) payload_ptr, rx_lengths[i], 1, NULL);
               UE_info->eNB_UE_stats[CC_idP][UE_id].num_pdu_rx[rx_lcids[i]] += 1;
               UE_info->eNB_UE_stats[CC_idP][UE_id].num_bytes_rx[rx_lcids[i]] += rx_lengths[i];
@@ -1662,6 +1705,9 @@ schedule_ulsch_rnti(module_id_t   module_idP,
         T_INT(rb_table[rb_table_index]),
         T_INT(UE_template_ptr->TBS_UL[harq_pid]),
         T_INT(ndi));
+#ifdef LATSEQ
+      LATSEQ_P("I mac.sched.up", "mcs%d.tbs%d.nrb%d:ue%d:fm%d.subfm%d", mcs, UE_info->eNB_UE_stats[CC_id][UE_id].ulsch_TBS, rb_table[rb_table_index], UE_id, frameP, subframeP);
+#endif
       /* Store information for possible retransmission */
       UE_template_ptr->nb_rb_ul[harq_pid] = rb_table[rb_table_index];
       UE_template_ptr->first_rb_ul[harq_pid] = UE_template_ptr->pre_first_nb_rb_ul;
diff --git a/openair2/LAYER2/PDCP_v10.1.0/pdcp.c b/openair2/LAYER2/PDCP_v10.1.0/pdcp.c
index cddb666bfd..5ed183814b 100644
--- a/openair2/LAYER2/PDCP_v10.1.0/pdcp.c
+++ b/openair2/LAYER2/PDCP_v10.1.0/pdcp.c
@@ -84,6 +84,11 @@ hash_table_t  *pdcp_coll_p = NULL;
   static int mbms_socket = -1;
 #endif
 
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
+
 uint32_t Pdcp_stats_tx_window_ms[MAX_eNB][MAX_MOBILES_PER_ENB];
 uint32_t Pdcp_stats_tx_bytes[MAX_eNB][MAX_MOBILES_PER_ENB][NB_RB_MAX];
 uint32_t Pdcp_stats_tx_bytes_w[MAX_eNB][MAX_MOBILES_PER_ENB][NB_RB_MAX];
@@ -116,6 +121,7 @@ int pdcp_pc5_sockfd;
 struct sockaddr_in prose_ctrl_addr;
 struct sockaddr_in prose_pdcp_addr;
 struct sockaddr_in pdcp_sin;
+
 /* pdcp module parameters and related functions*/
 static pdcp_params_t pdcp_params= {0,NULL};
 rnti_t                 pdcp_UE_UE_module_id_to_rnti[MAX_MOBILES_PER_ENB];
@@ -373,6 +379,12 @@ boolean_t pdcp_data_req(
         VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_PDCP_DATA_REQ,VCD_FUNCTION_OUT);
         return FALSE;
       }
+#if LATSEQ
+      if (!srb_flagP) {
+        LATSEQ_P("D pdcp.in--pdcp.tx","len%d:rnti%d:drb%d.gsn%d.psn%d", sdu_buffer_sizeP, ctxt_pP->rnti, rb_idP, RC.gtpv1u_data_g->tx_seq_num, current_sn);
+      }
+#endif
+
 
       LOG_D(PDCP, "Sequence number %d is assigned to current PDU\n", current_sn);
       /* Then append data... */
@@ -989,6 +1001,7 @@ pdcp_data_ind(
     return TRUE;
   }
 
+
   // XXX Decompression would be done at this point
   /*
    * After checking incoming sequence number PDCP header
@@ -1025,6 +1038,9 @@ pdcp_data_ind(
       GTPV1U_ENB_TUNNEL_DATA_REQ(message_p).rab_id       = rb_id + 4;
       itti_send_msg_to_task(TASK_VARIABLE, INSTANCE_DEFAULT, message_p);
       packet_forwarded = TRUE;
+#if LATSEQ
+      LATSEQ_P("U pdcp.rx--gtp.out","len%d:rnti%d:drb%d.psn%d",sdu_buffer_sizeP, ctxt_pP->rnti, rb_id, sequence_number);
+#endif
     }
   } else {
     packet_forwarded = FALSE;
@@ -1102,11 +1118,18 @@ pdcp_data_ind(
       memcpy(pdcpHead+1,
              &sdu_buffer_pP->data[payload_offset],
              sdu_buffer_sizeP - payload_offset);
+
       if( LOG_DEBUGFLAG(DEBUG_PDCP) )
-	log_dump(PDCP, pdcpHead+1, min(sdu_buffer_sizeP - payload_offset,30) , LOG_DUMP_CHAR,
-	         "Printing first bytes of PDCP SDU before adding it to the list: \n");
+        log_dump(PDCP, pdcpHead+1, min(sdu_buffer_sizeP - payload_offset,30) , LOG_DUMP_CHAR,
+        "Printing first bytes of PDCP SDU before adding it to the list: \n");
+#if LATSEQ
+      if (srb_flagP == FALSE) {
+        LATSEQ_P("U pdcp.rx--pdcp.out","len%d:rnti%d:drb%d.lid%d.psn%d.fm%d",(sdu_buffer_sizeP - payload_offset), ctxt_pP->rnti, rb_id, pdcpHead->destinationL2Id, sequence_number, ctxt_pP->frame);
+      }
+#endif
       pushNotifiedFIFO(&pdcp_sdu_list, new_sdu_p); 
 
+
     /* Print octets of incoming data in hexadecimal form */
       LOG_D(PDCP, "Following content has been received from RLC (%d,%d)(PDCP header has already been removed):\n",
           sdu_buffer_sizeP  - payload_offset + (int)sizeof(pdcp_data_ind_header_t),
diff --git a/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c b/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c
index cc44572abd..b8436a2d3a 100644
--- a/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c
+++ b/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c
@@ -57,6 +57,9 @@ extern int otg_enabled;
 #include "UTIL/OTG/otg_tx.h"
 #include "nfapi/oai_integration/vendor_ext.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 #include "platform_constants.h"
 #include "msc.h"
 #include "pdcp.h"
@@ -130,20 +133,31 @@ int pdcp_fifo_flush_sdus(const protocol_ctxt_t *const  ctxt_pP) {
         }
        else
        {
-	 if( LOG_DEBUGFLAG(DEBUG_PDCP) ) 
-	   log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
-	 ret = write(nas_sock_fd[pdcpHead->inst], pdcpData,pdcpHead->data_size );
-	 LOG_T(PDCP,"[UE PDCP_FIFOS] ret %d TRIED TO PUSH DATA TO rb_id %d handle %d sizeToWrite %d\n",
-	       ret,rb_id,nas_sock_fd[pdcpHead->inst],pdcpHead->data_size);
+    if( LOG_DEBUGFLAG(DEBUG_PDCP) ) {
+      log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
+    }
+
+      ret = write(nas_sock_fd[pdcpHead->inst], pdcpData,pdcpHead->data_size );
+      LOG_T(PDCP,"[UE PDCP_FIFOS] ret %d TRIED TO PUSH DATA TO rb_id %d handle %d sizeToWrite %d\n",
+         ret,rb_id,nas_sock_fd[pdcpHead->inst],pdcpHead->data_size);
        }
     } else if (ENB_NAS_USE_TUN) {
-      if( LOG_DEBUGFLAG(DEBUG_PDCP) ) 
-	log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
+
+      if( LOG_DEBUGFLAG(DEBUG_PDCP) ) {
+        log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
+      }
+#if LATSEQ
+      LATSEQ_P("U pdcp.out.nas--ip.out", "len%d:rnti%d:drb%d.sock%d.lid%d.fm%d", pdcpHead->data_size, ctxt_pP->rnti, rb_id, nas_sock_fd[0], pdcpHead->destinationL2Id, ctxt_pP->frame);
+#endif
       ret = write(nas_sock_fd[0], pdcpData, pdcpHead->data_size);
        LOG_T(PDCP,"[NB PDCP_FIFOS] ret %d TRIED TO PUSH DATA TO rb_id %d handle %d sizeToWrite %d\n",ret,rb_id,nas_sock_fd[0],pdcpHead->data_size);
     } else if (PDCP_USE_NETLINK) {
       int sizeToWrite= sizeof (pdcp_data_ind_header_t) + pdcpHead->data_size;
+#if LATSEQ
+      LATSEQ_P("U pdcp.out.nl--ip.out", "len%d:rnti%d:drb%d.sock%d.lid%d.fm%d", sizeToWrite, ctxt_pP->rnti, rb_id, nas_sock_fd[0], pdcpHead->destinationL2Id, ctxt_pP->frame);
+#endif
       memcpy(NLMSG_DATA(nas_nlh_tx), (uint8_t *) pdcpHead,  sizeToWrite);
+
       nas_nlh_tx->nlmsg_len = sizeToWrite;
       ret = sendmsg(nas_sock_fd[0],&nas_msg_tx,0);
     }  //  PDCP_USE_NETLINK
@@ -243,7 +257,9 @@ int pdcp_fifo_read_input_sdus_fromtun (const protocol_ctxt_t *const  ctxt_pP) {
       LOG_D(PDCP, "[FRAME %5u][UE][IP][INSTANCE %ld][RB %ld][--- PDCP_DATA_REQ / %d Bytes --->][PDCP][MOD %u][UE %04x][RB %ld]\n",
             ctxt.frame, ctxt.instance, rab_id, len, ctxt.module_id,
             ctxt.rnti, rab_id);
-
+#if LATSEQ
+      LATSEQ_P("D ip.in--pdcp.in.tun", "len%d:rnti%d:drb%d", len, ctxt.rnti, rab_id);
+#endif
 #if defined  ENABLE_PDCP_PAYLOAD_DEBUG
       LOG_I(PHY, "TUN interface output received from PDCP: \n");
       for (int i = 0; i < 128; i++) {
@@ -385,7 +401,6 @@ int pdcp_fifo_read_input_sdus_fromnetlinksock (const protocol_ctxt_t *const  ctx
     VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PDCP_FIFO_READ_BUFFER, 1 );
     len = recvmsg(nas_sock_fd[0], &nas_msg_rx, 0);
     VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PDCP_FIFO_READ_BUFFER, 0 );
-
     if (len > 0) {
       for (nas_nlh_rx = (struct nlmsghdr *) nl_rx_buf;
            NLMSG_OK (nas_nlh_rx, len);
@@ -448,6 +463,9 @@ int pdcp_fifo_read_input_sdus_fromnetlinksock (const protocol_ctxt_t *const  ctx
                       ctxt.module_id,
                       ctxt.rnti,
                       rab_id);
+#if LATSEQ
+                LATSEQ_P("D ip--pdcp.in.nl", "len%d:rnti%d:drb%d", pdcp_read_header_g.data_size, ctxt.rnti, rab_id);
+#endif
                 pdcp_data_req(&ctxt,
                               SRB_FLAG_NO,
                               rab_id,
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c
index de947225bb..f95f598575 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c
@@ -39,6 +39,9 @@
 #include "common/utils/LOG/log.h"
 #include "LTE_UL-AM-RLC.h"
 #include "LTE_DL-AM-RLC.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 uint32_t
@@ -719,6 +722,10 @@ rlc_am_mac_data_request (
             LOG_UI(RLC,"%s\n",message_string);
           } /* LOG_DEBUGFLAG(DEBUG_RLC) */
         }
+#if LATSEQ
+    LATSEQ_P("D rlc.seg.am--mac.mux","len%d:rnti%d:drb%d.lcid%d.rsn%d.reqfm%d", tb_size_in_bytes, ctxt_pP->rnti, l_rlc_p->rb_id, l_rlc_p->channel_id, pdu_info.sn , ctxt_pP->frame);
+    //.so%d : pdu_info.so
+#endif
       } else {
         if (rlc_am_get_control_pdu_infos(rlc_am_pdu_sn_10_p, &tb_size_in_bytes, &l_rlc_p->control_pdu_info) >= 0) {
           tb_size_in_bytes   = ((struct mac_tb_req *) (tb_p->data))->tb_size; //tb_size_in_bytes modified by rlc_am_get_control_pdu_infos!
@@ -1058,7 +1065,13 @@ rlc_am_data_req (
       message_string_size += sprintf(&message_string[message_string_size], " |\n");
       LOG_UI(RLC, "%s\n", message_string);
     } /* LOG_DEBUGFLAG(RLC) */
-
+#if LATSEQ
+    // Not necessary to detect userplane, because if it is the case
+    // then a rebuilding, no user data at input point
+    // but input point may belongs to userplane only
+    uint8_t seqnum = ((uint8_t *)(&sdu_pP->data[data_offset]))[1];
+    LATSEQ_P("D pdcp.tx--rlc.tx.am","len%d:rnti%d:drb%d.psn%d.lcid%d.rsdu%d", ((struct rlc_am_data_req *) (sdu_pP->data))->data_size, ctxt_pP->rnti, l_rlc_p->rb_id, seqnum, l_rlc_p->channel_id, l_rlc_p->next_sdu_index);
+#endif
     l_rlc_p->stat_tx_pdcp_sdu   += 1;
     l_rlc_p->stat_tx_pdcp_bytes += data_size;
     l_rlc_p->input_sdus[l_rlc_p->next_sdu_index].mui      = mui;
@@ -1080,6 +1093,9 @@ rlc_am_data_req (
     l_rlc_p->input_sdus[l_rlc_p->next_sdu_index].flags.no_new_sdu_segmented_in_last_pdu = 0;
     //l_rlc_p->input_sdus[l_rlc_p->next_sdu_index].li_index_for_discard = -1;
     l_rlc_p->next_sdu_index = (l_rlc_p->next_sdu_index + 1) % RLC_AM_SDU_CONTROL_BUFFER_SIZE;
+#if LATSEQ
+    LATSEQ_P("I rlc.am.txbuf","occ%d:drb%d", l_rlc_p->sdu_buffer_occupancy, l_rlc_p->rb_id);
+#endif
 
     if (l_rlc_p->channel_id <3) {
       LOG_I(RLC, PROTOCOL_RLC_AM_CTXT_FMT" RLC_AM_DATA_REQ size %d Bytes,  NB SDU %d current_sdu_index=%d next_sdu_index=%d conf %d mui %d vtA %d vtS %d\n",
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c
index 793d0057ac..830a4d0d3d 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c
@@ -31,6 +31,9 @@
 //#include "LAYER2/MAC/extern.h"
 #include "common/utils/LOG/log.h"
 #include "msc.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 inline void
@@ -162,6 +165,19 @@ rlc_am_send_sdu (
         PROTOCOL_RLC_AM_MSC_ARGS(ctxt_pP,rlc_pP),
         rlc_pP->output_sdu_size_to_write
       );
+#if LATSEQ
+      //there is 2 cases for pdcp sn lenght. Put the 2 possibilities...
+      // Copied from these functions
+      // pdcp_get_sequence_number_of_pdu_with_short_sn
+      // pdcp_get_sequence_number_of_pdu_with_long_sn
+
+      uint8_t psn_short = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x7F;
+      uint16_t psn_long = 0x00;
+      psn_long = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x0F;
+      psn_long <<= 8;
+      psn_long |= (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[1] & 0xFF;
+      LATSEQ_P("U rlc.rx.am--pdcp.rx","len%d:rnti%d:drb%d.lcid%d.rsn%d.psn%d.psn%d.fm%d", rlc_pP->output_sdu_size_to_write, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->vr_r, psn_short, psn_long, ctxt_pP->frame);
+#endif
       rlc_data_ind (ctxt_pP,
                     BOOL_NOT(rlc_pP->is_data_plane),
                     MBMS_FLAG_NO,
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c
index f9a4affb6b..594eff9b75 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c
@@ -30,6 +30,7 @@
 #include "list.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
+#include "common/utils/LATSEQ/latseq.h"
 
 
 //-----------------------------------------------------------------------------
@@ -346,6 +347,7 @@ rlc_am_receive_process_data_pdu (
             rlc_pP->vr_ms,
             rlc_pP->vr_x);
 
+
       pdu_status = rlc_am_rx_list_check_duplicate_insert_pdu(ctxt_pP, rlc_pP,tb_pP);
       if (pdu_status != RLC_AM_DATA_PDU_STATUS_OK) {
         rlc_pP->stat_rx_data_pdu_dropped     += 1;
@@ -522,7 +524,11 @@ if( (((rlc_am_rx_pdu_management_t*)(tb_pP->data))->all_segments_received) == (pd
       LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU]  PDU DISCARDED BAD HEADER FORMAT SN=%d\n",
             PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_info_p->sn);
   }
-
+#ifdef LATSEQ
+  // rlc_pP->vr_r fix pas terrible mais qui fera l'affaire pour l'instant
+  if (pdu_status == RLC_AM_DATA_PDU_STATUS_OK)
+    LATSEQ_P("U mac.demux--rlc.rx.am", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.fm%d", tb_size_in_bytesP, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->vr_r, pdu_info_p->so, ctxt_pP->frame);
+#endif
   if (pdu_status != RLC_AM_DATA_PDU_STATUS_OK) {
 	  /* Discard received block if out of window, duplicate or header error */
       free_mem_block (tb_pP, __func__);
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c
index 4a06553901..cf07a15575 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c
@@ -29,6 +29,9 @@
 #include "rlc_am.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 
 boolean_t rlc_am_rx_check_vr_reassemble(
@@ -453,8 +456,8 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
               LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT SN=%d SOSTART=%d] PDU SEGMENT INSERTED AFTER PDU SEGMENT WITH SOEND=%d\n",
                           PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn,so_start_segment,
 						  pdu_info_previous_cursor_p->so + pdu_info_previous_cursor_p->payload_size - 1);
-
 			  list2_insert_after_element(tb_pP, previous_cursor_p, &rlc_pP->receiver_buffer);
+
 			  return RLC_AM_DATA_PDU_STATUS_OK;
 		  }
 
@@ -538,7 +541,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
               LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT SN=%d SOSTART=%d SOEND=%d] PDU SEGMENT INSERTED BEFORE PDU SEGMENT WITH SOSTART=%d\n",
                             PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn,so_start_segment,so_end_segment,
 							pdu_info_cursor_p->so);
-
 			  list2_insert_before_element(tb_pP, cursor_p, &rlc_pP->receiver_buffer);
 			  return RLC_AM_DATA_PDU_STATUS_OK;
 		  }
@@ -606,7 +608,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
 	              LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT SN=%d SOSTART=%d] PDU SEGMENT INSERTED AFTER PDU SEGMENT WITH SOEND=%d\n",
 	                          PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn,so_start_segment,
 							  pdu_info_previous_cursor_p->so + pdu_info_previous_cursor_p->payload_size - 1);
-
 				  list2_insert_after_element(tb_pP, previous_cursor_p, &rlc_pP->receiver_buffer);
 				  return RLC_AM_DATA_PDU_STATUS_OK;
 			  }
@@ -705,7 +706,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
 	  if (trunc_segment != NULL) {
 		  LOG_I(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT]  CREATE SEGMENT FROM SEGMENT OFFSET=%d DATA LENGTH=%d SN=%d\n",
 						  PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),so_start_segment - pdu_rx_info_p->so,so_end_segment - so_start_segment + 1,pdu_rx_info_p->sn);
-
 		  if (previous_cursor_p != NULL) {
 			  list2_insert_after_element(trunc_segment, previous_cursor_p, &rlc_pP->receiver_buffer);
 		  }
@@ -779,7 +779,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu(
                             pdu_info_cursor_p->sn);
 	          list2_insert_before_element(tb_pP, cursor_p, &rlc_pP->receiver_buffer);
 	      }
-
 		  return pdu_status;
 	  }
 
@@ -811,14 +810,12 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu(
 
 	      LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU]  PDU REPLACES STORED PDU SEGMENTS SN=%d\n",
 	              PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn);
-
 	      if (previous_cursor_p != NULL) {
 	          list2_insert_after_element(tb_pP, previous_cursor_p, &rlc_pP->receiver_buffer);
 	      }
 	      else {
 	          list2_insert_before_element(tb_pP, cursor_next_p, &rlc_pP->receiver_buffer);
 	      }
-
 		  return pdu_status;
 	  } // End SN != vrR or SO != 0
 	  else {
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c
index dbe55c483d..db2d0fcbc3 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c
@@ -31,6 +31,9 @@
 #include "rlc_am.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 void rlc_am_pdu_polling (
@@ -550,6 +553,11 @@ void rlc_am_segment_10 (
     pdu_mngt_p->flags.transmitted = 1;
     pdu_mngt_p->sn = RLC_AM_PREV_SN(rlc_pP->vt_s);
 
+#if LATSEQ
+    for (int i=0; i < pdu_mngt_p->nb_sdus; i++) {
+      LATSEQ_P("D rlc.tx.am--rlc.seg.am","len%d:rnti%d:drb%d.lcid%d.rsdu%d.rsn%d", pdu_mngt_p->header_and_payload_size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, pdu_mngt_p->sdus_index[i], pdu_mngt_p->sn);
+    }
+#endif
 
     //TBC: What for resetting local pointers at the end ??
     pdu_p = NULL;
diff --git a/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c b/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c
index 4e3fffe176..b98379825d 100644
--- a/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c
+++ b/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c
@@ -30,6 +30,9 @@
 #include "rlc_primitives.h"
 #include "list.h"
 #include "LAYER2/MAC/mac_extern.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 //-----------------------------------------------------------------------------
 void
 rlc_tm_send_sdu (
@@ -67,7 +70,20 @@ rlc_tm_send_sdu (
 #endif
 
     memcpy (&rlc_pP->output_sdu_in_construction->data[rlc_pP->output_sdu_size_to_write], srcP, length_in_bytes);
-
+#if LATSEQ
+    if (rlc_pP->is_data_plane) {
+      //there is 2 cases for pdcp sn lenght. Put the 2 possibilities...
+      // Copied from these functions
+      // pdcp_get_sequence_number_of_pdu_with_short_sn
+      // pdcp_get_sequence_number_of_pdu_with_long_sn
+      uint8_t psn_short = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x7F;
+      uint16_t psn_long = 0x00;
+      psn_long = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x0F;
+      psn_long <<= 8;
+      psn_long |= (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[1] & 0xFF;
+      LATSEQ_P("U mac.demux--pdcp.rx","len%d:rnti%d:drb%d.lcid%d.psn%d.psn%d.fm%d", length_in_bytes, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, psn_short, psn_long, ctxt_pP->frame);
+    }
+#endif
     rlc_data_ind (
       ctxt_pP,
       BOOL_NOT(rlc_pP->is_data_plane),
@@ -114,12 +130,14 @@ rlc_tm_no_segment (
     ((struct mac_tb_req *) (pdu_p->data))->first_bit = 0;
     ((struct mac_tb_req *) (pdu_p->data))->tb_size = rlc_pP->rlc_pdu_size >> 3;
     list_add_tail_eurecom (pdu_p, &rlc_pP->pdus_to_mac_layer);
-
     rlc_pP->buffer_occupancy -= (sdu_mngt_p->sdu_size >> 3);
     free_mem_block (rlc_pP->input_sdus[rlc_pP->current_sdu_index], __func__);
     rlc_pP->input_sdus[rlc_pP->current_sdu_index] = NULL;
     rlc_pP->current_sdu_index = (rlc_pP->current_sdu_index + 1) % rlc_pP->size_input_sdus_buffer;
     rlc_pP->nb_sdu -= 1;
+#if LATSEQ
+    LATSEQ_P("D rlc.tx.tm--mac.mux","len%d:rnti%d:drb%d.lcid%d.rsdu%d.fm%d", sdu_mngt_p->sdu_size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->current_sdu_index, ctxt_pP->frame);
+#endif
   }
 }
 //-----------------------------------------------------------------------------
@@ -223,7 +241,13 @@ rlc_tm_data_req (
          rlc_p->current_sdu_index,
          rlc_p->next_sdu_index);
 #endif
-
+#if LATSEQ
+  // Not necessary to detect userplane, because if it is the case
+  // then a rebuilding, no user data at input point
+  // but input point may belongs to userplane only
+  uint8_t seqnum = (uint8_t)((unsigned char *)&sdu_pP->data)[1];
+  LATSEQ_P("D pdcp.tx--rlc.tx.tm","len%d:rnti%d:drb%d.lcid%d.psn%d.rsdu%d", ((struct rlc_um_data_req *) (sdu_pP->data))->data_size, ctxt_pP->rnti, rlc_p->rb_id, rlc_p->channel_id, seqnum, rlc_p->current_sdu_index);
+#endif
   // not in 3GPP specification but the buffer may be full if not correctly configured
   if (rlc_p->input_sdus[rlc_p->next_sdu_index] == NULL) {
     ((struct rlc_tm_tx_sdu_management *) (sdu_pP->data))->sdu_size = ((struct rlc_tm_data_req *) (sdu_pP->data))->data_size;
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c
index 654ddb8da7..f638554999 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c
@@ -37,7 +37,9 @@
 #include "mac_primitives.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
-
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "rlc_um_very_simple_test.h"
 
@@ -565,6 +567,9 @@ rlc_um_mac_data_request (const protocol_ctxt_t *const ctxt_pP, void *rlc_pP,cons
           message_string_size += sprintf(&message_string[message_string_size], " |\n");
           LOG_UI(RLC, "%s\n", message_string);
         } /*LOG_DEBUGFLAG(DEBUG_RLC) */
+#if LATSEQ
+        LATSEQ_P("D rlc.seg.um--mac.mux","len%d:rnti%d:drb%d.lcid%d.rsn%d.fm%d", tb_size_in_bytes, ctxt_pP->rnti, l_rlc_p->rb_id,l_rlc_p->channel_id, pdu_info.sn, ctxt_pP->frame);
+#endif
       } /* MESSAGE_CHART_GENERATOR || LOG_DEBUGFLAG(DEBUG_RLC) */
 
       tb_p = tb_p->next;
@@ -654,9 +659,21 @@ rlc_um_data_req (const protocol_ctxt_t *const ctxt_pP, void *rlc_pP, mem_block_t
 
     LOG_UI(RLC, "%s|\n", message_string);
   }
+#if LATSEQ
+  // Not necessary to detect userplane, because if it is the case
+  // then a rebuilding, no user data at input point
+  // but input point may belongs to userplane only
+  uint8_t seqnum = ((uint8_t *)(&sdu_pP->data[sizeof (struct rlc_um_data_req_alloc)]))[1];
+  uint16_t ssize = ((struct rlc_um_tx_sdu_management *) (sdu_pP->data))->sdu_size;
+  LATSEQ_P("D pdcp.tx--rlc.tx.um","len%d:rnti%d:drb%d.psn%d.lcid%d.rsdu%d", ssize, ctxt_pP->rnti, rlc_p->rb_id, seqnum, rlc_p->channel_id, ssize);
+#endif
+
 
   RLC_UM_MUTEX_LOCK(&rlc_p->lock_input_sdus, ctxt_pP, rlc_p);
   rlc_p->buffer_occupancy += ((struct rlc_um_tx_sdu_management *) (sdu_pP->data))->sdu_size;
+#if LATSEQ
+  LATSEQ_P("I rlc.um.txbuf","occ%d:drb%d", rlc_p->buffer_occupancy, rlc_p->rb_id);
+#endif
   list_add_tail_eurecom(sdu_pP, &rlc_p->input_sdus);
   RLC_UM_MUTEX_UNLOCK(&rlc_p->lock_input_sdus);
 
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c
index c8faa08358..fd6137da49 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c
@@ -32,6 +32,10 @@
 #include "list.h"
 #include "common/utils/LOG/log.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 //-----------------------------------------------------------------------------
 signed int rlc_um_get_pdu_infos(
   const protocol_ctxt_t* const ctxt_pP,
@@ -339,7 +343,10 @@ rlc_um_try_reassembly(
         }
         continue;
       }
-
+#if LATSEQ
+      if (rlc_pP->is_data_plane)
+        LATSEQ_P("U rlc.rx.um--rlc.unseg.um","len%d:rnti%d:drb%d.lcid%d.rsn%d.fm%d", size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->last_reassemblied_sn, ctxt_pP->frame);
+#endif
       if (e == RLC_E_FIXED_PART_DATA_FIELD_FOLLOW) {
         switch (fi) {
         case RLC_FI_1ST_BYTE_DATA_IS_1ST_BYTE_SDU_LAST_BYTE_DATA_IS_LAST_BYTE_SDU:
@@ -1041,6 +1048,7 @@ rlc_um_receive_process_dar (
     return;
   }
 
+
   RLC_UM_MUTEX_LOCK(&rlc_pP->lock_dar_buffer, ctxt_pP, rlc_pP);
 
   in_window = rlc_um_in_window(ctxt_pP, rlc_pP, rlc_pP->vr_uh - rlc_pP->rx_um_window_size, sn, rlc_pP->vr_ur);
@@ -1100,7 +1108,9 @@ rlc_um_receive_process_dar (
     mem_block_t *pdu = rlc_um_remove_pdu_from_dar_buffer(ctxt_pP, rlc_pP, sn);
     free_mem_block(pdu, __func__);
   }
-
+#if LATSEQ
+  LATSEQ_P("U mac.demux--rlc.rx.um","len%d:rnti%d:drb%d.lcid%d.rsn%d.fm%d", tb_sizeP, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, sn, ctxt_pP->frame);
+#endif
   rlc_um_store_pdu_in_dar_buffer(ctxt_pP, rlc_pP, pdu_mem_pP, sn);
 
 
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c
index 2eba223803..4ac31e9bcc 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c
@@ -36,6 +36,9 @@
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
 #include "msc.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 inline void
@@ -138,6 +141,20 @@ rlc_um_send_sdu (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP)
       rlc_um_v9_3_0_test_data_ind (rlc_pP->module_id, rlc_pP->rb_id, rlc_pP->output_sdu_size_to_write, rlc_pP->output_sdu_in_construction);
 #else
       // msg("[RLC] DATA IND ON MOD_ID %d RB ID %d, size %d\n",rlc_pP->module_id, rlc_pP->rb_id, ctxt_pP->frame,rlc_pP->output_sdu_size_to_write);
+#if LATSEQ
+      //there is 2 cases for pdcp sn lenght. Put the 2 possibilities...
+      // Copied from these functions
+      // pdcp_get_sequence_number_of_pdu_with_short_sn
+      // pdcp_get_sequence_number_of_pdu_with_long_sn
+      //if (rlc_pP->is_data_plane) {
+      uint8_t psn_short = (uint8_t)((unsigned char *)(rlc_pP->output_sdu_in_construction)->data)[0] & 0x7F;
+      uint16_t psn_long = 0x00;
+      psn_long = (uint8_t)((unsigned char *)(rlc_pP->output_sdu_in_construction)->data)[0] & 0x0F;
+      psn_long <<= 8;
+      psn_long |= (uint8_t)((unsigned char *)(rlc_pP->output_sdu_in_construction)->data)[1] & 0xFF;
+      LATSEQ_P("U rlc.unseg.um--pdcp.rx","len%d:rnti%d:drb%d.lcid%d.rsn%d.psn%d.psn%d.fm%d", rlc_pP->output_sdu_size_to_write, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->last_reassemblied_sn, psn_short, psn_long, ctxt_pP->frame);
+      //}
+#endif
       rlc_data_ind (
         ctxt_pP,
         BOOL_NOT(rlc_pP->is_data_plane),
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c
index 932bb1376e..18e6d14379 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c
@@ -32,6 +32,9 @@
 #include "rlc_um.h"
 #include "rlc_primitives.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 void
@@ -253,6 +256,9 @@ rlc_um_segment_10 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP
       }
 
       data_sdu_p = (char *) &(sdu_in_buffer->data[sizeof (struct rlc_um_tx_sdu_management) + sdu_mngt_p->sdu_segmented_size]);
+#if LATSEQ
+      LATSEQ_P("D rlc.tx.um--rlc.seg.um","len%d:rnti%d:drb%d.lcid%d.rsdu%d.rsn%d.rso%d", sdu_mngt_p->sdu_size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, sdu_mngt_p->sdu_size, rlc_pP->vt_us, sdu_mngt_p->sdu_segmented_size);
+#endif
 
       if (sdu_mngt_p->sdu_remaining_size > pdu_remaining_size) {
 #if TRACE_RLC_UM_SEGMENT
@@ -368,6 +374,7 @@ rlc_um_segment_10 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP
 //#if !EXMIMO
 //        assert(1!=1);
 //#endif
+
         memcpy(data, data_sdu_p, sdu_mngt_p->sdu_remaining_size);
         // reduce the size of the PDU
         continue_fill_pdu_with_sdu = 0;
@@ -624,6 +631,7 @@ rlc_um_segment_5 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP)
       fi_first_byte_pdu_is_first_byte_sdu = 1;
     }
 
+    // While a new sdu_in_buffer (input_sdus not empty) or continue_fill_pdu_with_sdu (means we have to continue filling a mac pdu)
     while ((sdu_in_buffer) && (continue_fill_pdu_with_sdu > 0)) {
       sdu_mngt_p = ((struct rlc_um_tx_sdu_management *) (sdu_in_buffer->data));
 
@@ -646,6 +654,12 @@ rlc_um_segment_5 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP)
 
       data_sdu_p = (char*) &(sdu_in_buffer->data[sizeof (struct rlc_um_tx_sdu_management) + sdu_mngt_p->sdu_segmented_size]);
 
+      //LATSEQ : first place for rlc.tx.um--rlc.seg.um
+
+#if LATSEQ
+      LATSEQ_P("D rlc.tx.um--rlc.seg.um","len%d:drb%d.rnti%d.fm%d:lcid%d.rsdu%d.rsn%d.rso%d", sdu_mngt_p->sdu_size, rlc_pP->rb_id, ctxt_pP->rnti, ctxt_pP->frame, rlc_pP->channel_id, sdu_mngt_p->sdu_creation_time, rlc_pP->vt_us, sdu_mngt_p->sdu_segmented_size);
+#endif
+
       if (sdu_mngt_p->sdu_remaining_size > pdu_remaining_size) {
 #if TRACE_RLC_UM_SEGMENT
         LOG_D(RLC, PROTOCOL_RLC_UM_CTXT_FMT" Filling all remaining PDU with %d bytes\n",
diff --git a/openair2/LAYER2/RLC/rlc_mac.c b/openair2/LAYER2/RLC/rlc_mac.c
index 89cbe4c406..0bc507e58d 100644
--- a/openair2/LAYER2/RLC/rlc_mac.c
+++ b/openair2/LAYER2/RLC/rlc_mac.c
@@ -37,7 +37,9 @@
 #include "hashtable.h"
 #include "assertions.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
-
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 //#define DEBUG_MAC_INTERFACE 1
 
 //-----------------------------------------------------------------------------
@@ -74,9 +76,11 @@ struct mac_data_ind mac_rlc_deserialize_tb (
       LOG_T(RLC, "[MAC-RLC] DUMP RX PDU(%d bytes):\n", tb_sizeP);
       rlc_util_print_hex_octets(RLC, ((struct mac_tb_ind *) (tb_p->data))->data_ptr, tb_sizeP);
 #endif
+
       nb_tb_read = nb_tb_read + 1;
       tbs_size   = tbs_size   + tb_sizeP;
       list_add_tail_eurecom(tb_p, &data_ind.data);
+      
     }
 
     num_tbP = num_tbP - 1;
@@ -218,6 +222,7 @@ tbs_size_t mac_rlc_data_req(
     T(T_ENB_RLC_MAC_DL, T_INT(module_idP), T_INT(rntiP), T_INT(channel_idP), T_INT(ret_tb_size));
 
 #endif
+
   VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_MAC_RLC_DATA_REQ,VCD_FUNCTION_OUT);
   return ret_tb_size;
 }
@@ -282,6 +287,11 @@ void mac_rlc_data_ind     (
     rlc_mode = RLC_MODE_NONE;
     //AssertFatal (0 , "%s RLC not configured lcid %u ! (h_rc %d)\n", __FUNCTION__,channel_idP,h_rc);
   }
+/*
+#if LATSEQ
+  LATSEQ_P_TEST("U phy.in.proc--mac.demux", "drb%d.rnti%d.fm%d:lcid%d",&rlc_union_p->rlc.am->rb_id, rntiP, frameP, channel_idP);
+#endif
+*/
 
   struct mac_data_ind data_ind = mac_rlc_deserialize_tb(buffer_pP, tb_sizeP, num_tbP, crcs_pP);
 
diff --git a/openair2/LAYER2/RLC/rlc_rrc.c b/openair2/LAYER2/RLC/rlc_rrc.c
index 4313f379fe..5ba8526b00 100644
--- a/openair2/LAYER2/RLC/rlc_rrc.c
+++ b/openair2/LAYER2/RLC/rlc_rrc.c
@@ -576,7 +576,7 @@ rlc_union_t *rrc_rlc_add_rlc   (
   hash_key_t             key         = HASHTABLE_NOT_A_KEY_VALUE;
   hashtable_rc_t         h_rc;
   hash_key_t             key_lcid    = HASHTABLE_NOT_A_KEY_VALUE;
-  hashtable_rc_t         h_lcid_rc;
+  hashtable_rc_t         h_lcid_rc   = HASH_TABLE_NONE;
   rlc_union_t           *rlc_union_p = NULL;
   rlc_mbms_id_t         *mbms_id_p  = NULL;
   logical_chan_id_t      lcid            = 0;
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity.c b/openair2/LAYER2/rlc_v2/rlc_entity.c
index d774e2b7e1..a1c6c8ee4e 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity.c
+++ b/openair2/LAYER2/rlc_v2/rlc_entity.c
@@ -46,7 +46,9 @@ rlc_entity_t *new_rlc_entity_am(
     int t_poll_retransmit,
     int poll_pdu,
     int poll_byte,
-    int max_retx_threshold)
+    int max_retx_threshold,
+    unsigned int channel_id,
+    int ue_rnti)
 {
   rlc_entity_am_t *ret;
 
@@ -87,6 +89,8 @@ rlc_entity_t *new_rlc_entity_am(
   ret->poll_pdu           = poll_pdu;
   ret->poll_byte          = poll_byte;
   ret->max_retx_threshold = max_retx_threshold;
+  ret->channel_id         = channel_id;
+  ret->ue_rnti            = ue_rnti;
 
   return (rlc_entity_t *)ret;
 }
@@ -98,7 +102,9 @@ rlc_entity_t *new_rlc_entity_um(
                       char *buf, int size),
     void *deliver_sdu_data,
     int t_reordering,
-    int sn_field_length)
+    int sn_field_length,
+    unsigned int channel_id,
+    int ue_rnti)
 {
   rlc_entity_um_t *ret;
 
@@ -129,6 +135,8 @@ rlc_entity_t *new_rlc_entity_um(
   ret->rx_maxsize         = rx_maxsize;
   ret->tx_maxsize         = tx_maxsize;
   ret->t_reordering       = t_reordering;
+  ret->channel_id         = channel_id;
+  ret->ue_rnti            = ue_rnti;
 
   if (sn_field_length == 5)
     ret->sn_modulus = 32;
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity.h b/openair2/LAYER2/rlc_v2/rlc_entity.h
index c9b35204f0..50178b551a 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity.h
+++ b/openair2/LAYER2/rlc_v2/rlc_entity.h
@@ -24,6 +24,8 @@
 
 #include <stdint.h>
 
+#include "platform_types.h"
+
 #define SDU_MAX 16000   /* maximum PDCP SDU size is 8188, let's take more */
 
 typedef struct {
@@ -34,10 +36,10 @@ typedef struct {
 
 typedef struct rlc_entity_t {
   /* functions provided by the RLC module */
-  void (*recv_pdu)(struct rlc_entity_t *entity, char *buffer, int size);
+  void (*recv_pdu)(struct rlc_entity_t *entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
   rlc_entity_buffer_status_t (*buffer_status)(
       struct rlc_entity_t *entity, int maxsize);
-  int (*generate_pdu)(struct rlc_entity_t *entity, char *buffer, int size);
+  int (*generate_pdu)(struct rlc_entity_t *entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 
   void (*recv_sdu)(struct rlc_entity_t *entity, char *buffer, int size,
                    int sdu_id);
@@ -83,7 +85,9 @@ rlc_entity_t *new_rlc_entity_am(
     int t_poll_retransmit,
     int poll_pdu,
     int poll_byte,
-    int max_retx_threshold);
+    int max_retx_threshold,
+    unsigned int channel_id,
+    int ue_rnti);
 
 rlc_entity_t *new_rlc_entity_um(
     int rx_maxsize,
@@ -92,6 +96,8 @@ rlc_entity_t *new_rlc_entity_um(
                       char *buf, int size),
     void *deliver_sdu_data,
     int t_reordering,
-    int sn_field_length);
+    int sn_field_length,
+    unsigned int channel_id,
+    int ue_rnti);
 
 #endif /* _RLC_ENTITY_H_ */
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_am.c b/openair2/LAYER2/rlc_v2/rlc_entity_am.c
index 710f22855e..47d3f915c5 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_am.c
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_am.c
@@ -26,6 +26,9 @@
 #include <string.h>
 
 #include "LOG/log.h"
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 /*************************************************************************/
 /* PDU RX functions                                                      */
@@ -196,6 +199,14 @@ static void rlc_am_reassemble(rlc_entity_am_t *entity)
        */
       if (r->data_pos != r->start->size ||
           (r->fi & 1) == 0) {
+#ifdef LATSEQ
+        uint8_t psn_short = (uint8_t)r->sdu[0] & 0x7F;
+        uint16_t psn_long = 0x00;
+        psn_long = (uint8_t)r->sdu[0] & 0x0F;
+        psn_long <<= 8;
+        psn_long |= (uint8_t)r->sdu[1] & 0xFF;
+        LATSEQ_P("U rlc.reas.am--pdcp.rx", "len%d:rnti%d:drb%d.rsn%d.rso%d.psn%d.psn%d", r->sdu_pos, entity->ue_rnti, entity->channel_id, r->sn, r->so, psn_short, psn_long);
+#endif
         /* SDU is full - deliver to higher layer */
         entity->common.deliver_sdu(entity->common.deliver_sdu_data,
                                    (rlc_entity_t *)entity,
@@ -357,6 +368,9 @@ static void consider_retransmission(rlc_entity_am_t *entity,
    * for the RLC code to keep going with this segment (we only remove
    * a segment that was ACKed)
    */
+#ifdef LATSEQ
+  LATSEQ_P("D rlc.seg.am--rlc.retx.am", "len%d:rnti%d:drb%d.rsn%d.rso%d.rretx%d",cur->data_size, entity->ue_rnti, entity->channel_id, cur->sn, cur->so, cur->retx_count);
+#endif
   entity->retransmit_list = rlc_tx_pdu_list_add(sn_compare_tx, entity,
                                                 entity->retransmit_list, cur);
 }
@@ -569,7 +583,7 @@ static void finalize_ack_nack_processing(rlc_entity_am_t *entity)
   cleanup_sdu_list(entity);
 }
 
-void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
+void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
 #define R(d) do { if (rlc_pdu_decoder_in_error(&d)) goto err; } while (0)
   rlc_entity_am_t *entity = (rlc_entity_am_t *)_entity;
@@ -617,6 +631,10 @@ void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
   e  = rlc_pdu_decoder_get_bits(&decoder, 1); R(decoder);
   sn = rlc_pdu_decoder_get_bits(&decoder, 10); R(decoder);
 
+#ifdef LATSEQ
+  LATSEQ_P("I rlc.rxbuf.am", "occ%d:rnti%d:drb%d", entity->rx_size + size, entity->ue_rnti, entity->channel_id);
+#endif
+
   /* dicard PDU if rx buffer is full */
   if (entity->rx_size + size > entity->rx_maxsize) {
     LOG_D(RLC, "%s:%d:%s: warning: discard PDU, RX buffer full\n",
@@ -638,7 +656,9 @@ void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
     lsf = 1;
     so = 0;
   }
-
+#ifdef LATSEQ
+  LATSEQ_P("U mac.demux--rlc.rx.am", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.rfi%d.fm%d", size, entity->ue_rnti, entity->channel_id, channel_id, sn, so, fi, frame);
+#endif
   packet_count = 1;
 
   /* go to start of data */
@@ -693,6 +713,10 @@ void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
 
   /* put in pdu reception list */
   entity->rx_size += size;
+  //entity->rx_num += 1;
+#ifdef LATSEQ
+  LATSEQ_P("U rlc.rx.am--rlc.reas.am", "len%d:rnti%d:drb%d.rsn%d.rso%d.rfi%d", size, entity->ue_rnti, entity->channel_id, sn, so, fi);
+#endif
   pdu_segment = rlc_rx_new_pdu_segment(sn, so, size, lsf, buffer, data_start);
   entity->rx_list = rlc_rx_pdu_segment_list_add(sn_compare_rx, entity,
                                                 entity->rx_list, pdu_segment);
@@ -1268,6 +1292,9 @@ static int serialize_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize,
     li = sdu->size - sdu_start_byte;
     if (outpos + li >= pdu->data_size)
       li = pdu->data_size - outpos;
+#ifdef LATSEQ
+    LATSEQ_P("D rlc.tx.am--rlc.seg.am", "len%d:rnti%d:drb%d.sdu%d.rsn%d.rfi%d", sdu->size, entity->ue_rnti, entity->channel_id, sdu->sdu_num, pdu->sn, fi);
+#endif
     memcpy(out+outpos, sdu->data + sdu_start_byte, li);
     outpos += li;
     sdu_start_byte = 0;
@@ -1279,7 +1306,7 @@ static int serialize_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize,
   return header_size + pdu->data_size;
 }
 
-static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
+static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize, int *sn, int *so)
 {
   int                  vt_ms;
   tx_pdu_size_t        pdu_size;
@@ -1302,6 +1329,7 @@ static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
   pdu = rlc_tx_new_pdu();
 
   pdu->sn = entity->vt_s;
+  *sn = pdu->sn;
   entity->vt_s = (entity->vt_s + 1) % 1024;
 
   /* go to first SDU (skip those already fully processed) */
@@ -1321,6 +1349,7 @@ static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
    * segment goes to retransmit list)
    */
   pdu->retx_count = -1;
+  *so = pdu->so;
 
   /* reserve SDU bytes */
   cursize = 0;
@@ -1333,6 +1362,9 @@ static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
   }
 
   pdu->data_size = cursize;
+// #ifdef LATSEQ
+//   LATSEQ_P("D rlc.tx.am--rlc.seg.am", "len%d:rnti%d:drb%d.sdu%d.rsn%d.rso%d", cursize, entity->ue_rnti, entity->channel_id, ((rlc_sdu_t*)(pdu->start_sdu))->sdu_num, pdu->sn, pdu->so);
+// #endif
 
   /* put PDU at the end of the wait list */
   entity->wait_list = rlc_tx_pdu_list_append(entity->wait_list, pdu);
@@ -1409,7 +1441,7 @@ static void resegment(rlc_tx_pdu_segment_t *pdu, int size)
   pdu->next = new_pdu;
 }
 
-static int generate_retx_pdu(rlc_entity_am_t *entity, char *buffer, int size)
+static int generate_retx_pdu(rlc_entity_am_t *entity, char *buffer, int size, int *sn, int *so)
 {
   rlc_tx_pdu_segment_t *pdu;
   int orig_size;
@@ -1438,7 +1470,8 @@ static int generate_retx_pdu(rlc_entity_am_t *entity, char *buffer, int size)
     p = 1;
     entity->force_poll = 0;
   }
-
+  *sn = pdu->sn;
+  *so = pdu->so;
   return serialize_pdu(entity, buffer, orig_size, pdu, p);
 }
 
@@ -1502,10 +1535,12 @@ rlc_entity_buffer_status_t rlc_entity_am_buffer_status(
   return ret;
 }
 
-int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
+int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
   rlc_entity_am_t *entity = (rlc_entity_am_t *)_entity;
   int ret;
+  int pdu_sn=0;
+  int pdu_so=0;
 
   if (status_to_report(entity)) {
     ret = generate_status(entity, buffer, size);
@@ -1514,12 +1549,19 @@ int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
   }
 
   if (entity->retransmit_list != NULL) {
-    ret = generate_retx_pdu(entity, buffer, size);
+    ret = generate_retx_pdu(entity, buffer, size, &pdu_sn, &pdu_so);
     if (ret != 0)
+#ifdef LATSEQ
+      LATSEQ_P("D rlc.retx.am--mac.mux", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.fm%d", ret, entity->ue_rnti, entity->channel_id, channel_id, pdu_sn, pdu_so, frame);
+#endif
       return ret;
   }
 
-  return generate_tx_pdu(entity, buffer, size);
+  ret = generate_tx_pdu(entity, buffer, size, &pdu_sn, &pdu_so);
+#ifdef LATSEQ
+  LATSEQ_P("D rlc.seg.am--mac.mux", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.reqfm%d", ret, entity->ue_rnti, entity->channel_id, channel_id, pdu_sn, pdu_so, frame);
+#endif
+  return ret;
 }
 
 /*************************************************************************/
@@ -1541,13 +1583,28 @@ void rlc_entity_am_recv_sdu(rlc_entity_t *_entity, char *buffer, int size,
   if (entity->tx_size + size > entity->tx_maxsize) {
     LOG_D(RLC, "%s:%d:%s: warning: SDU rejected, SDU buffer full\n",
           __FILE__, __LINE__, __FUNCTION__);
+#ifdef LATSEQ
+    uint16_t seqnum = 0x00;
+    seqnum = buffer[0] & 0x0F;
+    seqnum <<= 8;
+    seqnum |= buffer[1] & 0xFF;
+    LATSEQ_P("D pdcp.tx--rlc.drop.am", "len%d:rnti%d:drb%d.psn%d", size, entity->ue_rnti, entity->channel_id, seqnum);
+#endif
     return;
   }
 
   entity->tx_size += size;
-
-  sdu = rlc_new_sdu(buffer, size, sdu_id);
+  entity->tx_num += 1;
+  sdu = rlc_new_sdu(buffer, size, sdu_id, entity->tx_num);
   rlc_sdu_list_add(&entity->tx_list, &entity->tx_end, sdu);
+#ifdef LATSEQ
+  uint16_t seqnum = 0x00;
+  seqnum = buffer[0] & 0x0F;
+  seqnum <<= 8;
+  seqnum |= buffer[1] & 0xFF;
+  LATSEQ_P("D pdcp.tx--rlc.tx.am", "len%d:rnti%d:drb%d.psn%d.sdu%d", size, entity->ue_rnti, entity->channel_id, seqnum, entity->tx_num);
+  LATSEQ_P("I rlc.txbuf.am", "occ%d:rnti%d:drb%d", entity->tx_size, entity->ue_rnti, entity->channel_id);
+#endif
 }
 
 /*************************************************************************/
@@ -1765,6 +1822,7 @@ static void clear_entity(rlc_entity_am_t *entity)
   entity->tx_list = NULL;
   entity->tx_end = NULL;
   entity->tx_size = 0;
+  entity->tx_num = 0;
 
   free_pdu_segment_list(entity->wait_list);
   free_pdu_segment_list(entity->retransmit_list);
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_am.h b/openair2/LAYER2/rlc_v2/rlc_entity_am.h
index 0437f17ad8..9f89ef7d09 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_am.h
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_am.h
@@ -24,6 +24,7 @@
 
 #include <stdint.h>
 
+#include "platform_types.h"
 #include "rlc_entity.h"
 #include "rlc_pdu.h"
 #include "rlc_sdu.h"
@@ -226,6 +227,8 @@ typedef struct {
   int poll_pdu;              /* -1 means infinity */
   int poll_byte;             /* -1 means infinity */
   int max_retx_threshold;
+  unsigned int channel_id;
+  int ue_rnti;
 
   /* runtime rx */
   int vr_r;
@@ -255,6 +258,7 @@ typedef struct {
   rlc_rx_pdu_segment_t *rx_list;
   int                  rx_size;
   int                  rx_maxsize;
+  //int                  rx_num;
 
   /* reassembly management */
   rlc_am_reassemble_t    reassemble;
@@ -264,6 +268,7 @@ typedef struct {
   rlc_sdu_t *tx_end;
   int       tx_size;
   int       tx_maxsize;
+  int       tx_num;
 
   rlc_tx_pdu_segment_t *wait_list;
   rlc_tx_pdu_segment_t *retransmit_list;
@@ -273,10 +278,10 @@ typedef struct {
 
 void rlc_entity_am_recv_sdu(rlc_entity_t *entity, char *buffer, int size,
                             int sdu_id);
-void rlc_entity_am_recv_pdu(rlc_entity_t *entity, char *buffer, int size);
+void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 rlc_entity_buffer_status_t rlc_entity_am_buffer_status(
     rlc_entity_t *entity, int maxsize);
-int rlc_entity_am_generate_pdu(rlc_entity_t *entity, char *buffer, int size);
+int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 void rlc_entity_am_set_time(rlc_entity_t *entity, uint64_t now);
 void rlc_entity_am_discard_sdu(rlc_entity_t *entity, int sdu_id);
 void rlc_entity_am_reestablishment(rlc_entity_t *entity);
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_um.c b/openair2/LAYER2/rlc_v2/rlc_entity_um.c
index 54707875a0..efce33657b 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_um.c
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_um.c
@@ -26,6 +26,9 @@
 #include <string.h>
 
 #include "LOG/log.h"
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 /*************************************************************************/
 /* PDU RX functions                                                      */
@@ -228,7 +231,7 @@ static void rlc_um_reception_actions(rlc_entity_um_t *entity,
   }
 }
 
-void rlc_entity_um_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
+void rlc_entity_um_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
 #define R(d) do { if (rlc_pdu_decoder_in_error(&d)) goto err; } while (0)
   rlc_entity_um_t *entity = (rlc_entity_um_t *)_entity;
@@ -420,7 +423,7 @@ rlc_entity_buffer_status_t rlc_entity_um_buffer_status(
   return ret;
 }
 
-int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
+int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
   rlc_entity_um_t      *entity = (rlc_entity_um_t *)_entity;
   tx_pdu_size_t        pdu_size;
@@ -537,9 +540,11 @@ int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
   }
   if (entity->tx_list == NULL)
     entity->tx_end = NULL;
-
   /* update VT(US) */
   entity->vt_us = (entity->vt_us + 1) % entity->sn_modulus;
+#ifdef LATSEQ
+  LATSEQ_P("D rlc.tx.um--rlc.seg.um", "len%d:rnti%d:drb%d.lcid%d.rtime%d.rsn%d", pdu_size.header_size + pdu_size.data_size, entity->ue_rnti, entity->channel_id , entity->channel_id, entity->t_current, entity->vt_us);
+#endif
 
   return pdu_size.header_size + pdu_size.data_size;
 }
@@ -567,8 +572,9 @@ void rlc_entity_um_recv_sdu(rlc_entity_t *_entity, char *buffer, int size,
   }
 
   entity->tx_size += size;
-
-  sdu = rlc_new_sdu(buffer, size, sdu_id);
+  entity->tx_num += 1;
+// no access to ctxt_pP ???
+  sdu = rlc_new_sdu(buffer, size, sdu_id, entity->tx_num);
   rlc_sdu_list_add(&entity->tx_list, &entity->tx_end, sdu);
 }
 
@@ -689,6 +695,7 @@ static void clear_entity(rlc_entity_um_t *entity)
   entity->tx_list = NULL;
   entity->tx_end = NULL;
   entity->tx_size = 0;
+  entity->tx_num = 0;
 }
 
 void rlc_entity_um_reestablishment(rlc_entity_t *_entity)
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_um.h b/openair2/LAYER2/rlc_v2/rlc_entity_um.h
index 02c5141a7a..8275a20cd3 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_um.h
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_um.h
@@ -22,6 +22,7 @@
 #ifndef _RLC_ENTITY_UM_H_
 #define _RLC_ENTITY_UM_H_
 
+#include "platform_types.h"
 #include "rlc_entity.h"
 #include "rlc_pdu.h"
 #include "rlc_sdu.h"
@@ -43,6 +44,8 @@ typedef struct {
   /* configuration */
   int t_reordering;
   int sn_field_length;
+  unsigned int channel_id;
+  int ue_rnti;
 
   int sn_modulus;        /* 1024 for sn_field_length == 10, 32 for 5 */
   int window_size;       /* 512 for sn_field_length == 10, 16 for 5 */
@@ -74,17 +77,18 @@ typedef struct {
   rlc_sdu_t *tx_end;
   int       tx_size;
   int       tx_maxsize;
+  int       tx_num;
 } rlc_entity_um_t;
 
 void rlc_entity_um_recv_sdu(rlc_entity_t *_entity, char *buffer, int size,
                             int sdu_id);
-void rlc_entity_um_recv_pdu(rlc_entity_t *entity, char *buffer, int size);
+void rlc_entity_um_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 rlc_entity_buffer_status_t rlc_entity_um_buffer_status(
     rlc_entity_t *entity, int maxsize);
-int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size);
+int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 void rlc_entity_um_set_time(rlc_entity_t *entity, uint64_t now);
 void rlc_entity_um_discard_sdu(rlc_entity_t *entity, int sdu_id);
 void rlc_entity_um_reestablishment(rlc_entity_t *entity);
 void rlc_entity_um_delete(rlc_entity_t *entity);
 
-#endif /* _RLC_ENTITY_UM_H_ */
+#endif /* _RLC_ENTITY_UM_H_ */
\ No newline at end of file
diff --git a/openair2/LAYER2/rlc_v2/rlc_oai_api.c b/openair2/LAYER2/rlc_v2/rlc_oai_api.c
index 0cf4b85fa2..63a295cb34 100644
--- a/openair2/LAYER2/rlc_v2/rlc_oai_api.c
+++ b/openair2/LAYER2/rlc_v2/rlc_oai_api.c
@@ -28,6 +28,10 @@
 #include "rlc_ue_manager.h"
 #include "rlc_entity.h"
 
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 #include <stdint.h>
 
 static rlc_ue_manager_t *rlc_ue_manager;
@@ -95,7 +99,7 @@ void mac_rlc_data_ind     (
 
   if (rb != NULL) {
     rb->set_time(rb, rlc_current_time);
-    rb->recv_pdu(rb, buffer_pP, tb_sizeP);
+    rb->recv_pdu(rb, buffer_pP, tb_sizeP, channel_idP, frameP);
   } else {
     LOG_E(RLC, "%s:%d:%s: fatal: no RB found (rnti %d channel ID %d)\n",
           __FILE__, __LINE__, __FUNCTION__, rnti, channel_id);
@@ -127,9 +131,16 @@ tbs_size_t mac_rlc_data_req(
   rlc_manager_lock(rlc_ue_manager);
   ue = rlc_manager_get_ue(rlc_ue_manager, rntiP);
 
+  logical_chan_id_t lcid;
   switch (channel_idP) {
-  case 1 ... 2: rb = ue->srb[channel_idP - 1]; break;
-  case 3 ... 7: rb = ue->drb[channel_idP - 3]; break;
+  case 1 ... 2:
+    lcid = channel_idP - 1;
+    rb = ue->srb[lcid]; 
+    break;
+  case 3 ... 7:
+    lcid = channel_idP - 3;
+    rb = ue->drb[lcid];
+    break;
   default:      rb = NULL;                     break;
   }
 
@@ -144,7 +155,7 @@ tbs_size_t mac_rlc_data_req(
   if (rb != NULL) {
     rb->set_time(rb, rlc_current_time);
     maxsize = tb_sizeP;
-    ret = rb->generate_pdu(rb, buffer_pP, maxsize);
+    ret = rb->generate_pdu(rb, buffer_pP, maxsize, channel_idP, frameP);
   } else {
     LOG_E(RLC, "%s:%d:%s: fatal: data req for unknown RB\n", __FILE__, __LINE__, __FUNCTION__);
     exit(1);
@@ -152,7 +163,6 @@ tbs_size_t mac_rlc_data_req(
   }
 
   rlc_manager_unlock(rlc_ue_manager);
-
   if (enb_flagP)
     T(T_ENB_RLC_MAC_DL, T_INT(module_idP), T_INT(rntiP),
       T_INT(channel_idP), T_INT(ret));
@@ -638,7 +648,8 @@ static void add_srb(int rnti, int module_id, struct LTE_SRB_ToAddMod *s)
                                max_retx_reached, ue,
                                t_reordering, t_status_prohibit,
                                t_poll_retransmit,
-                               poll_pdu, poll_byte, max_retx_threshold);
+                               poll_pdu, poll_byte, max_retx_threshold, srb_id,
+                               rnti);
     rlc_ue_add_srb_rlc_entity(ue, srb_id, rlc_am);
 
     LOG_D(RLC, "%s:%d:%s: added SRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, srb_id, rnti);
@@ -715,7 +726,8 @@ static void add_drb_am(int rnti, int module_id, struct LTE_DRB_ToAddMod *s)
                                max_retx_reached, ue,
                                t_reordering, t_status_prohibit,
                                t_poll_retransmit,
-                               poll_pdu, poll_byte, max_retx_threshold);
+                               poll_pdu, poll_byte, max_retx_threshold, drb_id,
+                               rnti);
     rlc_ue_add_drb_rlc_entity(ue, drb_id, rlc_am);
 
     LOG_D(RLC, "%s:%d:%s: added DRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, drb_id, rnti);
@@ -785,7 +797,9 @@ static void add_drb_um(int rnti, int module_id, struct LTE_DRB_ToAddMod *s)
                                1000000,
                                deliver_sdu, ue,
                                t_reordering,
-                               sn_field_length);
+                               sn_field_length,
+                               drb_id,
+                               rnti);
     rlc_ue_add_drb_rlc_entity(ue, drb_id, rlc_um);
 
     LOG_D(RLC, "%s:%d:%s: added DRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, drb_id, rnti);
@@ -901,8 +915,9 @@ rlc_op_status_t rrc_rlc_config_asn1_req (const protocol_ctxt_t   * const ctxt_pP
                                      1000000,
                                      deliver_sdu, ue,
                                      0,//LTE_T_Reordering_ms0,//t_reordering,
-                                     5//LTE_SN_FieldLength_size5//sn_field_length
-                                    );
+                                     5,//LTE_SN_FieldLength_size5//sn_field_length
+                                     drb_id,
+                                     mbms_rnti);
           rlc_ue_add_drb_rlc_entity(ue, drb_id, rlc_um);
 
           LOG_D(RLC, "%s:%d:%s: added DRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, (int)drb_id, mbms_rnti);
diff --git a/openair2/LAYER2/rlc_v2/rlc_sdu.c b/openair2/LAYER2/rlc_v2/rlc_sdu.c
index 16465a9ff1..05bcc2c6fe 100644
--- a/openair2/LAYER2/rlc_v2/rlc_sdu.c
+++ b/openair2/LAYER2/rlc_v2/rlc_sdu.c
@@ -26,13 +26,14 @@
 
 #include "LOG/log.h"
 
-rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id)
+rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id, int sdu_num)
 {
   rlc_sdu_t *ret = calloc(1, sizeof(rlc_sdu_t));
   if (ret == NULL)
     goto oom;
 
   ret->upper_layer_id = upper_layer_id;
+  ret->sdu_num = sdu_num;
 
   ret->data = malloc(size);
   if (ret->data == NULL)
diff --git a/openair2/LAYER2/rlc_v2/rlc_sdu.h b/openair2/LAYER2/rlc_v2/rlc_sdu.h
index 2c678956ee..e93701741b 100644
--- a/openair2/LAYER2/rlc_v2/rlc_sdu.h
+++ b/openair2/LAYER2/rlc_v2/rlc_sdu.h
@@ -24,6 +24,7 @@
 
 typedef struct rlc_sdu_t {
   int upper_layer_id;
+  int sdu_num;
   char *data;
   int size;
   /* next_byte indicates the starting byte to use to construct a new PDU */
@@ -32,7 +33,7 @@ typedef struct rlc_sdu_t {
   struct rlc_sdu_t *next;
 } rlc_sdu_t;
 
-rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id);
+rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id, int sdu_num);
 void rlc_free_sdu(rlc_sdu_t *sdu);
 void rlc_sdu_list_add(rlc_sdu_t **list, rlc_sdu_t **end, rlc_sdu_t *sdu);
 
diff --git a/openair2/LAYER2/rlc_v2/tests/test.c b/openair2/LAYER2/rlc_v2/tests/test.c
index 734e85f1f5..4469eb0c6c 100644
--- a/openair2/LAYER2/rlc_v2/tests/test.c
+++ b/openair2/LAYER2/rlc_v2/tests/test.c
@@ -213,7 +213,7 @@ int test_main(void)
                                   successful_delivery_enb, NULL,
                                   max_retx_reached_enb, NULL,
                                   test[pos+3], test[pos+4], test[pos+5],
-                                  test[pos+6], test[pos+7], test[pos+8]);
+                                  test[pos+6], test[pos+7], test[pos+8],0,0);
           pos += 9;
           break;
         case UE_AM:
@@ -222,19 +222,19 @@ int test_main(void)
                                  successful_delivery_ue, NULL,
                                  max_retx_reached_ue, NULL,
                                  test[pos+3], test[pos+4], test[pos+5],
-                                 test[pos+6], test[pos+7], test[pos+8]);
+                                 test[pos+6], test[pos+7], test[pos+8],0,0);
           pos += 9;
           break;
         case ENB_UM:
           enb = new_rlc_entity_um(test[pos+1], test[pos+2],
                                   deliver_sdu_enb_um, NULL,
-                                  test[pos+3], test[pos+4]);
+                                  test[pos+3], test[pos+4],0);
           pos += 5;
           break;
         case UE_UM:
           ue = new_rlc_entity_um(test[pos+1], test[pos+2],
                                  deliver_sdu_ue_um, NULL,
-                                 test[pos+3], test[pos+4]);
+                                 test[pos+3], test[pos+4],0);
           pos += 5;
           break;
         case ENB_SDU:
diff --git a/openair2/RRC/LTE/rrc_eNB_S1AP.c b/openair2/RRC/LTE/rrc_eNB_S1AP.c
index 1cb575d1dd..6c993fff22 100644
--- a/openair2/RRC/LTE/rrc_eNB_S1AP.c
+++ b/openair2/RRC/LTE/rrc_eNB_S1AP.c
@@ -77,6 +77,7 @@ static const uint16_t S1AP_ENCRYPTION_EEA2_MASK = 0x4000;
 /* Masks for S1AP Integrity algorithms, EIA0 is always supported (not coded) */
 static const uint16_t S1AP_INTEGRITY_EIA1_MASK = 0x8000;
 static const uint16_t S1AP_INTEGRITY_EIA2_MASK = 0x4000;
+static const uint16_t S1AP_INTEGRITY_EIA3_MASK = 0x2000;
 
 #define INTEGRITY_ALGORITHM_NONE LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia0_v920
 
@@ -416,6 +417,15 @@ static LTE_CipheringAlgorithm_r12_t rrc_eNB_select_ciphering(uint16_t algorithms
  *\return the selected algorithm.
  */
 static e_LTE_SecurityAlgorithmConfig__integrityProtAlgorithm rrc_eNB_select_integrity(uint16_t algorithms) {
+  if (algorithms & S1AP_INTEGRITY_EIA3_MASK) {  // not sure on mask
+    /* TEMPORARY patch to fallback in eia2 instead of unsupported by eNB eia3*/
+    if (algorithms & S1AP_INTEGRITY_EIA2_MASK) {
+      return LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia2;
+    }
+    else {
+      return LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia3_v1130;
+    }
+  }
   if (algorithms & S1AP_INTEGRITY_EIA2_MASK) {
     return LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia2;
   }
diff --git a/openair3/GTPV1-U/gtpv1u_eNB.c b/openair3/GTPV1-U/gtpv1u_eNB.c
index 0fe2741d7b..52c624707b 100644
--- a/openair3/GTPV1-U/gtpv1u_eNB.c
+++ b/openair3/GTPV1-U/gtpv1u_eNB.c
@@ -52,6 +52,10 @@
 #include "gtpv1u_eNB_task.h"
 #include "rrc_eNB_GTPV1U.h"
 #include <common/utils/msc/msc.h>
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 
 #undef GTP_DUMP_SOCKET
 
@@ -145,6 +149,7 @@ static int gtpv1u_eNB_send_init_udp(const Gtpv1uS1Req *req) {
   UDP_INIT(message_p).port = req->enb_port_for_S1u_S12_S4_up;
   addr.s_addr = req->enb_ip_address_for_S1u_S12_S4_up;
   UDP_INIT(message_p).address = inet_ntoa(addr);
+  {const char *s;if ((s=getenv("OAINAT"))) {UDP_INIT(message_p).address=(char *)s;LOG_W(GTPU, "Using OAINAT=%s for GTPU",s);}}
   LOG_I(GTPU, "Tx UDP_INIT IP addr %s (%x)\n", UDP_INIT(message_p).address,UDP_INIT(message_p).port);
   MSC_LOG_EVENT(
     MSC_GTPU_ENB,
@@ -232,6 +237,7 @@ NwGtpv1uRcT gtpv1u_eNB_process_stack_req(
        */
       teid = pUlpApi->apiInfo.recvMsgInfo.teid;
       pMsg = (NwGtpv1uMsgT *) pUlpApi->apiInfo.recvMsgInfo.hMsg;
+      RC.gtpv1u_data_g->tx_seq_num = pMsg->seqNum;
       msgType = pMsg->msgType;
 
       if (NW_GTPV1U_OK != nwGtpv1uMsgGetTpdu(pUlpApi->apiInfo.recvMsgInfo.hMsg,
@@ -419,7 +425,9 @@ NwGtpv1uRcT gtpv1u_eNB_process_stack_req(
             }
           }
         }
-
+#if LATSEQ
+        LATSEQ_P("D gtp.in--pdcp.in.gtp", "len%d:rnti%d:teid%u.drb%d.gsn%d.gso%d.npdu%d", buffer_len, gtpv1u_teid_data_p->ue_id, teid, gtpv1u_teid_data_p->eps_bearer_id - 4, pMsg->seqNum, pMsg->msgBufOffset, pMsg->npduNum);
+#endif
         result = pdcp_data_req(
                    &ctxt,
                    SRB_FLAG_NO,
@@ -1358,6 +1366,10 @@ void *gtpv1u_eNB_process_itti_msg(void *notUsed) {
                           enb_s1u_teid,sgw_s1u_teid,data_req_p->length);
             (void)enb_s1u_teid; /* avoid gcc warning "set but not used" */
           } else {
+#if LATSEQ
+            uint16_t ipid = data_req_p->buffer[data_req_p->offset + 4] << 8 | data_req_p->buffer[data_req_p->offset + 5];
+            LATSEQ_P("U gtp.out--ip.out","len%d:rnti%d:drb%d.psn%d.teid%d.gsn%d.ipid0x%x",data_req_p->length, data_req_p->rnti, data_req_p->rab_id - 4, data_req_p->seqnum, sgw_s1u_teid, RC.gtpv1u_data_g->seq_num, ipid);
+#endif
             rc = nwGtpv1uProcessUlpReq(RC.gtpv1u_data_g->gtpv1u_stack, &stack_req);
 
             if (rc != NW_GTPV1U_OK) {
diff --git a/openair3/GTPV1-U/gtpv1u_eNB_defs.h b/openair3/GTPV1-U/gtpv1u_eNB_defs.h
index 79d9a1dcdd..7d32f7abcf 100644
--- a/openair3/GTPV1-U/gtpv1u_eNB_defs.h
+++ b/openair3/GTPV1-U/gtpv1u_eNB_defs.h
@@ -109,6 +109,7 @@ typedef struct gtpv1u_data_s {
   //udp_data_t            udp_data;
 
   uint16_t              seq_num;
+  uint16_t              tx_seq_num;
   uint8_t               restart_counter;
 
 #ifdef GTPU_IN_KERNEL
diff --git a/openair3/GTPV1-U/gtpv1u_task.c b/openair3/GTPV1-U/gtpv1u_task.c
index 1339839cf9..f199882a54 100644
--- a/openair3/GTPV1-U/gtpv1u_task.c
+++ b/openair3/GTPV1-U/gtpv1u_task.c
@@ -429,6 +429,7 @@ static void *gtpv1u_thread(void *args)
 
     // DATA COMING FROM UDP
     case UDP_DATA_IND: {
+      // TODO: Latses point ip.in--gtp.in
       udp_data_ind_t *udp_data_ind_p;
       udp_data_ind_p = &received_message_p->ittiMsg.udp_data_ind;
       nwGtpv1uProcessUdpReq(gtpv1u_sgw_data.gtpv1u_stack,
diff --git a/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1u.c b/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1u.c
index 0d962cad7d..c5152efc28 100644
--- a/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1u.c
+++ b/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1u.c
@@ -54,6 +54,9 @@
 #include "common/utils/LOG/log.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
 #endif
+//#ifdef LATSEQ
+//  #include "common/utils/LATSEQ/latseq.h"
+//#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -242,7 +245,9 @@ nwGtpv1uCreateAndSendMsg( NwGtpv1uStackT *thiz, uint32_t peerIp, uint16_t peerPo
     *((uint8_t *) msgHdr) = (pMsg->extHdrFlag ? htons(pMsg->nextExtHdrType) : 0x00);
     msgHdr++;
   }
-
+//#if LATSEQ
+//  LATSEQ_P("U gtp.out--ip.out","len%d::teid%d.gsn%d",pMsg->msgBufLen, pMsg->teid, pMsg->seqNum);
+//#endif
   rc = thiz->udp.udpDataReqCallback(thiz->udp.hUdp,
                                     pMsg->msgBuf,
                                     pMsg->msgBufLen,
@@ -571,7 +576,6 @@ nwGtpv1uProcessGpdu( NwGtpv1uStackT *thiz,
         " G-PDU ltid %u size %u",
         tunnelEndPointKey.teid,
         gpduLen);
-
       rc = nwGtpSessionSendMsgApiToUlpEntity(pTunnelEndPoint, pMsg);
     }
   } else {
diff --git a/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1uMsg.c b/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1uMsg.c
index 365d6d23a5..e7de58479d 100644
--- a/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1uMsg.c
+++ b/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1uMsg.c
@@ -48,6 +48,9 @@
 #if defined(ENB_MODE)
 #include "common/utils/LOG/log.h"
 #endif
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #define NW_GTPV1U_EPC_SPECIFIC_HEADER_SIZE                             (12)   /**< Size of GTPv1u EPC specific header */
 #define NW_GTPV1U_EPC_MIN_HEADER_SIZE                                  (8)
@@ -265,6 +268,7 @@ nwGtpv1uMsgFromBufferNew( NW_IN NwGtpv1uStackHandleT hGtpuStackHandle,
     pMsg->msgType       = *(pBuf);
     pBuf++;
 
+    // GPRS message length
     pBuf += 2;
 
     pMsg->teid          = ntohl(*((uint32_t *)pBuf));
@@ -285,6 +289,10 @@ nwGtpv1uMsgFromBufferNew( NW_IN NwGtpv1uStackHandleT hGtpuStackHandle,
                pMsg->msgLen, pMsg->msgBufLen, pMsg->msgBufOffset);
 #endif
     *phMsg = (NwGtpv1uMsgHandleT) pMsg;
+#ifdef LATSEQ
+    uint16_t ipid = pBuf[4] << 8 | pBuf[5];
+    LATSEQ_P("D ip.in--gtp.in", "len%d::ipid0x%x.teid%u.gsn%d.gso%d.npdu%d", pMsg->msgLen, ipid, pMsg->teid, pMsg->seqNum, pMsg->msgBufOffset, pMsg->npduNum);
+#endif
     return NW_GTPV1U_OK;
   }
 
diff --git a/openair3/NAS/UE/EMM/SecurityModeControl.c b/openair3/NAS/UE/EMM/SecurityModeControl.c
index b27270fadc..4ffb238f81 100644
--- a/openair3/NAS/UE/EMM/SecurityModeControl.c
+++ b/openair3/NAS/UE/EMM/SecurityModeControl.c
@@ -164,6 +164,7 @@ int emm_proc_security_mode_command(nas_user_t *user, int native_ksi, int ksi,
   if ( (reea != eea) || (reia != eia) ) {
     LOG_TRACE(WARNING, "EMM-PROC  - Replayed UE security capabilities "
               "rejected");
+    //printf("EMM_CAUSE_UE_SECURITY_MISMATCH : eai = %hhu reia = %hhu\n", eia, reia);
     emm_cause = EMM_CAUSE_UE_SECURITY_MISMATCH;
 
     /* XXX - For testing purpose UE always accepts EIA0
