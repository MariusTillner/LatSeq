diff --git a/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c b/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c
index b5bcb0848d..3dfaee2560 100644
--- a/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c
+++ b/openair1/PHY/LTE_TRANSPORT/dlsch_coding.c
@@ -40,6 +40,9 @@
 #include "SCHED/sched_eNB.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 #include "targets/RT/USER/lte-softmodem.h"
 #include <syscall.h>
 #include "targets/RT/USER/rt_wrapper.h"
@@ -374,8 +377,16 @@ int dlsch_encoding(PHY_VARS_eNB *eNB,
     //    printf("CRC %x (A %d)\n",crc,A);
     hadlsch->B = A+24;
     //    hadlsch->b = a;
+    // LATSEQ
+/*
+#if LATSEQ
+    LATSEQ_P_TEST("D mac.txreq--mac.harq","rnti%d:harq%d.fm%d.subfm%d",dlsch->rnti, harq_pid, frame, subframe);
+#endif
+*/
+
+    // END_LATSEQ
     memcpy(hadlsch->b,a,(A/8)+4);
-    
+
     if (lte_segmentation(hadlsch->b,
                          hadlsch->c,
                          hadlsch->B,
diff --git a/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c b/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c
index ae8c666d18..8b98c043dd 100644
--- a/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c
+++ b/openair1/PHY/LTE_TRANSPORT/ulsch_decoding.c
@@ -43,6 +43,10 @@
 #include "transport_proto.h"
 #include <executables/split_headers.h>
 
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 extern WORKER_CONF_t get_thread_worker_conf(void);
 extern volatile int oai_exit;
 
@@ -357,6 +361,9 @@ int ulsch_decoding_data(PHY_VARS_eNB *eNB, L1_rxtx_proc_t *proc,
     int sz=Kr_bytes - Fbytes - ((ulsch_harq->C>1)?3:0);
     pushTpool(proc->threadPool,req);
     proc->nbDecode++;
+#ifdef LATSEQ
+    LATSEQ_P("U phy.in.proc--mac.harq.up", "len%d::ue%d.cbseg%d.fm%d.subfm%d", sz, rdata->UEid, r, rdata->frame, rdata->subframe);
+#endif
     LOG_D(PHY,"Added a block to decode, in pipe: %d\n",proc->nbDecode);
     r_offset+=E;
     offset+=sz;	    
diff --git a/openair1/SCHED/fapi_l1.c b/openair1/SCHED/fapi_l1.c
index ecfec02193..468216bed0 100644
--- a/openair1/SCHED/fapi_l1.c
+++ b/openair1/SCHED/fapi_l1.c
@@ -37,6 +37,9 @@
 #include "nfapi/oai_integration/vendor_ext.h"
 #include "nfapi_pnf_interface.h"
 #include "fapi_l1.h"
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "common/ran_context.h"
 extern RAN_CONTEXT_t RC;
@@ -231,6 +234,12 @@ void handle_nfapi_dlsch_pdu(PHY_VARS_eNB *eNB,int frame,int subframe,L1_rxtx_pro
     LOG_E(PHY,"illegal harq_pid %d %s:%d\n", harq_pid, __FILE__, __LINE__);
     return;
   }
+#ifdef LATSEQ
+  if (rel8->rnti != 0xFFFF) {
+    uint16_t sfn_sf = (uint16_t)((frame << 4 ) | subframe);
+    LATSEQ_P("D mac.txreq--mac.harq.down", "len%d:rnti%d:txreq%d.harq%d.sfn%d", rel8->length, rel8->rnti, rel8->pdu_index, harq_pid, sfn_sf);
+  }
+#endif
 
   dlsch0_harq     = dlsch0->harq_processes[harq_pid];
   dlsch1_harq     = dlsch1->harq_processes[harq_pid];
diff --git a/openair1/SCHED/phy_procedures_lte_eNb.c b/openair1/SCHED/phy_procedures_lte_eNb.c
index 973c921d23..55705e5bd0 100644
--- a/openair1/SCHED/phy_procedures_lte_eNb.c
+++ b/openair1/SCHED/phy_procedures_lte_eNb.c
@@ -41,6 +41,9 @@
 #include <common/utils/system.h>
 #include "common/utils/LOG/vcd_signal_dumper.h"
 #include <nfapi/oai_integration/nfapi_pnf.h>
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "assertions.h"
 #include "msc.h"
@@ -683,6 +686,13 @@ void phy_procedures_eNB_TX(PHY_VARS_eNB *eNB,
                 dlsch0->harq_ids[frame%2][6],
                 dlsch0->harq_ids[frame%2][7]);
       } else {
+
+#if LATSEQ
+//dci is always 1
+        if(dlsch0->rnti != 0xFFFF)  // Corresponds to a broadcast rnti
+          LATSEQ_P("D mac.harq.down--phy.out.proc","len%d:rnti%d:harq%d.fm%d.subfm%d", dlsch0->harq_processes[harq_pid]->TBS/8,dlsch0->rnti, harq_pid, frame, subframe);
+#endif
+
         if (dlsch_procedures(eNB,
                              proc,
                              harq_pid,
@@ -1317,15 +1327,13 @@ void postDecode(L1_rxtx_proc_t *proc, notifiedFIFO_elt_t *req) {
   bool decodeSucess=rdata->decodeIterations <= rdata->maxIterations;
   ulsch_harq->processedSegments++;
   LOG_D(PHY, "processing result of segment: %d, ue %d, processed %d/%d\n",
-	rdata->segment_r, rdata->UEid, ulsch_harq->processedSegments, rdata->nbSegments);
+    rdata->segment_r, rdata->UEid, ulsch_harq->processedSegments, rdata->nbSegments);
   proc->nbDecode--;
   LOG_D(PHY,"remain to decoded in subframe: %d\n", proc->nbDecode);
-  if (decodeSucess)  {
+  if (decodeSucess) {
     int Fbytes=(rdata->segment_r==0) ? rdata->Fbits>>3 : 0;
     int sz=(rdata->Kr>>3) - Fbytes - ((ulsch_harq->C>1)?3:0);
-    memcpy(ulsch_harq->decodedBytes+rdata->offset,
-	   rdata->decoded_bytes+Fbytes,
-	   sz);
+    memcpy(ulsch_harq->decodedBytes+rdata->offset, rdata->decoded_bytes+Fbytes, sz);
   } else {
     if ( rdata->nbSegments != ulsch_harq->processedSegments ) {
       int nb=abortTpool(proc->threadPool, req->key);
@@ -1333,76 +1341,82 @@ void postDecode(L1_rxtx_proc_t *proc, notifiedFIFO_elt_t *req) {
       proc->nbDecode-=nb;
       LOG_D(PHY,"uplink segment error %d/%d, aborted %d segments\n",rdata->segment_r,rdata->nbSegments, nb);
       AssertFatal(ulsch_harq->processedSegments+nb == rdata->nbSegments,"processed: %d, aborted: %d, total %d\n",
-		  ulsch_harq->processedSegments, nb, rdata->nbSegments);
+      ulsch_harq->processedSegments, nb, rdata->nbSegments);
       ulsch_harq->processedSegments=rdata->nbSegments;
     }
   }
 
   // if this UE segments are all done
   if ( rdata->nbSegments == ulsch_harq->processedSegments) {
-      //compute the expected ULSCH RX power (for the stats)
-      int i=rdata->UEid;
-      ulsch_harq->delta_TF = get_hundred_times_delta_IF_eNB(eNB,i,rdata->harq_pid, 0); // 0 means bw_factor is not considered
-      if (RC.mac != NULL) { /* ulsim does not use RC.mac context. */
-	if (ulsch_harq->cqi_crc_status == 1) {
-	  fill_ulsch_cqi_indication(eNB,rdata->frame,rdata->subframe,ulsch_harq,ulsch->rnti);
-	  RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
-	} else {
-	  if(RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag & (1 << rdata->subframe) ) {
-	    RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
-	    RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_timer=30;
-	    LOG_D(PHY,"Frame %d,Subframe %d, We're supposed to get a cqi here. Set cqi_req_timer to 30.\n",rdata->frame,rdata->subframe);
-	  }
-	}
+    //compute the expected ULSCH RX power (for the stats)
+    int i=rdata->UEid;
+    ulsch_harq->delta_TF = get_hundred_times_delta_IF_eNB(eNB,i,rdata->harq_pid, 0); // 0 means bw_factor is not considered
+    if (RC.mac != NULL) { /* ulsim does not use RC.mac context. */
+      if (ulsch_harq->cqi_crc_status == 1) {
+        fill_ulsch_cqi_indication(eNB,rdata->frame,rdata->subframe,ulsch_harq,ulsch->rnti);
+        RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
+      } else {
+        if(RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag & (1 << rdata->subframe) ) {
+          RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_flag &= (~(1 << rdata->subframe));
+          RC.mac[eNB->Mod_id]->UE_info.UE_sched_ctrl[i].cqi_req_timer=30;
+          LOG_D(PHY,"Frame %d,Subframe %d, We're supposed to get a cqi here. Set cqi_req_timer to 30.\n",rdata->frame,rdata->subframe);
+        }
       }
-	
-      if (!decodeSucess) {
-        T(T_ENB_PHY_ULSCH_UE_NACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti),
-          T_INT(rdata->harq_pid));
-	fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,1); // indicate NAK to MAC
-	fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
-	LOG_D(PHY,"[eNB %d][PUSCH %d] frame %d subframe %d UE %d Error receiving ULSCH, round %d/%d (ACK %d,%d)\n",
-	      eNB->Mod_id,rdata->harq_pid,
-	      rdata->frame,rdata->subframe, i,
-	      ulsch_harq->round,
-	      ulsch->Mlimit,
-	      ulsch_harq->o_ACK[0],
-	      ulsch_harq->o_ACK[1]);
-	  
-	if (ulsch_harq->round >= 3)  {
-	  ulsch_harq->status  = SCH_IDLE;
-	  ulsch_harq->handled = 0;
-	  ulsch->harq_mask   &= ~(1 << rdata->harq_pid);
-	  ulsch_harq->round   = 0;
-	}
-	/* Mark the HARQ process to release it later if max transmission reached
-	 * (see below).
-	 * MAC does not send the max transmission count, we have to deal with it
-	 * locally in PHY.
-	 */
-	ulsch_harq->handled = 1;
-      }  // ulsch in error
-      else if(ulsch_harq->repetition_number == ulsch_harq->total_number_of_repetitions){
-	fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,0); // indicate ACK to MAC
-	fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
-	ulsch_harq->status = SCH_IDLE;
-	ulsch->harq_mask &= ~(1 << rdata->harq_pid);
-	for (int j=0;j<NUMBER_OF_ULSCH_MAX;j++) 
-           if (eNB->ulsch_stats[j].rnti == ulsch->rnti) {
-              eNB->ulsch_stats[j].total_bytes_rx+=ulsch_harq->TBS;
-              for (int aa=0;aa<eNB->frame_parms.nb_antennas_rx;aa++) {
-                eNB->ulsch_stats[j].ulsch_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_power[aa]);
-                eNB->ulsch_stats[j].ulsch_noise_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_noise_power[aa]); 
-              }
-              break;
-           }
-        T (T_ENB_PHY_ULSCH_UE_ACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti),
-           T_INT(rdata->harq_pid));
-      }  // ulsch not in error
-	
-      if (ulsch_harq->O_ACK>0)
-	fill_ulsch_harq_indication(eNB,ulsch_harq,ulsch->rnti,rdata->frame,rdata->subframe,ulsch->bundling);
-  } 
+    }
+
+    if (!decodeSucess) {
+      T(T_ENB_PHY_ULSCH_UE_NACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti), T_INT(rdata->harq_pid));
+#ifdef LATSEQ
+      LATSEQ_P("I mac.harq.up", "nack%d:ue%d:harq%d.fm%d.subfm%d", ulsch_harq->round, rdata->UEid, rdata->harq_pid, rdata->frame, rdata->subframe);
+#endif
+      fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,1); // indicate NAK to MAC
+      fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
+
+      LOG_D(PHY,"[eNB %d][PUSCH %d] frame %d subframe %d UE %d Error receiving ULSCH, round %d/%d (ACK %d,%d)\n",
+            eNB->Mod_id,rdata->harq_pid,
+            rdata->frame,rdata->subframe, i,
+            ulsch_harq->round,
+            ulsch->Mlimit,
+            ulsch_harq->o_ACK[0],
+            ulsch_harq->o_ACK[1]);
+        
+      if (ulsch_harq->round >= 3)  {
+        ulsch_harq->status  = SCH_IDLE;
+        ulsch_harq->handled = 0;
+        ulsch->harq_mask   &= ~(1 << rdata->harq_pid);
+        ulsch_harq->round   = 0;
+      }
+      /* Mark the HARQ process to release it later if max transmission reached
+        * (see below).
+        * MAC does not send the max transmission count, we have to deal with it
+        * locally in PHY.
+        */
+      ulsch_harq->handled = 1;
+    }  // ulsch in error
+    else if(ulsch_harq->repetition_number == ulsch_harq->total_number_of_repetitions) {
+#ifdef LATSEQ
+      LATSEQ_P("I mac.harq.up", "nack%d:ue%d:harq%d.fm%d.subfm%d", 0, rdata->UEid, rdata->harq_pid, rdata->frame, rdata->subframe);
+#endif
+      fill_crc_indication(eNB,i,rdata->frame,rdata->subframe,0); // indicate ACK to MAC
+      fill_rx_indication(eNB,i,rdata->frame,rdata->subframe);  // indicate SDU to MAC
+      ulsch_harq->status = SCH_IDLE;
+      ulsch->harq_mask &= ~(1 << rdata->harq_pid);
+      for (int j=0;j<NUMBER_OF_ULSCH_MAX;j++) {
+        if (eNB->ulsch_stats[j].rnti == ulsch->rnti) {
+          eNB->ulsch_stats[j].total_bytes_rx+=ulsch_harq->TBS;
+          for (int aa=0;aa<eNB->frame_parms.nb_antennas_rx;aa++) {
+            eNB->ulsch_stats[j].ulsch_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_power[aa]);
+            eNB->ulsch_stats[j].ulsch_noise_power[aa] = dB_fixed_x10(eNB->pusch_vars[rdata->UEid]->ulsch_noise_power[aa]); 
+          }
+          break;
+        }
+      }
+      T (T_ENB_PHY_ULSCH_UE_ACK, T_INT(eNB->Mod_id), T_INT(rdata->frame), T_INT(rdata->subframe), T_INT(ulsch->rnti), T_INT(rdata->harq_pid));
+    }  // ulsch not in error
+
+    if (ulsch_harq->O_ACK>0)
+      fill_ulsch_harq_indication(eNB,ulsch_harq,ulsch->rnti,rdata->frame,rdata->subframe,ulsch->bundling);
+  }
 }
 
 void pusch_procedures(PHY_VARS_eNB *eNB,L1_rxtx_proc_t *proc) {
@@ -1498,13 +1512,20 @@ void pusch_procedures(PHY_VARS_eNB *eNB,L1_rxtx_proc_t *proc) {
       ulsch->harq_mask &= ~(1 << harq_pid);
       LOG_W (PHY, "Removing stale ULSCH config for UE %x harq_pid %d (harq_mask is now 0x%2.2x)\n", ulsch->rnti, harq_pid, ulsch->harq_mask);
     }
+/*
+#if LATSEQ
+    LATSEQ_P_TEST("U phy.in.proc--mac.demux","ue%d.rnti%d.fm%d:harq%d.round%d.subfm%d",i, ulsch->rnti, frame, harq_pid, ulsch_harq->round, subframe);
+#endif
+*/
   }   //   for (i=0; i<NUMBER_OF_ULSCH_MAX; i++)
+
   
   while (proc->nbDecode > 0) {
     notifiedFIFO_elt_t *req=pullTpool(proc->respDecode, proc->threadPool);
     postDecode(proc, req);
     delNotifiedFIFO_elt(req);
   }
+
 }
 
 extern int      oai_exit;
diff --git a/openair2/COMMON/gtpv1_u_messages_types.h b/openair2/COMMON/gtpv1_u_messages_types.h
index 75df3253f6..5c0f9a8ff1 100644
--- a/openair2/COMMON/gtpv1_u_messages_types.h
+++ b/openair2/COMMON/gtpv1_u_messages_types.h
@@ -127,6 +127,7 @@ typedef struct gtpv1u_enb_tunnel_data_req_s {
   uint32_t               offset;               ///< start of message offset in buffer
   rnti_t                 rnti;
   rb_id_t                rab_id;
+  uint32_t               seqnum;
 } gtpv1u_enb_tunnel_data_req_t;
 
 typedef struct gtpv1u_enb_data_forwarding_req_s {
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c b/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c
index 596d978a98..c694c218c6 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_dlsch.c
@@ -58,6 +58,9 @@
 #include <dlfcn.h>
 
 #include "T.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #define ENABLE_MAC_PAYLOAD_DEBUG
 //#define DEBUG_eNB_SCHEDULER 1
@@ -753,7 +756,6 @@ schedule_ue_spec(module_id_t module_idP,
                   round_DL,
                   ue_template->oldmcs1[harq_pid]);
           }
-
           dl_req->tl.tag = NFAPI_DL_CONFIG_REQUEST_BODY_TAG;
           eNB->DL_req[CC_id].sfn_sf = frameP<<4 | subframeP;
           eNB->DL_req[CC_id].header.message_id = NFAPI_DL_CONFIG_REQUEST;
@@ -947,6 +949,9 @@ schedule_ue_spec(module_id_t module_idP,
 
         LOG_D(MAC, "dlsch_mcs before and after the rate matching = (%d, %d), TBS %d, nb_rb %d\n",
               eNB_UE_stats->dlsch_mcs1, mcs, TBS, nb_rb);
+#ifdef LATSEQ
+        LATSEQ_P("I mac.sched.down", "mcs%d.tbs%d.nrb%d:rnti%d:lcid%d", eNB_UE_stats->dlsch_mcs1, TBS, nb_rb, rnti, sdu_lcids[0]);
+#endif
 
         int post_padding = TBS - header_length_total - sdu_length_total - ta_len > 2;
         int padding = post_padding ? 0 : TBS - header_length_total - sdu_length_total - ta_len;
@@ -1186,6 +1191,9 @@ schedule_ue_spec(module_id_t module_idP,
                                     dlsch_pdu->payload[0]);
         LOG_D(MAC, "Filled NFAPI configuration for DCI/DLSCH/TXREQ %d, new SDU\n",
               eNB->pdu_index[CC_id]);
+#if LATSEQ
+        LATSEQ_P("D mac.mux--mac.txreq","len%d:rnti%d:lcid%d.txreq%d.reqfm%d.harq%d.sfn%d", TBS, rnti, sdu_lcids[0], eNB->pdu_index[CC_id], frameP, harq_pid, eNB->TX_req[CC_id].sfn_sf);
+#endif
         eNB->pdu_index[CC_id]++;
         program_dlsch_acknak(module_idP,
                              CC_id,
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c b/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c
index e9f0b807c4..67d83e2008 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_fairRR.c
@@ -49,6 +49,9 @@
 #include "rlc.h"
 #include "common/utils/lte/prach_utils.h"
 #include "T.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 
 #ifdef PHY_TX_THREAD
@@ -2066,6 +2069,9 @@ schedule_ue_spec_fairRR(module_id_t module_idP,
                                     0, //number of PRBs treated as one subband, not used here
                                     0 // number of beamforming vectors, not used here
                                    );
+#if LATSEQ
+            LATSEQ_P("D mac.mux--mac.txreq","len%d:rnti%d:lcid%d.txreq%d.reqfm%d.harq%d.sfn%d", TBS, rnti, sdu_lcids[0], eNB->pdu_index[CC_id], frameP, harq_pid, eNB->TX_req[CC_id].sfn_sf);
+#endif
             dl_req->number_pdu++;
             eNB->TX_req[CC_id].sfn_sf = fill_nfapi_tx_req(&eNB->TX_req[CC_id].tx_request_body,
                                         (frameP*10)+subframeP,
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_mch.c b/openair2/LAYER2/MAC/eNB_scheduler_mch.c
index 1272b16ec0..726da282f9 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_mch.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_mch.c
@@ -48,7 +48,7 @@
 #include "pdcp.h"
 #include "assertions.h"
 
-#include "SIMULATION/TOOLS/sim.h"	// for taus
+#include "SIMULATION/TOOLS/sim.h"  // for taus
 
 #define ENABLE_MAC_PAYLOAD_DEBUG
 #define DEBUG_eNB_SCHEDULER 1
@@ -58,27 +58,27 @@ extern RAN_CONTEXT_t RC;
 
 int8_t
 get_mbsfn_sf_alloction(module_id_t module_idP, uint8_t CC_id,
-		       uint8_t mbsfn_sync_area)
+           uint8_t mbsfn_sync_area)
 {
     // currently there is one-to-one mapping between sf allocation pattern and sync area
     if (mbsfn_sync_area > MAX_MBSFN_AREA) {
-	LOG_W(MAC,
-	      "[eNB %d] CC_id %d MBSFN synchronization area %d out of range\n ",
-	      module_idP, CC_id, mbsfn_sync_area);
-	return -1;
+  LOG_W(MAC,
+        "[eNB %d] CC_id %d MBSFN synchronization area %d out of range\n ",
+        module_idP, CC_id, mbsfn_sync_area);
+  return -1;
     }else if (RC.mac[module_idP]->
-	       common_channels[CC_id].non_mbsfn_SubframeConfig
-	       != NULL) {
-	return mbsfn_sync_area;
+         common_channels[CC_id].non_mbsfn_SubframeConfig
+         != NULL) {
+  return mbsfn_sync_area;
     }else if (RC.mac[module_idP]->
-	       common_channels[CC_id].mbsfn_SubframeConfig[mbsfn_sync_area]
-	       != NULL) {
-	return mbsfn_sync_area;
+         common_channels[CC_id].mbsfn_SubframeConfig[mbsfn_sync_area]
+         != NULL) {
+  return mbsfn_sync_area;
     } else {
-	LOG_W(MAC,
-	      "[eNB %d] CC_id %d MBSFN Subframe Config pattern %d not found \n ",
-	      module_idP, CC_id, mbsfn_sync_area);
-	return -1;
+  LOG_W(MAC,
+        "[eNB %d] CC_id %d MBSFN Subframe Config pattern %d not found \n ",
+        module_idP, CC_id, mbsfn_sync_area);
+  return -1;
     }
 }
 
@@ -92,14 +92,14 @@ static uint32_t msi_sfs=0;
 
 static int check_CAS_sf(frame_t frameP,sub_frame_t subframeP){
    if( ((frameP&3)==0) && (subframeP == 0))
-	return 1;	
+  return 1;  
    else 
-   	return 0;
+     return 0;
 }
 static int check_nonMBSFN_sf(frame_t frameP,COMMON_channels_t *cc,int sf){
-   uint32_t non_mbsfn_SubframeConfig = (cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]<<1 | cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]>>7);	
+   uint32_t non_mbsfn_SubframeConfig = (cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]<<1 | cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]>>7);  
    if( frameP % (4<<cc->non_mbsfn_SubframeConfig->radioFrameAllocationPeriod_r14) == cc->non_mbsfn_SubframeConfig->radioFrameAllocationOffset_r14 ){
-	return (non_mbsfn_SubframeConfig & (0x200>>(sf)))==(0x200 >> (sf));
+  return (non_mbsfn_SubframeConfig & (0x200>>(sf)))==(0x200 >> (sf));
    }
    return 0;
 }
@@ -110,29 +110,29 @@ static int mbms_mch_i=0;
 
 int
 schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
-	      sub_frame_t subframeP)
+        sub_frame_t subframeP)
 {
 
     nfapi_dl_config_request_body_t *dl_req;
     //nfapi_dl_config_request_pdu_t *dl_config_pdu;
     
     int mcch_flag = 0, mtch_flag = 0, msi_flag = 0;
-    int mbsfn_period = 0;	// 1<<(RC.mac[module_idP]->mbsfn_SubframeConfig[0]->radioframeAllocationPeriod);
-    int mcch_period = 0;	//32<<(RC.mac[module_idP]->mbsfn_AreaInfo[0]->mcch_Config_r9.mcch_RepetitionPeriod_r9);
+    int mbsfn_period = 0;  // 1<<(RC.mac[module_idP]->mbsfn_SubframeConfig[0]->radioframeAllocationPeriod);
+    int mcch_period = 0;  //32<<(RC.mac[module_idP]->mbsfn_AreaInfo[0]->mcch_Config_r9.mcch_RepetitionPeriod_r9);
     //TOCHECK mtch index here
     if(RC.mac[module_idP]->common_channels[CC_id].
               pmch_Config[0] == NULL )
-	return 0;
+  return 0;
 
     //TOCHECK mtch index here
     int mch_scheduling_period =
-	8 << (RC.mac[module_idP]->common_channels[CC_id].
-	      pmch_Config[0]->mch_SchedulingPeriod_r9);
+  8 << (RC.mac[module_idP]->common_channels[CC_id].
+        pmch_Config[0]->mch_SchedulingPeriod_r9);
 
     unsigned char mcch_sdu_length;
     unsigned char header_len_mcch = 0, header_len_msi =
-	0, header_len_mtch = 0, header_len_mtch_temp =
-	0, header_len_mcch_temp = 0, header_len_msi_temp = 0;
+  0, header_len_mtch = 0, header_len_mtch_temp =
+  0, header_len_mcch_temp = 0, header_len_msi_temp = 0;
     int ii = 0, msi_pos = -1;
     int mcch_mcs = -1;
     int shifted_sf = 0;
@@ -143,23 +143,23 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
 
     unsigned char sdu_lcids[11], num_sdus = 0, offset = 0;
     uint16_t sdu_lengths[11], sdu_length_total = 0;
-    unsigned char mch_buffer[MAX_DLSCH_PAYLOAD_BYTES];	// check the max value, this is for dlsch only
+    unsigned char mch_buffer[MAX_DLSCH_PAYLOAD_BYTES];  // check the max value, this is for dlsch only
 
     COMMON_channels_t *cc = &RC.mac[module_idP]->common_channels[CC_id];
 
     cc->MCH_pdu.Pdu_size = 0;
 
     for (i = 0; i < cc->num_active_mbsfn_area; i++) {
-	// assume, that there is always a mapping
-	if ((j = get_mbsfn_sf_alloction(module_idP, CC_id, i)) == -1) {
-	    return 0;
-	}
+  // assume, that there is always a mapping
+  if ((j = get_mbsfn_sf_alloction(module_idP, CC_id, i)) == -1) {
+      return 0;
+  }
 
         if(cc->non_mbsfn_SubframeConfig){
             int alloc_offset=0;
             uint32_t period;
 
-            uint32_t non_mbsfn_SubframeConfig = (cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]<<1 | cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]>>7);	
+            uint32_t non_mbsfn_SubframeConfig = (cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]<<1 | cc->non_mbsfn_SubframeConfig->subframeAllocation_r14.buf[0]>>7);  
             long mcch_offset        = cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9;
 
             period = 4<<cc->non_mbsfn_SubframeConfig->radioFrameAllocationPeriod_r14;
@@ -168,77 +168,63 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
          
             // get the real MCS value
             switch (cc->mbsfn_AreaInfo[i]->mcch_Config_r9.signallingMCS_r9) {
-        	case 0:
-          	mcch_mcs = 2;
-          	break;
+          case 0:
+            mcch_mcs = 2;
+            break;
 
-        	case 1:
-          	mcch_mcs = 7;
-          	break;
+          case 1:
+            mcch_mcs = 7;
+            break;
 
-        	case 2:
-          	mcch_mcs = 13;
-          	break;
+          case 2:
+            mcch_mcs = 13;
+            break;
 
-        	case 3:
-          	mcch_mcs = 19;
-          	break;
+          case 3:
+            mcch_mcs = 19;
+            break;
             }
-	   	  
+         
             if (cc->pmch_Config[0]) {
-        		mch_scheduling_period = 8 << cc->pmch_Config[0]->mch_SchedulingPeriod_r9;
+            mch_scheduling_period = 8 << cc->pmch_Config[0]->mch_SchedulingPeriod_r9;
             }
 
            LOG_D(MAC,"frameP %d subframe %d period %d alloc_offset %d mcch_mcs %d mcch_period %d mcch_offset %ld buf %x mch_scheduling_period %d\n",frameP, subframeP, period, alloc_offset,mcch_mcs, mcch_period, mcch_offset,(cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0]),mch_scheduling_period);
-	//if( (frameP % (4 << cc->commonSF_AllocPeriod_r9) ) == 0 ){
-	//	   if((subframeP==0)){
-	//	   	x=0;
-	//	   	mbms_mch_i=0;
-	//	   }
-	//}
-            //if (frameP % (4 << cc->commonSF_AllocPeriod_r9 ) == 0) {
-	    //       if((subframeP==0)){
-	    //       	x=0;
-	    //       	mbms_mch_i=0;
-	    //       }
-	    //}
             if (cc->pmch_Config[0]) {
               //  Find the first subframe in this MCH to transmit MSI
               if (frameP % 1 == 0) {
                 if (frameP % mch_scheduling_period == 0) {
-		   msi_pos=0;
-		   if((frameP&3)==0)
-			msi_pos++;
-		   while((non_mbsfn_SubframeConfig & (0x100 >> msi_pos)) == (0x100>>msi_pos))
-			msi_pos++;
-		   mbms_mch_i=0;
-
-		   if((subframeP==0)){
-		   	x=0;
-		   	mbms_mch_i=0;
-		   }
-		 
-		}
+                  msi_pos=0;
+                  if((frameP&3)==0)
+                    msi_pos++;
+                  while((non_mbsfn_SubframeConfig & (0x100 >> msi_pos)) == (0x100>>msi_pos))
+                    msi_pos++;
+                  mbms_mch_i=0;
+
+                  if((subframeP==0)){
+                    x=0;
+                    mbms_mch_i=0;
+                  }
+                }
               }
             }
-
-	    if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9+shifted_sf){
-
-			shifted_sf = check_nonMBSFN_sf(frameP,cc,subframeP)+check_CAS_sf(frameP,subframeP);
-			msi_pos=subframeP+shifted_sf;
-			if(shifted_sf==0)
-				mbms_mch_i++;
-			LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d shifted_sf %d\n",frameP, subframeP, msi_pos,mbms_mch_i,shifted_sf);
-		}
-	    }
+      if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+    if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9+shifted_sf){
+
+      shifted_sf = check_nonMBSFN_sf(frameP,cc,subframeP)+check_CAS_sf(frameP,subframeP);
+      msi_pos=subframeP+shifted_sf;
+      if(shifted_sf==0)
+        mbms_mch_i++;
+      LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d shifted_sf %d\n",frameP, subframeP, msi_pos,mbms_mch_i,shifted_sf);
+    }
+      }
 
             // Check if the subframe is for MSI, MCCH or MTCHs and Set the correspoding flag to 1
             switch (subframeP) {
               case 0: 
-          	    if (msi_pos == 0) {
-            	      msi_flag = 1;
-          	    }
+                if (msi_pos == 0) {
+                    msi_flag = 1;
+                }
                       mtch_flag = 1;
                 break;
               case 1:
@@ -331,7 +317,7 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
                               msi_flag, mcch_flag, mtch_flag);
             }
 
-	    //TODO quitar la subframe 0 del otro switch ... está mal interpretado ? 
+      //TODO quitar la subframe 0 del otro switch ... está mal interpretado ? 
            // if((frameP&3) == 0){
            //            mtch_flag=0;mcch_flag=0;msi_flag=0;
            // }
@@ -344,73 +330,73 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
                     }
                   break;
                   case 1:{
-                  	if ((non_mbsfn_SubframeConfig & 0x100) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x100) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 2:{
-                  	if ((non_mbsfn_SubframeConfig & 0x80) > 0)
-                  	   {mtch_flag=0;mcch_flag=0;msi_flag=0;}
+                    if ((non_mbsfn_SubframeConfig & 0x80) > 0)
+                       {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 3:{
-                  	if ((non_mbsfn_SubframeConfig & 0x40) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x40) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 4:{
-                  	if ((non_mbsfn_SubframeConfig & 0x20) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x20) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 5:{
-                  	if ((non_mbsfn_SubframeConfig & 0x10) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x10) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 6:{
-                  	if ((non_mbsfn_SubframeConfig & 0x8) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x8) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 7:{
-                  	if ((non_mbsfn_SubframeConfig & 0x4) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x4) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 8:{
-                  	if ((non_mbsfn_SubframeConfig & 0x2) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x2) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                     }
                   break;
                   case 9:{
-                  	if ((non_mbsfn_SubframeConfig & 0x1) > 0)
+                    if ((non_mbsfn_SubframeConfig & 0x1) > 0)
                        {mtch_flag=0;mcch_flag=0;msi_flag=0;}
                   }
                   break;
                }
             }
-	    // sf allocation is non-overlapping
+      // sf allocation is non-overlapping
             if ((msi_flag == 1) || (mcch_flag == 1) || (mtch_flag == 1)) {
-		  x++;
-		  //if( (msi_flag!=1 && mcch_flag!=1) || (msi_flag!=1 && mcch_flag!=1 && mtch_flag!=1)  ){
-		        	//x++;
-		  //}
-		 	
-		  if(msi_flag==1){
-		  	if ( (/*AJ*/ (/*V*/ ( /*U*/ (frameP %( 4 << cc->commonSF_AllocPeriod_r9)) ) / 8 ) % ((8 << cc->pmch_Config[mbms_mch_i]->mch_SchedulingPeriod_r9) / 8 ) ) != 0 ){
-				msi_flag=0;
-				LOG_D(MAC,"frameP %d subframeP %d reset(%d)\n",frameP, subframeP, mbms_mch_i);
-			}
-	        
-		  }
-
-	          LOG_D(MAC,"[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d, x %d\n",
+      x++;
+      //if( (msi_flag!=1 && mcch_flag!=1) || (msi_flag!=1 && mcch_flag!=1 && mtch_flag!=1)  ){
+              //x++;
+      //}
+       
+      if(msi_flag==1){
+        if ( (/*AJ*/ (/*V*/ ( /*U*/ (frameP %( 4 << cc->commonSF_AllocPeriod_r9)) ) / 8 ) % ((8 << cc->pmch_Config[mbms_mch_i]->mch_SchedulingPeriod_r9) / 8 ) ) != 0 ){
+        msi_flag=0;
+        LOG_D(MAC,"frameP %d subframeP %d reset(%d)\n",frameP, subframeP, mbms_mch_i);
+      }
+          
+      }
+
+            LOG_D(MAC,"[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d, x %d\n",
                   module_idP, CC_id, frameP, subframeP, i, j,
                    msi_flag, mcch_flag, mtch_flag,x);
                   break;
             }
-	   
+     
 
         }else if(cc->mbsfn_SubframeConfig[j]){
 
@@ -418,7 +404,7 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
                 1 << (cc->mbsfn_SubframeConfig[j]->radioframeAllocationPeriod);
             mcch_period =
                 32 << (cc->mbsfn_AreaInfo[i]->
-            	   mcch_Config_r9.mcch_RepetitionPeriod_r9);
+                 mcch_Config_r9.mcch_RepetitionPeriod_r9);
             msi_pos = 0;
             ii = 0;
             LOG_D(MAC, "[eNB %d] CC_id %d Frame %d subframeP %d : Checking MBSFN Sync Area %d/%d with SF allocation %d/%d for MCCH and MTCH (mbsfn period %d, mcch period %d)\n",
@@ -445,241 +431,241 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
             }
 
             // 1st: Check the MBSFN subframes from SIB2 info (SF allocation pattern i, max 8 non-overlapping patterns exist)
-            if (frameP % mbsfn_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {	// MBSFN frameP
-                if (cc->mbsfn_SubframeConfig[j]->subframeAllocation.present == LTE_MBSFN_SubframeConfig__subframeAllocation_PR_oneFrame) {	// one-frameP format
-            	     //  Find the first subframeP in this MCH to transmit MSI
-            	     if (frameP % mch_scheduling_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {
-            	         while (ii == 0) {
-            	     	ii = cc->
-            	     	    mbsfn_SubframeConfig[j]->subframeAllocation.
-            	     	    choice.oneFrame.buf[0] & (0x80 >> msi_pos);
-            	     	msi_pos++;
-            	         }
-            	         LOG_D(MAC, "[eNB %d] CC_id %d Frame %d subframeP %d : sync area %d sf allocation pattern %d sf alloc %x msi pos is %d \n",
-            	     	  module_idP, CC_id, frameP, subframeP, i, j,
-            	     	  cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0],
-            	     	  msi_pos);
-	 	         if((subframeP==1)){
-		        	x=0;
-		        	mbms_mch_i=0;
-	      	     	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		         }
-            	     }
-	       
-            	     // Check if the subframeP is for MSI, MCCH or MTCHs and Set the correspoding flag to 1
-            	     switch (subframeP) {
-            	     case 1:
-            	         if (cc->tdd_Config == NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF1) == MBSFN_FDD_SF1) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=1;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-            	     	    if (msi_pos == 1) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ( (frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&& ( (cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF1) == MBSFN_FDD_SF1) ) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 2:
-            	         if (cc->tdd_Config == NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF2) ==  MBSFN_FDD_SF2) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=2;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-
-            	     	    if (msi_pos == 2) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ( (frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&& ((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF2) ==  MBSFN_FDD_SF2)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 3:
-            	         if (cc->tdd_Config != NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF3) ==  MBSFN_TDD_SF3) {
-            	     	    if (msi_pos == 1) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF3) ==  MBSFN_TDD_SF3)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         } else {	// FDD
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF3) ==  MBSFN_FDD_SF3) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=3;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-            	     	    if (msi_pos == 3) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF3) == MBSFN_FDD_SF3)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 4:
-            	         if (cc->tdd_Config != NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF4) == MBSFN_TDD_SF4) {
-            	     	    if (msi_pos == 2) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF4) == MBSFN_TDD_SF4)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 6:
-            	         if (cc->tdd_Config == NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF6) ==  MBSFN_FDD_SF6) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=4;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-            	     	    if (msi_pos == 4) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF6) ==  MBSFN_FDD_SF6)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 7:
-            	         if (cc->tdd_Config != NULL) {	// TDD
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF7) == MBSFN_TDD_SF7) {
-            	     	    if (msi_pos == 3) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF7) ==  MBSFN_TDD_SF7)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         } else {	// FDD
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF7) == MBSFN_FDD_SF7) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=5;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-
-            	     	    if (msi_pos == 5) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF7) == MBSFN_FDD_SF7)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 8:
-            	         if (cc->tdd_Config != NULL) {	//TDD
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF8) == MBSFN_TDD_SF8) {
-            	     	    if (msi_pos == 4) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF8) == MBSFN_TDD_SF8)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         } else {	// FDD
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF8) ==  MBSFN_FDD_SF8) {
-   		     	   if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
-		     	      if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
-		     	 	msi_pos=6;
-		     	 	mbms_mch_i++;
-		     	 	LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
-		     	      }
-		     	    }
-            	     	    if (msi_pos == 6) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF8) == MBSFN_FDD_SF8)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     case 9:
-            	         if (cc->tdd_Config != NULL) {
-            	     	if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF9) ==  MBSFN_TDD_SF9) {
-            	     	    if (msi_pos == 5) {
-            	     		msi_flag = 1;
-            	     	    }
-            	     	    if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
-            	     		&&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF9) == MBSFN_TDD_SF9)) {
-            	     		mcch_flag = 1;
-            	     	    }
-            	     	    mtch_flag = 1;
-            	     	}
-            	         }
-            	         break;
-            	     }	// end switch
-            	     // sf allocation is non-overlapping
-            	     if ((msi_flag == 1) || (mcch_flag == 1) || (mtch_flag == 1)) {
-		     	  x++;
-		         //if( (msi_flag!=1 && mcch_flag!=1) || (msi_flag!=1 && mcch_flag!=1 && mtch_flag!=1)  ){
-		     		//x++;
-		         //}
-			  if(msi_flag==1){
-			  	if ( (/*AJ*/ (/*V*/ ( /*U*/ (frameP %( 4 << cc->commonSF_AllocPeriod_r9)) ) / 8 ) % ((8 << cc->pmch_Config[mbms_mch_i]->mch_SchedulingPeriod_r9) / 8 ) ) != 0 ){
-					msi_flag=0;
-					LOG_D(MAC,"frameP %d subframeP %d reset(%d)\n",frameP, subframeP, mbms_mch_i);
-				}
-		        
-			  }
-
-            	         LOG_D(MAC,"[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d x %d\n",
-            	     	  module_idP, CC_id, frameP, subframeP, i, j,
-            	     	  msi_flag, mcch_flag, mtch_flag,x);
-            	         break;
-            	     }
+            if (frameP % mbsfn_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {  // MBSFN frameP
+                if (cc->mbsfn_SubframeConfig[j]->subframeAllocation.present == LTE_MBSFN_SubframeConfig__subframeAllocation_PR_oneFrame) {  // one-frameP format
+                   //  Find the first subframeP in this MCH to transmit MSI
+                   if (frameP % mch_scheduling_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {
+                       while (ii == 0) {
+                     ii = cc->
+                         mbsfn_SubframeConfig[j]->subframeAllocation.
+                         choice.oneFrame.buf[0] & (0x80 >> msi_pos);
+                     msi_pos++;
+                       }
+                       LOG_D(MAC, "[eNB %d] CC_id %d Frame %d subframeP %d : sync area %d sf allocation pattern %d sf alloc %x msi pos is %d \n",
+                       module_idP, CC_id, frameP, subframeP, i, j,
+                       cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0],
+                       msi_pos);
+              if((subframeP==1)){
+              x=0;
+              mbms_mch_i=0;
+                 LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+             }
+                   }
+         
+                   // Check if the subframeP is for MSI, MCCH or MTCHs and Set the correspoding flag to 1
+                   switch (subframeP) {
+                   case 1:
+                       if (cc->tdd_Config == NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF1) == MBSFN_FDD_SF1) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=1;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+                         if (msi_pos == 1) {
+                       msi_flag = 1;
+                         }
+                         if ( (frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       && ( (cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF1) == MBSFN_FDD_SF1) ) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 2:
+                       if (cc->tdd_Config == NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF2) ==  MBSFN_FDD_SF2) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=2;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+
+                         if (msi_pos == 2) {
+                       msi_flag = 1;
+                         }
+                         if ( (frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       && ((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF2) ==  MBSFN_FDD_SF2)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 3:
+                       if (cc->tdd_Config != NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF3) ==  MBSFN_TDD_SF3) {
+                         if (msi_pos == 1) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF3) ==  MBSFN_TDD_SF3)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       } else {  // FDD
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF3) ==  MBSFN_FDD_SF3) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=3;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+                         if (msi_pos == 3) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF3) == MBSFN_FDD_SF3)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 4:
+                       if (cc->tdd_Config != NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF4) == MBSFN_TDD_SF4) {
+                         if (msi_pos == 2) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF4) == MBSFN_TDD_SF4)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 6:
+                       if (cc->tdd_Config == NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF6) ==  MBSFN_FDD_SF6) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=4;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+                         if (msi_pos == 4) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF6) ==  MBSFN_FDD_SF6)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 7:
+                       if (cc->tdd_Config != NULL) {  // TDD
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF7) == MBSFN_TDD_SF7) {
+                         if (msi_pos == 3) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF7) ==  MBSFN_TDD_SF7)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       } else {  // FDD
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF7) == MBSFN_FDD_SF7) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=5;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+
+                         if (msi_pos == 5) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF7) == MBSFN_FDD_SF7)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 8:
+                       if (cc->tdd_Config != NULL) {  //TDD
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF8) == MBSFN_TDD_SF8) {
+                         if (msi_pos == 4) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF8) == MBSFN_TDD_SF8)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       } else {  // FDD
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_FDD_SF8) ==  MBSFN_FDD_SF8) {
+                 if(cc->pmch_Config[mbms_mch_i+1]!=NULL){
+                 if( x == cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9){
+              msi_pos=6;
+              mbms_mch_i++;
+              LOG_D(MAC,"MSP, frameP %d subframeP %d msi_pos(%d) mbms_mch_i %d\n",frameP, subframeP, msi_pos,mbms_mch_i);
+                 }
+               }
+                         if (msi_pos == 6) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_FDD_SF8) == MBSFN_FDD_SF8)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   case 9:
+                       if (cc->tdd_Config != NULL) {
+                     if ((cc->mbsfn_SubframeConfig[j]->subframeAllocation.choice.oneFrame.buf[0] & MBSFN_TDD_SF9) ==  MBSFN_TDD_SF9) {
+                         if (msi_pos == 5) {
+                       msi_flag = 1;
+                         }
+                         if ((frameP % mcch_period == cc->mbsfn_AreaInfo[i]->mcch_Config_r9.mcch_Offset_r9)
+                       &&((cc->mbsfn_AreaInfo[i]->mcch_Config_r9.sf_AllocInfo_r9.buf[0] & MBSFN_TDD_SF9) == MBSFN_TDD_SF9)) {
+                       mcch_flag = 1;
+                         }
+                         mtch_flag = 1;
+                     }
+                       }
+                       break;
+                   }  // end switch
+                   // sf allocation is non-overlapping
+                   if ((msi_flag == 1) || (mcch_flag == 1) || (mtch_flag == 1)) {
+             x++;
+             //if( (msi_flag!=1 && mcch_flag!=1) || (msi_flag!=1 && mcch_flag!=1 && mtch_flag!=1)  ){
+             //x++;
+             //}
+        if(msi_flag==1){
+          if ( (/*AJ*/ (/*V*/ ( /*U*/ (frameP %( 4 << cc->commonSF_AllocPeriod_r9)) ) / 8 ) % ((8 << cc->pmch_Config[mbms_mch_i]->mch_SchedulingPeriod_r9) / 8 ) ) != 0 ){
+          msi_flag=0;
+          LOG_D(MAC,"frameP %d subframeP %d reset(%d)\n",frameP, subframeP, mbms_mch_i);
+        }
+            
+        }
+
+                       LOG_D(MAC,"[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d x %d\n",
+                       module_idP, CC_id, frameP, subframeP, i, j,
+                       msi_flag, mcch_flag, mtch_flag,x);
+                       break;
+                   }
                 } else {// four-frameP format
-			 printf("Hola\n");
-			 AssertFatal(1==0,"four-frameP format: not implemented yet\n");
+       printf("Hola\n");
+       AssertFatal(1==0,"four-frameP format: not implemented yet\n");
                 }
             }
         } // MBMS format
@@ -691,9 +677,9 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
 
     // Calculate the mcs
     if ((msi_flag == 1) || (mcch_flag == 1)) {
-	cc->MCH_pdu.mcs = mcch_mcs;
-    } else if (mtch_flag == 1) {	// only MTCH in this subframeP
-	cc->MCH_pdu.mcs = cc->pmch_Config[mbms_mch_i]->dataMCS_r9;
+  cc->MCH_pdu.mcs = mcch_mcs;
+    } else if (mtch_flag == 1) {  // only MTCH in this subframeP
+  cc->MCH_pdu.mcs = cc->pmch_Config[mbms_mch_i]->dataMCS_r9;
     }
 
 
@@ -709,400 +695,400 @@ schedule_MBMS_NFAPI(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
     // MSI buffer pointer
     char *buffer_pointer=NULL;
     if (msi_flag == 1) {
-	// Create MSI here
-	msi_ptr = &msi_control_element[0];
-
-	//Header for MTCHs
-	num_mtch = cc->mbms_SessionList[mbms_mch_i]->list.count;
-
-    	TBS =
-	get_TBS_DL(cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
-	//l=0;
-
-	for (k = 0; k < num_mtch; k++) {	// loop for all session in this MCH (MCH[0]) at this moment
-
-	    ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[mbms_mch_i]->list.array[k]->logicalChannelIdentity_r9;	//mtch_lcid;
-
-	    if( msi_sfs != 0 )
-	    	msi_pmch_stop = msi_sfs-1;
-	    else 
-		msi_pmch_stop = msi_sfs;
-	
-    	    msi_pmch_stop = msi_sfs;
-
-	    if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
-	        ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = (((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) >> 8) & 0x7f);
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = ((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) & 0xff);
-		msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
-	    }else{
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;	// last subframeP of this mtch (only one mtch now)
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
-		msi_pmch_stop=0;
-	    }
-	    msi_ptr += sizeof(MSI_ELEMENT);
-	}
-
-	msi_length = msi_ptr - msi_control_element;
-
-	if (msi_length < 128) {
-	    header_len_msi = 2;
-	} else {
-	    header_len_msi = 3;
-	}
-
-	LOG_D(MAC, "[eNB %d] CC_id %d Frame %d : MSI->MCH, length of MSI is %d bytes TBS %d, bytes in buffer %d stop_sf_LSB %d msi_sfs %d cc->pmch_Config[0]->sf_AllocEnd_r9 %ld\n",
-	      module_idP, CC_id, frameP, msi_length,TBS, bytes_in_buffer,msi_pmch_stop,msi_sfs,cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
-	    
-	msi_sfs = 0;
-
-	// Store MSI data to mch_buffer[0]
-	memcpy((char *) &mch_buffer[sdu_length_total],
-	       msi_control_element, msi_length);
-
-	buffer_pointer = (char *) &mch_buffer[sdu_length_total];
-
-	sdu_lcids[num_sdus] = MCH_SCHDL_INFO;
-	sdu_lengths[num_sdus] = msi_length;
-	sdu_length_total += sdu_lengths[num_sdus];
-	LOG_D(MAC, "[eNB %d] CC_id %d Create %d bytes for MSI\n",
-	      module_idP, CC_id, sdu_lengths[num_sdus]);
-	num_sdus++;
-	cc->msi_active = 1;
+  // Create MSI here
+  msi_ptr = &msi_control_element[0];
+
+  //Header for MTCHs
+  num_mtch = cc->mbms_SessionList[mbms_mch_i]->list.count;
+
+      TBS =
+  get_TBS_DL(cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
+  //l=0;
+
+  for (k = 0; k < num_mtch; k++) {  // loop for all session in this MCH (MCH[0]) at this moment
+
+      ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[mbms_mch_i]->list.array[k]->logicalChannelIdentity_r9;  //mtch_lcid;
+
+      if( msi_sfs != 0 )
+        msi_pmch_stop = msi_sfs-1;
+      else 
+    msi_pmch_stop = msi_sfs;
+  
+          msi_pmch_stop = msi_sfs;
+
+      if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
+          ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = (((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) >> 8) & 0x7f);
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = ((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) & 0xff);
+    msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
+      }else{
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;  // last subframeP of this mtch (only one mtch now)
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
+    msi_pmch_stop=0;
+      }
+      msi_ptr += sizeof(MSI_ELEMENT);
+  }
+
+  msi_length = msi_ptr - msi_control_element;
+
+  if (msi_length < 128) {
+      header_len_msi = 2;
+  } else {
+      header_len_msi = 3;
+  }
+
+  LOG_D(MAC, "[eNB %d] CC_id %d Frame %d : MSI->MCH, length of MSI is %d bytes TBS %d, bytes in buffer %d stop_sf_LSB %d msi_sfs %d cc->pmch_Config[0]->sf_AllocEnd_r9 %ld\n",
+        module_idP, CC_id, frameP, msi_length,TBS, bytes_in_buffer,msi_pmch_stop,msi_sfs,cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
+      
+  msi_sfs = 0;
+
+  // Store MSI data to mch_buffer[0]
+  memcpy((char *) &mch_buffer[sdu_length_total],
+         msi_control_element, msi_length);
+
+  buffer_pointer = (char *) &mch_buffer[sdu_length_total];
+
+  sdu_lcids[num_sdus] = MCH_SCHDL_INFO;
+  sdu_lengths[num_sdus] = msi_length;
+  sdu_length_total += sdu_lengths[num_sdus];
+  LOG_D(MAC, "[eNB %d] CC_id %d Create %d bytes for MSI\n",
+        module_idP, CC_id, sdu_lengths[num_sdus]);
+  num_sdus++;
+  cc->msi_active = 1;
     }
     // there is MCCH
     if (mcch_flag == 1) {
-	//MCCH scheduling if !FeMBMS
-	if(!cc->non_mbsfn_SubframeConfig){
+  //MCCH scheduling if !FeMBMS
+  if(!cc->non_mbsfn_SubframeConfig){
           mcch_sdu_length = mac_rrc_data_req(module_idP, CC_id, frameP, MCCH_COUNTING, 0xFFFC, 1, &cc->MCCH_pdu.payload[0], 
-					 i);	// this is the mbsfn sync area index
-	  if(mcch_sdu_length>0)
-		LOG_I(MAC, "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE COUNTING (area %d, sfAlloc %d)\n",
-		  module_idP, CC_id, frameP, subframeP, i, j);
+           i);  // this is the mbsfn sync area index
+    if(mcch_sdu_length>0)
+    LOG_I(MAC, "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE COUNTING (area %d, sfAlloc %d)\n",
+      module_idP, CC_id, frameP, subframeP, i, j);
 
-	  if (mcch_sdu_length > 0) {
+    if (mcch_sdu_length > 0) {
               mcch_sdu_length+=1; //RLC ?
-	      LOG_D(MAC, "[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
-		    module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
-
-	      header_len_mcch = 2;
-
-	      if (cc->tdd_Config != NULL) {
-		  LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
-			module_idP, CC_id, frameP, subframeP,
-			mcch_sdu_length, mcch_mcs);
-	      } else {
-		  LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
-			module_idP, CC_id, frameP, subframeP,
-			mcch_sdu_length, mcch_mcs);
-	      }
-
-	      cc->mcch_active = 1;
-
-	      memcpy((char *) &mch_buffer[sdu_length_total]+1,
-		     &cc->MCCH_pdu.payload[0], mcch_sdu_length);
-	      sdu_lcids[num_sdus] = MCCH_LCHANID;
-	      sdu_lengths[num_sdus] = mcch_sdu_length;
-
-	      if (sdu_lengths[num_sdus] > 128) {
-		  header_len_mcch = 3;
-	      }
-
-	      sdu_length_total += sdu_lengths[num_sdus];
-	      LOG_D(MAC,
-		    "[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
-		    module_idP, CC_id, sdu_lengths[num_sdus]);
-	      num_sdus++;
-	  }
-	}
-
-	//MCCH scheduling ... do it anyway
-	{
-	    LOG_I(MAC, "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE (area %d, sfAlloc %d)\n",
-	  	module_idP, CC_id, frameP, subframeP, i, j);
-
-	    mcch_sdu_length = mac_rrc_data_req(module_idP, CC_id, frameP, MCCH, 0xFFFC, 1, &cc->MCCH_pdu.payload[0], 
-				       i);	// this is the mbsfn sync area index
-
-	    if (mcch_sdu_length > 0) {
-		mcch_sdu_length+=1; //RLC ?
-		LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
-		      module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
-
-		header_len_mcch = 2;
-
-		if (cc->tdd_Config != NULL) {
-		    LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
-			  module_idP, CC_id, frameP, subframeP,
-			  mcch_sdu_length, mcch_mcs);
-		} else {
-		    LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
-			  module_idP, CC_id, frameP, subframeP,
-			  mcch_sdu_length, mcch_mcs);
-		}
-
-		cc->mcch_active = 1;
-
-		memcpy((char *) &mch_buffer[sdu_length_total]+1,
-		       &cc->MCCH_pdu.payload[0], mcch_sdu_length);
-		sdu_lcids[num_sdus] = MCCH_LCHANID;
-		sdu_lengths[num_sdus] = mcch_sdu_length;
-
-		if (sdu_lengths[num_sdus] > 128) {
-		    header_len_mcch = 3;
-		}
-
-		sdu_length_total += sdu_lengths[num_sdus];
-		LOG_D(MAC,"[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
-		      module_idP, CC_id, sdu_lengths[num_sdus]);
-		num_sdus++;
-	    }
-	}
+        LOG_D(MAC, "[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
+        module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
+
+        header_len_mcch = 2;
+
+        if (cc->tdd_Config != NULL) {
+      LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
+      module_idP, CC_id, frameP, subframeP,
+      mcch_sdu_length, mcch_mcs);
+        } else {
+      LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
+      module_idP, CC_id, frameP, subframeP,
+      mcch_sdu_length, mcch_mcs);
+        }
+
+        cc->mcch_active = 1;
+
+        memcpy((char *) &mch_buffer[sdu_length_total]+1,
+         &cc->MCCH_pdu.payload[0], mcch_sdu_length);
+        sdu_lcids[num_sdus] = MCCH_LCHANID;
+        sdu_lengths[num_sdus] = mcch_sdu_length;
+
+        if (sdu_lengths[num_sdus] > 128) {
+      header_len_mcch = 3;
+        }
+
+        sdu_length_total += sdu_lengths[num_sdus];
+        LOG_D(MAC,
+        "[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
+        module_idP, CC_id, sdu_lengths[num_sdus]);
+        num_sdus++;
+    }
+  }
+
+  //MCCH scheduling ... do it anyway
+  {
+      LOG_I(MAC, "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE (area %d, sfAlloc %d)\n",
+      module_idP, CC_id, frameP, subframeP, i, j);
+
+      mcch_sdu_length = mac_rrc_data_req(module_idP, CC_id, frameP, MCCH, 0xFFFC, 1, &cc->MCCH_pdu.payload[0], 
+               i);  // this is the mbsfn sync area index
+
+      if (mcch_sdu_length > 0) {
+    mcch_sdu_length+=1; //RLC ?
+    LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
+          module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
+
+    header_len_mcch = 2;
+
+    if (cc->tdd_Config != NULL) {
+        LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
+        module_idP, CC_id, frameP, subframeP,
+        mcch_sdu_length, mcch_mcs);
+    } else {
+        LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
+        module_idP, CC_id, frameP, subframeP,
+        mcch_sdu_length, mcch_mcs);
+    }
+
+    cc->mcch_active = 1;
+
+    memcpy((char *) &mch_buffer[sdu_length_total]+1,
+           &cc->MCCH_pdu.payload[0], mcch_sdu_length);
+    sdu_lcids[num_sdus] = MCCH_LCHANID;
+    sdu_lengths[num_sdus] = mcch_sdu_length;
+
+    if (sdu_lengths[num_sdus] > 128) {
+        header_len_mcch = 3;
+    }
+
+    sdu_length_total += sdu_lengths[num_sdus];
+    LOG_D(MAC,"[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
+          module_idP, CC_id, sdu_lengths[num_sdus]);
+    num_sdus++;
+      }
+  }
     }// mcch_flag
 
 
     TBS =
-	get_TBS_DL(/*cc->pmch_Config[0]->dataMCS_r9*/cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
+  get_TBS_DL(/*cc->pmch_Config[0]->dataMCS_r9*/cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
     // do not let mcch and mtch multiplexing when relaying is active
     // for sync area 1, so not transmit data
     //if ((i == 0) && ((RC.mac[module_idP]->MBMS_flag != multicast_relay) || (RC.mac[module_idP]->mcch_active==0))) {
 
     // there is MTCHs, loop if there are more than 1
     if (mtch_flag == 1 ) {
-	// Calculate TBS
-	// get MTCH data from RLC (like for DTCH)
-	LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Schedule MTCH (area %d, sfAlloc %d)\n",
-	      module_idP, CC_id, frameP, subframeP, i, j);
-
-	header_len_mtch = 3;
-	LOG_D(MAC,"[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
-	      module_idP, CC_id, frameP, MTCH, TBS,
-	      TBS - header_len_mcch - header_len_msi - sdu_length_total -
-	      header_len_mtch);
-
-	//TODO
-	mbms_rab_id = cc->mbms_SessionList[0/*mbms_mch_i*/]->list.array[0]->logicalChannelIdentity_r9;
-
-	rlc_status =
-	    mac_rlc_status_ind(module_idP, 0xfffd, frameP, subframeP,
-			       module_idP, ENB_FLAG_YES, MBMS_FLAG_YES,
-				cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9,
-			       //MTCH,
+  // Calculate TBS
+  // get MTCH data from RLC (like for DTCH)
+  LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframeP %d: Schedule MTCH (area %d, sfAlloc %d)\n",
+        module_idP, CC_id, frameP, subframeP, i, j);
+
+  header_len_mtch = 3;
+  LOG_D(MAC,"[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
+        module_idP, CC_id, frameP, MTCH, TBS,
+        TBS - header_len_mcch - header_len_msi - sdu_length_total -
+        header_len_mtch);
+
+  //TODO
+  mbms_rab_id = cc->mbms_SessionList[0/*mbms_mch_i*/]->list.array[0]->logicalChannelIdentity_r9;
+
+  rlc_status =
+      mac_rlc_status_ind(module_idP, 0xfffd, frameP, subframeP,
+             module_idP, ENB_FLAG_YES, MBMS_FLAG_YES,
+        cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9,
+             //MTCH,
                                      0, 0
                                     );
 
-	bytes_in_buffer = rlc_status.bytes_in_buffer;
+  bytes_in_buffer = rlc_status.bytes_in_buffer;
 
-	//TOCHECK is this really neede?
-	if( !(mcch_flag==1 || msi_flag==1) )
-		msi_sfs = rlc_status.bytes_in_buffer/(TBS- header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)+(rlc_status.bytes_in_buffer%(TBS- header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)?1:0);
+  //TOCHECK is this really neede?
+  if( !(mcch_flag==1 || msi_flag==1) )
+    msi_sfs = rlc_status.bytes_in_buffer/(TBS- header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)+(rlc_status.bytes_in_buffer%(TBS- header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)?1:0);
 
         uint16_t TBS_MTCH =
-	get_TBS_DL(cc->pmch_Config[mbms_mch_i]->dataMCS_r9, to_prb(cc->mib->message.dl_Bandwidth));
+  get_TBS_DL(cc->pmch_Config[mbms_mch_i]->dataMCS_r9, to_prb(cc->mib->message.dl_Bandwidth));
 
-	if(msi_flag==1 && buffer_pointer!=NULL){
-	//	msi_ptr = &msi_control_element[0];
+  if(msi_flag==1 && buffer_pointer!=NULL){
+  //  msi_ptr = &msi_control_element[0];
 
-	    msi_pmch_stop = (rlc_status.bytes_in_buffer - header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)/(TBS_MTCH/*- header_len_mcch - header_len_msi -sdu_length_total*/ - header_len_mtch)+((rlc_status.bytes_in_buffer-TBS-header_len_mcch - header_len_msi -sdu_length_total)%(TBS_MTCH/*- header_len_mcch - header_len_msi -sdu_length_total*/ - header_len_mtch)?0:0);
+      msi_pmch_stop = (rlc_status.bytes_in_buffer - header_len_mcch - header_len_msi -sdu_length_total - header_len_mtch)/(TBS_MTCH/*- header_len_mcch - header_len_msi -sdu_length_total*/ - header_len_mtch)+((rlc_status.bytes_in_buffer-TBS-header_len_mcch - header_len_msi -sdu_length_total)%(TBS_MTCH/*- header_len_mcch - header_len_msi -sdu_length_total*/ - header_len_mtch)?0:0);
 
-	    for (k = 0; k < num_mtch; k++) {	// loop for all session in this MCH (MCH[0]) at this moment
-	      msi_ptr = &msi_control_element[k];
+      for (k = 0; k < num_mtch; k++) {  // loop for all session in this MCH (MCH[0]) at this moment
+        msi_ptr = &msi_control_element[k];
 
-	      ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[mbms_mch_i]->list.array[k]->logicalChannelIdentity_r9;	//mtch_lcid;
+        ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[mbms_mch_i]->list.array[k]->logicalChannelIdentity_r9;  //mtch_lcid;
 
-	      if( msi_pmch_stop > cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9)
-	             LOG_E(MAC,"e-MBMS Buffer Overflow\n"); 
+        if( msi_pmch_stop > cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9)
+               LOG_E(MAC,"e-MBMS Buffer Overflow\n"); 
 
-	      if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
-	          ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = (((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) >> 8) & 0x7f);
-	      	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = ((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) & 0xff);
-	          msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
-	      }else{
-	      	((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;	// last subframeP of this mtch (only one mtch now)
-	      	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
-	          msi_pmch_stop=0;
-	      }
-	      LOG_I(MAC,"frameP %d, subframeP %d LCID %d rlc_status.bytes_in_buffer %d stop_sf_LSB %d stop_sf_MSB %d msi_pmch_stop %d sf_AllocEnd_r9 %ld, msi_length %d\n",frameP,subframeP,((MSI_ELEMENT *) msi_ptr)->lcid,rlc_status.bytes_in_buffer,((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB,((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB, msi_pmch_stop,cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9, msi_length);
-	   }
+        if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
+            ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = (((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) >> 8) & 0x7f);
+          ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = ((msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9) & 0xff);
+            msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9);
+        }else{
+          ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;  // last subframeP of this mtch (only one mtch now)
+          ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
+            msi_pmch_stop=0;
+        }
+        LOG_I(MAC,"frameP %d, subframeP %d LCID %d rlc_status.bytes_in_buffer %d stop_sf_LSB %d stop_sf_MSB %d msi_pmch_stop %d sf_AllocEnd_r9 %ld, msi_length %d\n",frameP,subframeP,((MSI_ELEMENT *) msi_ptr)->lcid,rlc_status.bytes_in_buffer,((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB,((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB, msi_pmch_stop,cc->pmch_Config[mbms_mch_i]->sf_AllocEnd_r9, msi_length);
+     }
 
-	    memcpy((char*)buffer_pointer,
-	       msi_control_element, msi_length);
-	}
+      memcpy((char*)buffer_pointer,
+         msi_control_element, msi_length);
+  }
 
-	LOG_D(MAC, "e-MBMS log channel %u frameP %d, subframeP %d,  rlc_status.bytes_in_buffer is %d TBS_MTCH %d pmch_stop %d msi_sfs %d\n",
-	      MTCH, frameP, subframeP, rlc_status.bytes_in_buffer,TBS_MTCH,msi_pmch_stop,msi_sfs);
+  LOG_D(MAC, "e-MBMS log channel %u frameP %d, subframeP %d,  rlc_status.bytes_in_buffer is %d TBS_MTCH %d pmch_stop %d msi_sfs %d\n",
+        MTCH, frameP, subframeP, rlc_status.bytes_in_buffer,TBS_MTCH,msi_pmch_stop,msi_sfs);
 
-	//TODO not sure whether msi and mch MCH should be precluded ... keep in mind this konditions just in case if ((rlc_status.bytes_in_buffer > 0 &&  msi_pmch_stop > 0) && ((msi_flag!=1 || mcch_flag!=1))
-	if ((rlc_status.bytes_in_buffer > 0 &&  msi_pmch_stop > 0) /*&& ((msi_flag!=1 || mcch_flag!=1))*/ /*|| (rlc_status.bytes_in_buffer > 0 && (msi_flag==1 || mcch_flag==1))*//*|| msi_sfs > cc->pmch_Config[0]->sf_AllocEnd_r9 */ /*msi_pmch_stop>=num_sf_alloc*/ ) {
-	    LOG_I(MAC,"[eNB %d][MBMS USER-PLANE], CC_id %d, Frame %d, Subframe %d MTCH->MCH, Requesting %d bytes from RLC (header len mtch %d) rlc_status.bytes_in_buffer %d, LCID %ld\n",
-		  module_idP, CC_id, frameP, subframeP,
-		  TBS - header_len_mcch - header_len_msi -
-		  sdu_length_total - header_len_mtch, header_len_mtch, rlc_status.bytes_in_buffer,cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9);
+  //TODO not sure whether msi and mch MCH should be precluded ... keep in mind this konditions just in case if ((rlc_status.bytes_in_buffer > 0 &&  msi_pmch_stop > 0) && ((msi_flag!=1 || mcch_flag!=1))
+  if ((rlc_status.bytes_in_buffer > 0 &&  msi_pmch_stop > 0) /*&& ((msi_flag!=1 || mcch_flag!=1))*/ /*|| (rlc_status.bytes_in_buffer > 0 && (msi_flag==1 || mcch_flag==1))*//*|| msi_sfs > cc->pmch_Config[0]->sf_AllocEnd_r9 */ /*msi_pmch_stop>=num_sf_alloc*/ ) {
+      LOG_I(MAC,"[eNB %d][MBMS USER-PLANE], CC_id %d, Frame %d, Subframe %d MTCH->MCH, Requesting %d bytes from RLC (header len mtch %d) rlc_status.bytes_in_buffer %d, LCID %ld\n",
+      module_idP, CC_id, frameP, subframeP,
+      TBS - header_len_mcch - header_len_msi -
+      sdu_length_total - header_len_mtch, header_len_mtch, rlc_status.bytes_in_buffer,cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9);
 
       sdu_lengths[num_sdus] = mac_rlc_data_req(module_idP, 0xfffd, module_idP, frameP, ENB_FLAG_YES, MBMS_FLAG_YES,cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9,
                                                TBS - header_len_mcch - header_len_msi - sdu_length_total - header_len_mtch,
-						     (char *)
-						     &mch_buffer[sdu_length_total]
+                 (char *)
+                 &mch_buffer[sdu_length_total]
                                 ,0,
                                  0
                                  );
-	    LOG_D(MAC,"[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_sfs %d sdu_lengths[num_sdus] %d\n",
-		  module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs, sdu_lengths[num_sdus]);
+      LOG_D(MAC,"[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_sfs %d sdu_lengths[num_sdus] %d\n",
+      module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs, sdu_lengths[num_sdus]);
 
-	    cc->mtch_active = 1;
+      cc->mtch_active = 1;
 
-	    sdu_lcids[num_sdus] = cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9/*MTCH*/;
-	    sdu_length_total += sdu_lengths[num_sdus];
+      sdu_lcids[num_sdus] = cc->mbms_SessionList[mbms_mch_i]->list.array[0]->logicalChannelIdentity_r9/*MTCH*/;
+      sdu_length_total += sdu_lengths[num_sdus];
 
-	    if (msi_pmch_stop != 0 && msi_flag !=1)
-	    	msi_pmch_stop--;
+      if (msi_pmch_stop != 0 && msi_flag !=1)
+        msi_pmch_stop--;
 
-	    if (sdu_lengths[num_sdus] < 128) {
-		header_len_mtch = 2;
-	    }
+      if (sdu_lengths[num_sdus] < 128) {
+    header_len_mtch = 2;
+      }
 
-	    num_sdus++;
-	} 
-	else {
-	    header_len_mtch = 0;
-	}
+      num_sdus++;
+  } 
+  else {
+      header_len_mtch = 0;
+  }
     }
 
     // FINAL STEP: Prepare and multiplexe MSI, MCCH and MTCHs
     if ((sdu_length_total + header_len_msi + header_len_mcch + header_len_mtch) > 0) {
 
-	// Adjust the last subheader
-	header_len_mtch_temp = header_len_mtch;
-	header_len_mcch_temp = header_len_mcch;
-	header_len_msi_temp = header_len_msi;
-
-	if (header_len_mtch > 0) {
-	    header_len_mtch = 1;	// remove Length field in the  subheader for the last PDU
-	} else if (header_len_mcch > 0) {
-	    header_len_mcch = 1;
-	} else {
-	    header_len_msi = 1;
-	}
-
-	// Calculate the padding
-	if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
-	     sdu_length_total) < 0) {
-	    LOG_E(MAC, "Error in building MAC PDU, TBS %d < PDU %d \n",
-		  TBS,
-		  header_len_mtch + header_len_mcch + header_len_msi +
-		  sdu_length_total);
-	    return 0;
-	} else
-	    if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
-		 sdu_length_total) <= 2) {
-	    padding =
-		(TBS - header_len_mtch - header_len_mcch - header_len_msi -
-		 sdu_length_total);
-	    post_padding = 0;
-	} else {		// using post_padding, give back the Length field of subheader  for the last PDU
-	    padding = 0;
-
-	    if (header_len_mtch > 0) {
-		header_len_mtch = header_len_mtch_temp;
-	    } else if (header_len_mcch > 0) {
-		header_len_mcch = header_len_mcch_temp;
-	    } else {
-		header_len_msi = header_len_msi_temp;
-	    }
-
-	    post_padding =
-		TBS - sdu_length_total - header_len_msi - header_len_mcch -
-		header_len_mtch;
-	}
-
-	// Generate the MAC Header for MCH
-	// here we use the function for DLSCH because DLSCH & MCH have the same Header structure
-	offset = generate_dlsch_header((unsigned char *) cc->MCH_pdu.payload, num_sdus, sdu_lengths, sdu_lcids, 255,	// no drx
-				       31,	// no timing advance
-				       NULL,	// no contention res id
-				       padding, post_padding);
-
-	cc->MCH_pdu.Pdu_size = TBS;
-	cc->MCH_pdu.sync_area = i;
-	cc->MCH_pdu.msi_active = cc->msi_active;
-	cc->MCH_pdu.mcch_active = cc->mcch_active;
-	cc->MCH_pdu.mtch_active = cc->mtch_active;
-	LOG_D(MAC, " MCS for this sf is %d (mcch active %d, mtch active %d)\n",
-	      cc->MCH_pdu.mcs, cc->MCH_pdu.mcch_active,
-	      cc->MCH_pdu.mtch_active);
-	LOG_D(MAC, "[eNB %d][MBMS USER-PLANE ] CC_id %d Generate header : sdu_length_total %d, num_sdus %d, sdu_lengths[0] %d, sdu_lcids[0] %d => payload offset %d,padding %d,post_padding %d (mcs %d, TBS %d), header MTCH %d, header MCCH %d, header MSI %d\n",
-	      module_idP, CC_id, sdu_length_total, num_sdus,
-	      sdu_lengths[0], sdu_lcids[0], offset, padding, post_padding,
-	      cc->MCH_pdu.mcs, TBS, header_len_mtch, header_len_mcch,
-	      header_len_msi);
-	// copy SDU to mch_pdu after the MAC Header
-	memcpy(&cc->MCH_pdu.payload[offset], mch_buffer, sdu_length_total);
-
-	// filling remainder of MCH with random data if necessery
-	for (j = 0; j < (TBS - sdu_length_total - offset); j++) {
-	    cc->MCH_pdu.payload[offset + sdu_length_total + j] =
-		(char) (taus() & 0xff);
-	}
-
-	/* Tracing of PDU is done on UE side */
-	//if (opt_enabled == 1) {
-	trace_pdu(DIRECTION_DOWNLINK, (uint8_t *) cc->MCH_pdu.payload, TBS, module_idP, WS_M_RNTI , 0xfffd,	// M_RNTI = 6 in wirehsark
-	          RC.mac[module_idP]->frame,
-	          RC.mac[module_idP]->subframe, 0, 0);
-	LOG_D(OPT, "[eNB %d][MCH] CC_id %d Frame %d : MAC PDU with size %d\n",
-		  module_idP, CC_id, frameP, TBS);
-	//}
-
-       	eNB_MAC_INST *eNB = RC.mac[module_idP];
-    	dl_req = &eNB->DL_req[CC_id].dl_config_request_body;
-	dl_req->tl.tag = NFAPI_DL_CONFIG_REQUEST_BODY_TAG;
-    	fill_nfapi_mch_config(
-			dl_req,
-			TBS,
-			0,
-			0xfffd,
-			0,
-			get_Qm(cc->MCH_pdu.mcs),
-			cc->MCH_pdu.mcs,
-			6000, //equal to RS power
-			0 //mbsfn_area_id
-			);
-
-	eNB->TX_req[CC_id].sfn_sf = fill_nfapi_tx_req(&eNB->TX_req[CC_id].tx_request_body,
+  // Adjust the last subheader
+  header_len_mtch_temp = header_len_mtch;
+  header_len_mcch_temp = header_len_mcch;
+  header_len_msi_temp = header_len_msi;
+
+  if (header_len_mtch > 0) {
+      header_len_mtch = 1;  // remove Length field in the  subheader for the last PDU
+  } else if (header_len_mcch > 0) {
+      header_len_mcch = 1;
+  } else {
+      header_len_msi = 1;
+  }
+
+  // Calculate the padding
+  if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
+       sdu_length_total) < 0) {
+      LOG_E(MAC, "Error in building MAC PDU, TBS %d < PDU %d \n",
+      TBS,
+      header_len_mtch + header_len_mcch + header_len_msi +
+      sdu_length_total);
+      return 0;
+  } else
+      if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
+     sdu_length_total) <= 2) {
+      padding =
+    (TBS - header_len_mtch - header_len_mcch - header_len_msi -
+     sdu_length_total);
+      post_padding = 0;
+  } else {    // using post_padding, give back the Length field of subheader  for the last PDU
+      padding = 0;
+
+      if (header_len_mtch > 0) {
+    header_len_mtch = header_len_mtch_temp;
+      } else if (header_len_mcch > 0) {
+    header_len_mcch = header_len_mcch_temp;
+      } else {
+    header_len_msi = header_len_msi_temp;
+      }
+
+      post_padding =
+    TBS - sdu_length_total - header_len_msi - header_len_mcch -
+    header_len_mtch;
+  }
+
+  // Generate the MAC Header for MCH
+  // here we use the function for DLSCH because DLSCH & MCH have the same Header structure
+  offset = generate_dlsch_header((unsigned char *) cc->MCH_pdu.payload, num_sdus, sdu_lengths, sdu_lcids, 255,  // no drx
+               31,  // no timing advance
+               NULL,  // no contention res id
+               padding, post_padding);
+
+  cc->MCH_pdu.Pdu_size = TBS;
+  cc->MCH_pdu.sync_area = i;
+  cc->MCH_pdu.msi_active = cc->msi_active;
+  cc->MCH_pdu.mcch_active = cc->mcch_active;
+  cc->MCH_pdu.mtch_active = cc->mtch_active;
+  LOG_D(MAC, " MCS for this sf is %d (mcch active %d, mtch active %d)\n",
+        cc->MCH_pdu.mcs, cc->MCH_pdu.mcch_active,
+        cc->MCH_pdu.mtch_active);
+  LOG_D(MAC, "[eNB %d][MBMS USER-PLANE ] CC_id %d Generate header : sdu_length_total %d, num_sdus %d, sdu_lengths[0] %d, sdu_lcids[0] %d => payload offset %d,padding %d,post_padding %d (mcs %d, TBS %d), header MTCH %d, header MCCH %d, header MSI %d\n",
+        module_idP, CC_id, sdu_length_total, num_sdus,
+        sdu_lengths[0], sdu_lcids[0], offset, padding, post_padding,
+        cc->MCH_pdu.mcs, TBS, header_len_mtch, header_len_mcch,
+        header_len_msi);
+  // copy SDU to mch_pdu after the MAC Header
+  memcpy(&cc->MCH_pdu.payload[offset], mch_buffer, sdu_length_total);
+
+  // filling remainder of MCH with random data if necessery
+  for (j = 0; j < (TBS - sdu_length_total - offset); j++) {
+      cc->MCH_pdu.payload[offset + sdu_length_total + j] =
+    (char) (taus() & 0xff);
+  }
+
+  /* Tracing of PDU is done on UE side */
+  //if (opt_enabled == 1) {
+  trace_pdu(DIRECTION_DOWNLINK, (uint8_t *) cc->MCH_pdu.payload, TBS, module_idP, WS_M_RNTI , 0xfffd,  // M_RNTI = 6 in wirehsark
+            RC.mac[module_idP]->frame,
+            RC.mac[module_idP]->subframe, 0, 0);
+  LOG_D(OPT, "[eNB %d][MCH] CC_id %d Frame %d : MAC PDU with size %d\n",
+      module_idP, CC_id, frameP, TBS);
+  //}
+
+         eNB_MAC_INST *eNB = RC.mac[module_idP];
+      dl_req = &eNB->DL_req[CC_id].dl_config_request_body;
+  dl_req->tl.tag = NFAPI_DL_CONFIG_REQUEST_BODY_TAG;
+      fill_nfapi_mch_config(
+      dl_req,
+      TBS,
+      0,
+      0xfffd,
+      0,
+      get_Qm(cc->MCH_pdu.mcs),
+      cc->MCH_pdu.mcs,
+      6000, //equal to RS power
+      0 //mbsfn_area_id
+      );
+
+  eNB->TX_req[CC_id].sfn_sf = fill_nfapi_tx_req(&eNB->TX_req[CC_id].tx_request_body,
                                         (frameP * 10) + subframeP,
                                         TBS,
                                         eNB->pdu_index[CC_id],
                                         (uint8_t*)cc->MCH_pdu.payload);
-	return 1;
+  return 1;
     } else {
-	cc->MCH_pdu.Pdu_size = 0;
-	cc->MCH_pdu.sync_area = 0;
-	cc->MCH_pdu.msi_active = 0;
-	cc->MCH_pdu.mcch_active = 0;
-	cc->MCH_pdu.mtch_active = 0;
-	return 0;
+  cc->MCH_pdu.Pdu_size = 0;
+  cc->MCH_pdu.sync_area = 0;
+  cc->MCH_pdu.msi_active = 0;
+  cc->MCH_pdu.mcch_active = 0;
+  cc->MCH_pdu.mtch_active = 0;
+  return 0;
     }
 }
 int
 schedule_MBMS(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
-	      sub_frame_t subframeP)
+        sub_frame_t subframeP)
 {
 
     int mcch_flag = 0, mtch_flag = 0, msi_flag = 0;
-    int mbsfn_period = 0;	// 1<<(RC.mac[module_idP]->mbsfn_SubframeConfig[0]->radioframeAllocationPeriod);
-    int mcch_period = 0;	//32<<(RC.mac[module_idP]->mbsfn_AreaInfo[0]->mcch_Config_r9.mcch_RepetitionPeriod_r9);
+    int mbsfn_period = 0;  // 1<<(RC.mac[module_idP]->mbsfn_SubframeConfig[0]->radioframeAllocationPeriod);
+    int mcch_period = 0;  //32<<(RC.mac[module_idP]->mbsfn_AreaInfo[0]->mcch_Config_r9.mcch_RepetitionPeriod_r9);
     if(RC.mac[module_idP]->common_channels[CC_id].
               pmch_Config[0] == NULL )
 
-	return 0;
+  return 0;
 
 
     int mch_scheduling_period =
-	8 << (RC.mac[module_idP]->common_channels[CC_id].
-	      pmch_Config[0]->mch_SchedulingPeriod_r9);
+  8 << (RC.mac[module_idP]->common_channels[CC_id].
+        pmch_Config[0]->mch_SchedulingPeriod_r9);
     unsigned char mcch_sdu_length;
     unsigned char header_len_mcch = 0, header_len_msi =
-	0, header_len_mtch = 0, header_len_mtch_temp =
-	0, header_len_mcch_temp = 0, header_len_msi_temp = 0;
+  0, header_len_mtch = 0, header_len_mtch_temp =
+  0, header_len_mcch_temp = 0, header_len_msi_temp = 0;
     int ii = 0, msi_pos = 0;
     int mcch_mcs = -1;
     uint16_t TBS, j = -1, padding = 0, post_padding = 0;
@@ -1112,370 +1098,370 @@ schedule_MBMS(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
     //uint8_t l =0;
     unsigned char sdu_lcids[11], num_sdus = 0, offset = 0;
     uint16_t sdu_lengths[11], sdu_length_total = 0;
-    unsigned char mch_buffer[MAX_DLSCH_PAYLOAD_BYTES];	// check the max value, this is for dlsch only
+    unsigned char mch_buffer[MAX_DLSCH_PAYLOAD_BYTES];  // check the max value, this is for dlsch only
 
     COMMON_channels_t *cc = &RC.mac[module_idP]->common_channels[CC_id];
 
     cc->MCH_pdu.Pdu_size = 0;
 
     for (i = 0; i < cc->num_active_mbsfn_area; i++) {
-	// assume, that there is always a mapping
-	if ((j = get_mbsfn_sf_alloction(module_idP, CC_id, i)) == -1) {
-	    return 0;
-	}
-
-	mbsfn_period =
-	    1 << (cc->mbsfn_SubframeConfig[j]->radioframeAllocationPeriod);
-	mcch_period =
-	    32 << (cc->mbsfn_AreaInfo[i]->
-		   mcch_Config_r9.mcch_RepetitionPeriod_r9);
-	msi_pos = 0;
-	ii = 0;
-	LOG_D(MAC,
-	      "[eNB %d] CC_id %d Frame %d subframeP %d : Checking MBSFN Sync Area %d/%d with SF allocation %d/%d for MCCH and MTCH (mbsfn period %d, mcch period %d)\n",
-	      module_idP, CC_id, frameP, subframeP, i,
-	      cc->num_active_mbsfn_area, j, cc->num_sf_allocation_pattern,
-	      mbsfn_period, mcch_period);
-
-
-	switch (cc->mbsfn_AreaInfo[i]->mcch_Config_r9.signallingMCS_r9) {
-	case 0:
-	    mcch_mcs = 2;
-	    break;
-
-	case 1:
-	    mcch_mcs = 7;
-	    break;
-
-	case 2:
-	    mcch_mcs = 13;
-	    break;
-
-	case 3:
-	    mcch_mcs = 19;
-	    break;
-	}
-
-	// 1st: Check the MBSFN subframes from SIB2 info (SF allocation pattern i, max 8 non-overlapping patterns exist)
-	if (frameP % mbsfn_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {	// MBSFN frameP
-	    if (cc->mbsfn_SubframeConfig[j]->subframeAllocation.present == LTE_MBSFN_SubframeConfig__subframeAllocation_PR_oneFrame) {	// one-frameP format
-
-		//  Find the first subframeP in this MCH to transmit MSI
-		if (frameP % mch_scheduling_period ==
-		    cc->mbsfn_SubframeConfig[j]->
-		    radioframeAllocationOffset) {
-		    while (ii == 0) {
-			ii = cc->
-			    mbsfn_SubframeConfig[j]->subframeAllocation.
-			    choice.oneFrame.buf[0] & (0x80 >> msi_pos);
-			msi_pos++;
-		    }
-
-		    LOG_D(MAC,
-			  "[eNB %d] CC_id %d Frame %d subframeP %d : sync area %d sf allocation pattern %d sf alloc %x msi pos is %d \n",
-			  module_idP, CC_id, frameP, subframeP, i, j,
-			  cc->mbsfn_SubframeConfig[j]->
-			  subframeAllocation.choice.oneFrame.buf[0],
-			  msi_pos);
-		}
-		// Check if the subframeP is for MSI, MCCH or MTCHs and Set the correspoding flag to 1
-		switch (subframeP) {
-		case 1:
-		    if (cc->tdd_Config == NULL) {
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF1) ==
-			    MBSFN_FDD_SF1) {
-			    if (msi_pos == 1) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF1) ==
-				 MBSFN_FDD_SF1)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 2:
-		    if (cc->tdd_Config == NULL) {
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF2) ==
-			    MBSFN_FDD_SF2) {
-			    if (msi_pos == 2) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF2) ==
-				 MBSFN_FDD_SF2)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 3:
-		    if (cc->tdd_Config != NULL) {	// TDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_TDD_SF3) ==
-			    MBSFN_TDD_SF3) {
-			    if (msi_pos == 1) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_TDD_SF3) ==
-				 MBSFN_TDD_SF3)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    } else {	// FDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF3) ==
-			    MBSFN_FDD_SF3) {
-			    if (msi_pos == 3) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF3) ==
-				 MBSFN_FDD_SF3)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 4:
-		    if (cc->tdd_Config != NULL) {
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_TDD_SF4) ==
-			    MBSFN_TDD_SF4) {
-			    if (msi_pos == 2) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_TDD_SF4) ==
-				 MBSFN_TDD_SF4)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 6:
-		    if (cc->tdd_Config == NULL) {
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF6) ==
-			    MBSFN_FDD_SF6) {
-			    if (msi_pos == 4) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF6) ==
-				 MBSFN_FDD_SF6)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 7:
-		    if (cc->tdd_Config != NULL) {	// TDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_TDD_SF7) ==
-			    MBSFN_TDD_SF7) {
-			    if (msi_pos == 3) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_TDD_SF7) ==
-				 MBSFN_TDD_SF7)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    } else {	// FDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF7) ==
-			    MBSFN_FDD_SF7) {
-			    if (msi_pos == 5) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF7) ==
-				 MBSFN_FDD_SF7)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 8:
-		    if (cc->tdd_Config != NULL) {	//TDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_TDD_SF8) ==
-			    MBSFN_TDD_SF8) {
-			    if (msi_pos == 4) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_TDD_SF8) ==
-				 MBSFN_TDD_SF8)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    } else {	// FDD
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_FDD_SF8) ==
-			    MBSFN_FDD_SF8) {
-			    if (msi_pos == 6) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_FDD_SF8) ==
-				 MBSFN_FDD_SF8)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-
-		case 9:
-		    if (cc->tdd_Config != NULL) {
-			if ((cc->
-			     mbsfn_SubframeConfig[j]->subframeAllocation.
-			     choice.oneFrame.buf[0] & MBSFN_TDD_SF9) ==
-			    MBSFN_TDD_SF9) {
-			    if (msi_pos == 5) {
-				msi_flag = 1;
-			    }
-
-			    if ((frameP % mcch_period ==
-				 cc->mbsfn_AreaInfo[i]->
-				 mcch_Config_r9.mcch_Offset_r9)
-				&&
-				((cc->mbsfn_AreaInfo[i]->
-				  mcch_Config_r9.sf_AllocInfo_r9.
-				  buf[0] & MBSFN_TDD_SF9) ==
-				 MBSFN_TDD_SF9)) {
-				mcch_flag = 1;
-			    }
-
-			    mtch_flag = 1;
-			}
-		    }
-
-		    break;
-		}		// end switch
-
-		// sf allocation is non-overlapping
-		if ((msi_flag == 1) || (mcch_flag == 1)
-		    || (mtch_flag == 1)) {
-		    LOG_D(MAC,
-			  "[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d\n",
-			  module_idP, CC_id, frameP, subframeP, i, j,
-			  msi_flag, mcch_flag, mtch_flag);
-		    break;
-		}
-	    } else {		// four-frameP format
-	    }
-	}
-    }				// end of for loop
+  // assume, that there is always a mapping
+  if ((j = get_mbsfn_sf_alloction(module_idP, CC_id, i)) == -1) {
+      return 0;
+  }
+
+  mbsfn_period =
+      1 << (cc->mbsfn_SubframeConfig[j]->radioframeAllocationPeriod);
+  mcch_period =
+      32 << (cc->mbsfn_AreaInfo[i]->
+       mcch_Config_r9.mcch_RepetitionPeriod_r9);
+  msi_pos = 0;
+  ii = 0;
+  LOG_D(MAC,
+        "[eNB %d] CC_id %d Frame %d subframeP %d : Checking MBSFN Sync Area %d/%d with SF allocation %d/%d for MCCH and MTCH (mbsfn period %d, mcch period %d)\n",
+        module_idP, CC_id, frameP, subframeP, i,
+        cc->num_active_mbsfn_area, j, cc->num_sf_allocation_pattern,
+        mbsfn_period, mcch_period);
+
+
+  switch (cc->mbsfn_AreaInfo[i]->mcch_Config_r9.signallingMCS_r9) {
+  case 0:
+      mcch_mcs = 2;
+      break;
+
+  case 1:
+      mcch_mcs = 7;
+      break;
+
+  case 2:
+      mcch_mcs = 13;
+      break;
+
+  case 3:
+      mcch_mcs = 19;
+      break;
+  }
+
+  // 1st: Check the MBSFN subframes from SIB2 info (SF allocation pattern i, max 8 non-overlapping patterns exist)
+  if (frameP % mbsfn_period == cc->mbsfn_SubframeConfig[j]->radioframeAllocationOffset) {  // MBSFN frameP
+      if (cc->mbsfn_SubframeConfig[j]->subframeAllocation.present == LTE_MBSFN_SubframeConfig__subframeAllocation_PR_oneFrame) {  // one-frameP format
+
+    //  Find the first subframeP in this MCH to transmit MSI
+    if (frameP % mch_scheduling_period ==
+        cc->mbsfn_SubframeConfig[j]->
+        radioframeAllocationOffset) {
+        while (ii == 0) {
+      ii = cc->
+          mbsfn_SubframeConfig[j]->subframeAllocation.
+          choice.oneFrame.buf[0] & (0x80 >> msi_pos);
+      msi_pos++;
+        }
+
+        LOG_D(MAC,
+        "[eNB %d] CC_id %d Frame %d subframeP %d : sync area %d sf allocation pattern %d sf alloc %x msi pos is %d \n",
+        module_idP, CC_id, frameP, subframeP, i, j,
+        cc->mbsfn_SubframeConfig[j]->
+        subframeAllocation.choice.oneFrame.buf[0],
+        msi_pos);
+    }
+    // Check if the subframeP is for MSI, MCCH or MTCHs and Set the correspoding flag to 1
+    switch (subframeP) {
+    case 1:
+        if (cc->tdd_Config == NULL) {
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF1) ==
+          MBSFN_FDD_SF1) {
+          if (msi_pos == 1) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF1) ==
+         MBSFN_FDD_SF1)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 2:
+        if (cc->tdd_Config == NULL) {
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF2) ==
+          MBSFN_FDD_SF2) {
+          if (msi_pos == 2) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF2) ==
+         MBSFN_FDD_SF2)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 3:
+        if (cc->tdd_Config != NULL) {  // TDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_TDD_SF3) ==
+          MBSFN_TDD_SF3) {
+          if (msi_pos == 1) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_TDD_SF3) ==
+         MBSFN_TDD_SF3)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        } else {  // FDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF3) ==
+          MBSFN_FDD_SF3) {
+          if (msi_pos == 3) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF3) ==
+         MBSFN_FDD_SF3)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 4:
+        if (cc->tdd_Config != NULL) {
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_TDD_SF4) ==
+          MBSFN_TDD_SF4) {
+          if (msi_pos == 2) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_TDD_SF4) ==
+         MBSFN_TDD_SF4)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 6:
+        if (cc->tdd_Config == NULL) {
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF6) ==
+          MBSFN_FDD_SF6) {
+          if (msi_pos == 4) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF6) ==
+         MBSFN_FDD_SF6)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 7:
+        if (cc->tdd_Config != NULL) {  // TDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_TDD_SF7) ==
+          MBSFN_TDD_SF7) {
+          if (msi_pos == 3) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_TDD_SF7) ==
+         MBSFN_TDD_SF7)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        } else {  // FDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF7) ==
+          MBSFN_FDD_SF7) {
+          if (msi_pos == 5) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF7) ==
+         MBSFN_FDD_SF7)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 8:
+        if (cc->tdd_Config != NULL) {  //TDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_TDD_SF8) ==
+          MBSFN_TDD_SF8) {
+          if (msi_pos == 4) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_TDD_SF8) ==
+         MBSFN_TDD_SF8)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        } else {  // FDD
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_FDD_SF8) ==
+          MBSFN_FDD_SF8) {
+          if (msi_pos == 6) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_FDD_SF8) ==
+         MBSFN_FDD_SF8)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+
+    case 9:
+        if (cc->tdd_Config != NULL) {
+      if ((cc->
+           mbsfn_SubframeConfig[j]->subframeAllocation.
+           choice.oneFrame.buf[0] & MBSFN_TDD_SF9) ==
+          MBSFN_TDD_SF9) {
+          if (msi_pos == 5) {
+        msi_flag = 1;
+          }
+
+          if ((frameP % mcch_period ==
+         cc->mbsfn_AreaInfo[i]->
+         mcch_Config_r9.mcch_Offset_r9)
+        &&
+        ((cc->mbsfn_AreaInfo[i]->
+          mcch_Config_r9.sf_AllocInfo_r9.
+          buf[0] & MBSFN_TDD_SF9) ==
+         MBSFN_TDD_SF9)) {
+        mcch_flag = 1;
+          }
+
+          mtch_flag = 1;
+      }
+        }
+
+        break;
+    }    // end switch
+
+    // sf allocation is non-overlapping
+    if ((msi_flag == 1) || (mcch_flag == 1)
+        || (mtch_flag == 1)) {
+        LOG_D(MAC,
+        "[eNB %d] CC_id %d Frame %d Subframe %d: sync area %d SF alloc %d: msi flag %d, mcch flag %d, mtch flag %d\n",
+        module_idP, CC_id, frameP, subframeP, i, j,
+        msi_flag, mcch_flag, mtch_flag);
+        break;
+    }
+      } else {    // four-frameP format
+      }
+  }
+    }        // end of for loop
 
     cc->msi_active = 0;
     cc->mcch_active = 0;
@@ -1483,9 +1469,9 @@ schedule_MBMS(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
 
     // Calculate the mcs
     if ((msi_flag == 1) || (mcch_flag == 1)) {
-	cc->MCH_pdu.mcs = mcch_mcs;
-    } else if (mtch_flag == 1) {	// only MTCH in this subframeP
-	cc->MCH_pdu.mcs = cc->pmch_Config[0]->dataMCS_r9;
+  cc->MCH_pdu.mcs = mcch_mcs;
+    } else if (mtch_flag == 1) {  // only MTCH in this subframeP
+  cc->MCH_pdu.mcs = cc->pmch_Config[0]->dataMCS_r9;
     }
 
 
@@ -1498,350 +1484,350 @@ schedule_MBMS(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
 
     // there is MSI (MCH Scheduling Info)
     if (msi_flag == 1) {
-	// Create MSI here
-	uint16_t msi_control_element[29], *msi_ptr;
-
-	msi_ptr = &msi_control_element[0];
-	//((MSI_ELEMENT *) msi_ptr)->lcid = MCCH_LCHANID;	//MCCH
-
-	//if (mcch_flag == 1) {
-	//    ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0;
-	//    ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0;
-	//} else {		// no mcch for this MSP
-	//    ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;	// stop value is 2047
-	//    ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xff;
-	//}
-
-	//msi_ptr += sizeof(MSI_ELEMENT);
-
-	//Header for MTCHs
-	num_mtch = cc->mbms_SessionList[0]->list.count;
-
-    	TBS =
-	get_TBS_DL(cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
-	//l=0;
-
-	for (k = 0; k < num_mtch; k++) {	// loop for all session in this MCH (MCH[0]) at this moment
-
-	    ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[0]->list.array[k]->logicalChannelIdentity_r9;	//mtch_lcid;
-
-	    if( msi_sfs != 0 )
-	    	msi_pmch_stop = msi_sfs-1;
-	    else 
-		msi_pmch_stop = msi_sfs;
-
-	    if( msi_pmch_stop > cc->pmch_Config[0]->sf_AllocEnd_r9)
-		   LOG_W(MAC,"e-MBMS Buffer Overflow\n"); 
-
-	    if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
-	        ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0;	// last subframeP of this mtch (only one mtch now) & stop_sf limited to 256
-	    	//((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = msi_pmch_stop;
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = (msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[0]->sf_AllocEnd_r9);
-		msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[0]->sf_AllocEnd_r9);
-	    }else{
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;	// last subframeP of this mtch (only one mtch now)
-	    	((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
-		msi_pmch_stop=0;
-	    }
-
-	   
-	   
-	    msi_ptr += sizeof(MSI_ELEMENT);
-	}
-
-	msi_length = msi_ptr - msi_control_element;
-
-	if (msi_length < 128) {
-	    header_len_msi = 2;
-	} else {
-	    header_len_msi = 3;
-	}
-
-	LOG_W(MAC,
-	      "[eNB %d] CC_id %d Frame %d : MSI->MCH, length of MSI is %d bytes TBS %d, bytes in buffer %d stop_sf_LSB %d msi_sfs %d cc->pmch_Config[0]->sf_AllocEnd_r9 %ld\n",
-	      module_idP, CC_id, frameP, msi_length,TBS, bytes_in_buffer,msi_pmch_stop,msi_sfs,cc->pmch_Config[0]->sf_AllocEnd_r9);
-	    
-	msi_sfs = 0;
-
-	//LOG_D(MAC,"Scheduler: MSI is transmitted in this subframeP \n" );
-
-	//   LOG_D(MAC,"Scheduler: MSI length is %d bytes\n",msi_length);
-	// Store MSI data to mch_buffer[0]
-	memcpy((char *) &mch_buffer[sdu_length_total],
-	       msi_control_element, msi_length);
-
-	sdu_lcids[num_sdus] = MCH_SCHDL_INFO;
-	sdu_lengths[num_sdus] = msi_length;
-	sdu_length_total += sdu_lengths[num_sdus];
-	LOG_D(MAC, "[eNB %d] CC_id %d Create %d bytes for MSI\n",
-	      module_idP, CC_id, sdu_lengths[num_sdus]);
-	num_sdus++;
-	cc->msi_active = 1;
+  // Create MSI here
+  uint16_t msi_control_element[29], *msi_ptr;
+
+  msi_ptr = &msi_control_element[0];
+  //((MSI_ELEMENT *) msi_ptr)->lcid = MCCH_LCHANID;  //MCCH
+
+  //if (mcch_flag == 1) {
+  //    ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0;
+  //    ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0;
+  //} else {    // no mcch for this MSP
+  //    ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;  // stop value is 2047
+  //    ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xff;
+  //}
+
+  //msi_ptr += sizeof(MSI_ELEMENT);
+
+  //Header for MTCHs
+  num_mtch = cc->mbms_SessionList[0]->list.count;
+
+      TBS =
+  get_TBS_DL(cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
+  //l=0;
+
+  for (k = 0; k < num_mtch; k++) {  // loop for all session in this MCH (MCH[0]) at this moment
+
+      ((MSI_ELEMENT *) msi_ptr)->lcid = cc->mbms_SessionList[0]->list.array[k]->logicalChannelIdentity_r9;  //mtch_lcid;
+
+      if( msi_sfs != 0 )
+        msi_pmch_stop = msi_sfs-1;
+      else 
+    msi_pmch_stop = msi_sfs;
+
+      if( msi_pmch_stop > cc->pmch_Config[0]->sf_AllocEnd_r9)
+       LOG_W(MAC,"e-MBMS Buffer Overflow\n"); 
+
+      if(msi_pmch_stop>=num_sf_alloc /*&& msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9*/)  {
+          ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0;  // last subframeP of this mtch (only one mtch now) & stop_sf limited to 256
+        //((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = msi_pmch_stop;
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = (msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[0]->sf_AllocEnd_r9);
+    msi_pmch_stop = (msi_pmch_stop <=cc->pmch_Config[0]->sf_AllocEnd_r9 ? msi_pmch_stop: cc->pmch_Config[0]->sf_AllocEnd_r9);
+      }else{
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_MSB = 0x7;  // last subframeP of this mtch (only one mtch now)
+        ((MSI_ELEMENT *) msi_ptr)->stop_sf_LSB = 0xFF; 
+    msi_pmch_stop=0;
+      }
+
+     
+     
+      msi_ptr += sizeof(MSI_ELEMENT);
+  }
+
+  msi_length = msi_ptr - msi_control_element;
+
+  if (msi_length < 128) {
+      header_len_msi = 2;
+  } else {
+      header_len_msi = 3;
+  }
+
+  LOG_W(MAC,
+        "[eNB %d] CC_id %d Frame %d : MSI->MCH, length of MSI is %d bytes TBS %d, bytes in buffer %d stop_sf_LSB %d msi_sfs %d cc->pmch_Config[0]->sf_AllocEnd_r9 %ld\n",
+        module_idP, CC_id, frameP, msi_length,TBS, bytes_in_buffer,msi_pmch_stop,msi_sfs,cc->pmch_Config[0]->sf_AllocEnd_r9);
+      
+  msi_sfs = 0;
+
+  //LOG_D(MAC,"Scheduler: MSI is transmitted in this subframeP \n" );
+
+  //   LOG_D(MAC,"Scheduler: MSI length is %d bytes\n",msi_length);
+  // Store MSI data to mch_buffer[0]
+  memcpy((char *) &mch_buffer[sdu_length_total],
+         msi_control_element, msi_length);
+
+  sdu_lcids[num_sdus] = MCH_SCHDL_INFO;
+  sdu_lengths[num_sdus] = msi_length;
+  sdu_length_total += sdu_lengths[num_sdus];
+  LOG_D(MAC, "[eNB %d] CC_id %d Create %d bytes for MSI\n",
+        module_idP, CC_id, sdu_lengths[num_sdus]);
+  num_sdus++;
+  cc->msi_active = 1;
     }
     // there is MCCH
     if (mcch_flag == 1) {
-	LOG_D(MAC,
-	      "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE (area %d, sfAlloc %d)\n",
-	      module_idP, CC_id, frameP, subframeP, i, j);
+  LOG_D(MAC,
+        "[eNB %d] CC_id %d Frame %d Subframe %d: Schedule MCCH MESSAGE (area %d, sfAlloc %d)\n",
+        module_idP, CC_id, frameP, subframeP, i, j);
 
-	mcch_sdu_length = mac_rrc_data_req(module_idP, CC_id, frameP, MCCH, 0xFFFC, 1, &cc->MCCH_pdu.payload[0], 
-					   i);	// this is the mbsfn sync area index
+  mcch_sdu_length = mac_rrc_data_req(module_idP, CC_id, frameP, MCCH, 0xFFFC, 1, &cc->MCCH_pdu.payload[0], 
+             i);  // this is the mbsfn sync area index
 
         mcch_sdu_length+=1; //RLC ?
 
-	if (mcch_sdu_length > 0) {
-	    LOG_D(MAC,
-		  "[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
-		  module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
-
-	    header_len_mcch = 2;
-
-	    if (cc->tdd_Config != NULL) {
-		LOG_D(MAC,
-		      "[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
-		      module_idP, CC_id, frameP, subframeP,
-		      mcch_sdu_length, mcch_mcs);
-	    } else {
-		LOG_D(MAC,
-		      "[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
-		      module_idP, CC_id, frameP, subframeP,
-		      mcch_sdu_length, mcch_mcs);
-	    }
-
-	    cc->mcch_active = 1;
-
-	    memcpy((char *) &mch_buffer[sdu_length_total]+1,
-		   &cc->MCCH_pdu.payload[0], mcch_sdu_length);
-	    sdu_lcids[num_sdus] = MCCH_LCHANID;
-	    sdu_lengths[num_sdus] = mcch_sdu_length;
-
-	    if (sdu_lengths[num_sdus] > 128) {
-		header_len_mcch = 3;
-	    }
-
-	    sdu_length_total += sdu_lengths[num_sdus];
-	    LOG_D(MAC,
-		  "[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
-		  module_idP, CC_id, sdu_lengths[num_sdus]);
-	    num_sdus++;
-	}
+  if (mcch_sdu_length > 0) {
+      LOG_D(MAC,
+      "[eNB %d] CC_id %d Frame %d subframeP %d : MCCH->MCH, Received %d bytes from RRC \n",
+      module_idP, CC_id, frameP, subframeP, mcch_sdu_length);
+
+      header_len_mcch = 2;
+
+      if (cc->tdd_Config != NULL) {
+    LOG_D(MAC,
+          "[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (TDD) for MCCH message %d bytes (mcs %d )\n",
+          module_idP, CC_id, frameP, subframeP,
+          mcch_sdu_length, mcch_mcs);
+      } else {
+    LOG_D(MAC,
+          "[eNB %d] CC_id %d Frame %d subframeP %d: Scheduling MCCH->MCH (FDD) for MCCH message %d bytes (mcs %d)\n",
+          module_idP, CC_id, frameP, subframeP,
+          mcch_sdu_length, mcch_mcs);
+      }
+
+      cc->mcch_active = 1;
+
+      memcpy((char *) &mch_buffer[sdu_length_total]+1,
+       &cc->MCCH_pdu.payload[0], mcch_sdu_length);
+      sdu_lcids[num_sdus] = MCCH_LCHANID;
+      sdu_lengths[num_sdus] = mcch_sdu_length;
+
+      if (sdu_lengths[num_sdus] > 128) {
+    header_len_mcch = 3;
+      }
+
+      sdu_length_total += sdu_lengths[num_sdus];
+      LOG_D(MAC,
+      "[eNB %d] CC_id %d Got %d bytes for MCCH from RRC \n",
+      module_idP, CC_id, sdu_lengths[num_sdus]);
+      num_sdus++;
+  }
     }
 
     TBS =
-	get_TBS_DL(/*cc->pmch_Config[0]->dataMCS_r9*/cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
+  get_TBS_DL(/*cc->pmch_Config[0]->dataMCS_r9*/cc->MCH_pdu.mcs, to_prb(cc->mib->message.dl_Bandwidth));
     // do not let mcch and mtch multiplexing when relaying is active
     // for sync area 1, so not transmit data
     //if ((i == 0) && ((RC.mac[module_idP]->MBMS_flag != multicast_relay) || (RC.mac[module_idP]->mcch_active==0))) {
 
     // there is MTCHs, loop if there are more than 1
     if (mtch_flag == 1 ) {
-	// Calculate TBS
-	/* if ((msi_flag==1) || (mcch_flag==1)) {
-	   TBS = mac_xface->get_TBS(mcch_mcs, mac_xface->frame_parms->N_RB_DL);
-	   }
-	   else { // only MTCH in this subframeP
-	   TBS = mac_xface->get_TBS(RC.mac[module_idP]->pmch_Config[0]->dataMCS_r9, mac_xface->frame_parms->N_RB_DL);
-	   }
-
-	   // get MTCH data from RLC (like for DTCH)
-	   LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframe %d: Schedule MTCH (area %d, sfAlloc %d)\n",Mod_id,CC_id,frame,subframe,i,j);
-
-	   header_len_mtch = 3;
-	   LOG_D(MAC,"[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
-	   Mod_id,CC_id,frame,MTCH,TBS,
-	   TBS-header_len_mcch-header_len_msi-sdu_length_total-header_len_mtch);
-
-	   rlc_status = mac_rlc_status_ind(Mod_id,frame,1,RLC_MBMS_YES,MTCH+ (maxDRB + 3) * MAX_MOBILES_PER_RG,
-	   TBS-header_len_mcch-header_len_msi-sdu_length_total-header_len_mtch);
-	   printf("frame %d, subframe %d,  rlc_status.bytes_in_buffer is %d\n",frame,subframe, rlc_status.bytes_in_buffer);
-
-	 */
-
-	// get MTCH data from RLC (like for DTCH)
-	LOG_D(MAC,
-	      "[eNB %d] CC_id %d Frame %d subframeP %d: Schedule MTCH (area %d, sfAlloc %d)\n",
-	      module_idP, CC_id, frameP, subframeP, i, j);
-
-	header_len_mtch = 3;
-	LOG_D(MAC,
-	      "[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
-	      module_idP, CC_id, frameP, MTCH, TBS,
-	      TBS - header_len_mcch - header_len_msi - sdu_length_total -
-	      header_len_mtch);
-
-	mbms_rab_id = cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9;
-
-	rlc_status =
-	    mac_rlc_status_ind(module_idP, 0xfffd, frameP, subframeP,
-			       module_idP, ENB_FLAG_YES, MBMS_FLAG_YES,
-				cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9,
-			       //MTCH,
+  // Calculate TBS
+  /* if ((msi_flag==1) || (mcch_flag==1)) {
+     TBS = mac_xface->get_TBS(mcch_mcs, mac_xface->frame_parms->N_RB_DL);
+     }
+     else { // only MTCH in this subframeP
+     TBS = mac_xface->get_TBS(RC.mac[module_idP]->pmch_Config[0]->dataMCS_r9, mac_xface->frame_parms->N_RB_DL);
+     }
+
+     // get MTCH data from RLC (like for DTCH)
+     LOG_D(MAC,"[eNB %d] CC_id %d Frame %d subframe %d: Schedule MTCH (area %d, sfAlloc %d)\n",Mod_id,CC_id,frame,subframe,i,j);
+
+     header_len_mtch = 3;
+     LOG_D(MAC,"[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
+     Mod_id,CC_id,frame,MTCH,TBS,
+     TBS-header_len_mcch-header_len_msi-sdu_length_total-header_len_mtch);
+
+     rlc_status = mac_rlc_status_ind(Mod_id,frame,1,RLC_MBMS_YES,MTCH+ (maxDRB + 3) * MAX_MOBILES_PER_RG,
+     TBS-header_len_mcch-header_len_msi-sdu_length_total-header_len_mtch);
+     printf("frame %d, subframe %d,  rlc_status.bytes_in_buffer is %d\n",frame,subframe, rlc_status.bytes_in_buffer);
+
+   */
+
+  // get MTCH data from RLC (like for DTCH)
+  LOG_D(MAC,
+        "[eNB %d] CC_id %d Frame %d subframeP %d: Schedule MTCH (area %d, sfAlloc %d)\n",
+        module_idP, CC_id, frameP, subframeP, i, j);
+
+  header_len_mtch = 3;
+  LOG_D(MAC,
+        "[eNB %d], CC_id %d, Frame %d, MTCH->MCH, Checking RLC status (rab %d, tbs %d, len %d)\n",
+        module_idP, CC_id, frameP, MTCH, TBS,
+        TBS - header_len_mcch - header_len_msi - sdu_length_total -
+        header_len_mtch);
+
+  mbms_rab_id = cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9;
+
+  rlc_status =
+      mac_rlc_status_ind(module_idP, 0xfffd, frameP, subframeP,
+             module_idP, ENB_FLAG_YES, MBMS_FLAG_YES,
+        cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9,
+             //MTCH,
                                      0, 0
                                     );
-	bytes_in_buffer = rlc_status.bytes_in_buffer;
+  bytes_in_buffer = rlc_status.bytes_in_buffer;
 
 
-	msi_sfs = rlc_status.bytes_in_buffer/TBS+(rlc_status.bytes_in_buffer%TBS?1:0);
+  msi_sfs = rlc_status.bytes_in_buffer/TBS+(rlc_status.bytes_in_buffer%TBS?1:0);
 
-	LOG_D(MAC,
-	      "e-MBMS log channel %u frameP %d, subframeP %d,  rlc_status.bytes_in_buffer is %d TBS %d pmch_stop %d msi_sfs %d\n",
-	      MTCH, frameP, subframeP, rlc_status.bytes_in_buffer,TBS,msi_pmch_stop,msi_sfs);
+  LOG_D(MAC,
+        "e-MBMS log channel %u frameP %d, subframeP %d,  rlc_status.bytes_in_buffer is %d TBS %d pmch_stop %d msi_sfs %d\n",
+        MTCH, frameP, subframeP, rlc_status.bytes_in_buffer,TBS,msi_pmch_stop,msi_sfs);
 
-	if (rlc_status.bytes_in_buffer > 0 ||  msi_pmch_stop > 0  /*msi_pmch_stop>=num_sf_alloc*/ ) {
-	    //if(rlc_status.bytes_in_buffer > 0){
-	    LOG_I(MAC,
-		  "[eNB %d][MBMS USER-PLANE], CC_id %d, Frame %d, MTCH->MCH, Requesting %d bytes from RLC (header len mtch %d) rlc_status.bytes_in_buffer %d\n",
-		  module_idP, CC_id, frameP,
-		  TBS - header_len_mcch - header_len_msi -
-		  sdu_length_total - header_len_mtch, header_len_mtch, rlc_status.bytes_in_buffer);
+  if (rlc_status.bytes_in_buffer > 0 ||  msi_pmch_stop > 0  /*msi_pmch_stop>=num_sf_alloc*/ ) {
+      //if(rlc_status.bytes_in_buffer > 0){
+      LOG_I(MAC,
+      "[eNB %d][MBMS USER-PLANE], CC_id %d, Frame %d, MTCH->MCH, Requesting %d bytes from RLC (header len mtch %d) rlc_status.bytes_in_buffer %d\n",
+      module_idP, CC_id, frameP,
+      TBS - header_len_mcch - header_len_msi -
+      sdu_length_total - header_len_mtch, header_len_mtch, rlc_status.bytes_in_buffer);
 
       sdu_lengths[num_sdus] = mac_rlc_data_req(module_idP, 0xfffd, module_idP, frameP, ENB_FLAG_YES, MBMS_FLAG_YES,cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9,
                                                TBS - header_len_mcch - header_len_msi - sdu_length_total - header_len_mtch,
-						     (char *)
-						     &mch_buffer[sdu_length_total]
+                 (char *)
+                 &mch_buffer[sdu_length_total]
                                 ,0,
                                  0
                                  );
-	
-	    //sdu_lengths[num_sdus] = mac_rlc_data_req(module_idP,frameP, MBMS_FLAG_NO,  MTCH+(MAX_NUM_RB*(MAX_MOBILES_PER_ENB+1)), (char*)&mch_buffer[sdu_length_total]);
-	    LOG_I(MAC,
-		  "[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_sfs %d sdu_lengths[num_sdus] %d\n",
-		  module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs, sdu_lengths[num_sdus]);
-	    cc->mtch_active = 1;
-	    sdu_lcids[num_sdus] = cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9/*MTCH*/;
-	    sdu_length_total += sdu_lengths[num_sdus];
-
-	    if (msi_pmch_stop != 0)
-	    	msi_pmch_stop--;
-
-
-	    if (sdu_lengths[num_sdus] < 128) {
-		header_len_mtch = 2;
-	    }
-
-	    num_sdus++;
-	  //}
-	} 
-	else {
-	//    LOG_E(MAC,
-	//	  "[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_buffer %d msi_sfs %ld msi_buffer_act %ld  sdu_lengths[num_sdus] %d\n",
-	//	  module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs,msi_buffer_act, sdu_lengths[num_sdus]);
-
-	    header_len_mtch = 0;
-	}
+  
+      //sdu_lengths[num_sdus] = mac_rlc_data_req(module_idP,frameP, MBMS_FLAG_NO,  MTCH+(MAX_NUM_RB*(MAX_MOBILES_PER_ENB+1)), (char*)&mch_buffer[sdu_length_total]);
+      LOG_I(MAC,
+      "[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_sfs %d sdu_lengths[num_sdus] %d\n",
+      module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs, sdu_lengths[num_sdus]);
+      cc->mtch_active = 1;
+      sdu_lcids[num_sdus] = cc->mbms_SessionList[0]->list.array[0]->logicalChannelIdentity_r9/*MTCH*/;
+      sdu_length_total += sdu_lengths[num_sdus];
+
+      if (msi_pmch_stop != 0)
+        msi_pmch_stop--;
+
+
+      if (sdu_lengths[num_sdus] < 128) {
+    header_len_mtch = 2;
+      }
+
+      num_sdus++;
+    //}
+  } 
+  else {
+  //    LOG_E(MAC,
+  //    "[eNB %d][MBMS USER-PLANE] CC_id %d Got %d bytes for MTCH %d msi_pmch_stop %d msi_buffer %d msi_sfs %ld msi_buffer_act %ld  sdu_lengths[num_sdus] %d\n",
+  //    module_idP, CC_id, sdu_lengths[num_sdus], MTCH,msi_pmch_stop,msi_sfs,msi_buffer_act, sdu_lengths[num_sdus]);
+
+      header_len_mtch = 0;
+  }
     }
     //  }
 
     // FINAL STEP: Prepare and multiplexe MSI, MCCH and MTCHs
     if ((sdu_length_total + header_len_msi + header_len_mcch +
-	 header_len_mtch) > 0) {
-	// Adjust the last subheader
-	/*                                 if ((msi_flag==1) || (mcch_flag==1)) {
-	   RC.mac[module_idP]->MCH_pdu.mcs = mcch_mcs;
-	   }
-	   else if (mtch_flag == 1) { // only MTCH in this subframeP
-	   RC.mac[module_idP]->MCH_pdu.mcs = RC.mac[module_idP]->pmch_Config[0]->dataMCS_r9;
-	   }
-	 */
-	header_len_mtch_temp = header_len_mtch;
-	header_len_mcch_temp = header_len_mcch;
-	header_len_msi_temp = header_len_msi;
-
-	if (header_len_mtch > 0) {
-	    header_len_mtch = 1;	// remove Length field in the  subheader for the last PDU
-	} else if (header_len_mcch > 0) {
-	    header_len_mcch = 1;
-	} else {
-	    header_len_msi = 1;
-	}
-
-	// Calculate the padding
-	if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
-	     sdu_length_total) < 0) {
-	    LOG_E(MAC, "Error in building MAC PDU, TBS %d < PDU %d \n",
-		  TBS,
-		  header_len_mtch + header_len_mcch + header_len_msi +
-		  sdu_length_total);
-	    return 0;
-	} else
-	    if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
-		 sdu_length_total) <= 2) {
-	    padding =
-		(TBS - header_len_mtch - header_len_mcch - header_len_msi -
-		 sdu_length_total);
-	    post_padding = 0;
-	} else {		// using post_padding, give back the Length field of subheader  for the last PDU
-	    padding = 0;
-
-	    if (header_len_mtch > 0) {
-		header_len_mtch = header_len_mtch_temp;
-	    } else if (header_len_mcch > 0) {
-		header_len_mcch = header_len_mcch_temp;
-	    } else {
-		header_len_msi = header_len_msi_temp;
-	    }
-
-	    post_padding =
-		TBS - sdu_length_total - header_len_msi - header_len_mcch -
-		header_len_mtch;
-	}
-
-	// Generate the MAC Header for MCH
-	// here we use the function for DLSCH because DLSCH & MCH have the same Header structure
-	offset = generate_dlsch_header((unsigned char *) cc->MCH_pdu.payload, num_sdus, sdu_lengths, sdu_lcids, 255,	// no drx
-				       31,	// no timing advance
-				       NULL,	// no contention res id
-				       padding, post_padding);
-
-	cc->MCH_pdu.Pdu_size = TBS;
-	cc->MCH_pdu.sync_area = i;
-	cc->MCH_pdu.msi_active = cc->msi_active;
-	cc->MCH_pdu.mcch_active = cc->mcch_active;
-	cc->MCH_pdu.mtch_active = cc->mtch_active;
-	LOG_D(MAC,
-	      " MCS for this sf is %d (mcch active %d, mtch active %d)\n",
-	      cc->MCH_pdu.mcs, cc->MCH_pdu.mcch_active,
-	      cc->MCH_pdu.mtch_active);
-	LOG_D(MAC,
-	      "[eNB %d][MBMS USER-PLANE ] CC_id %d Generate header : sdu_length_total %d, num_sdus %d, sdu_lengths[0] %d, sdu_lcids[0] %d => payload offset %d,padding %d,post_padding %d (mcs %d, TBS %d), header MTCH %d, header MCCH %d, header MSI %d\n",
-	      module_idP, CC_id, sdu_length_total, num_sdus,
-	      sdu_lengths[0], sdu_lcids[0], offset, padding, post_padding,
-	      cc->MCH_pdu.mcs, TBS, header_len_mtch, header_len_mcch,
-	      header_len_msi);
-	// copy SDU to mch_pdu after the MAC Header
-	memcpy(&cc->MCH_pdu.payload[offset], mch_buffer, sdu_length_total);
-
-	// filling remainder of MCH with random data if necessery
-	for (j = 0; j < (TBS - sdu_length_total - offset); j++) {
-	    cc->MCH_pdu.payload[offset + sdu_length_total + j] =
-		(char) (taus() & 0xff);
-	}
-
-	/* Tracing of PDU is done on UE side */
-	//if (opt_enabled == 1) {
-	    trace_pdu(DIRECTION_DOWNLINK, (uint8_t *) cc->MCH_pdu.payload, TBS, module_idP, WS_M_RNTI , 0xffff,	// M_RNTI = 6 in wirehsark
-		      RC.mac[module_idP]->frame,
-		      RC.mac[module_idP]->subframe, 0, 0);
-	    LOG_D(OPT,
-		  "[eNB %d][MCH] CC_id %d Frame %d : MAC PDU with size %d\n",
-		  module_idP, CC_id, frameP, TBS);
-	//}
-
-	/*
-	   for (j=0;j<sdu_length_total;j++)
-	   printf("%2x.",RC.mac[module_idP]->MCH_pdu.payload[j+offset]);
-	   printf(" \n"); */
-	return 1;
+   header_len_mtch) > 0) {
+  // Adjust the last subheader
+  /*                                 if ((msi_flag==1) || (mcch_flag==1)) {
+     RC.mac[module_idP]->MCH_pdu.mcs = mcch_mcs;
+     }
+     else if (mtch_flag == 1) { // only MTCH in this subframeP
+     RC.mac[module_idP]->MCH_pdu.mcs = RC.mac[module_idP]->pmch_Config[0]->dataMCS_r9;
+     }
+   */
+  header_len_mtch_temp = header_len_mtch;
+  header_len_mcch_temp = header_len_mcch;
+  header_len_msi_temp = header_len_msi;
+
+  if (header_len_mtch > 0) {
+      header_len_mtch = 1;  // remove Length field in the  subheader for the last PDU
+  } else if (header_len_mcch > 0) {
+      header_len_mcch = 1;
+  } else {
+      header_len_msi = 1;
+  }
+
+  // Calculate the padding
+  if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
+       sdu_length_total) < 0) {
+      LOG_E(MAC, "Error in building MAC PDU, TBS %d < PDU %d \n",
+      TBS,
+      header_len_mtch + header_len_mcch + header_len_msi +
+      sdu_length_total);
+      return 0;
+  } else
+      if ((TBS - header_len_mtch - header_len_mcch - header_len_msi -
+     sdu_length_total) <= 2) {
+      padding =
+    (TBS - header_len_mtch - header_len_mcch - header_len_msi -
+     sdu_length_total);
+      post_padding = 0;
+  } else {    // using post_padding, give back the Length field of subheader  for the last PDU
+      padding = 0;
+
+      if (header_len_mtch > 0) {
+    header_len_mtch = header_len_mtch_temp;
+      } else if (header_len_mcch > 0) {
+    header_len_mcch = header_len_mcch_temp;
+      } else {
+    header_len_msi = header_len_msi_temp;
+      }
+
+      post_padding =
+    TBS - sdu_length_total - header_len_msi - header_len_mcch -
+    header_len_mtch;
+  }
+
+  // Generate the MAC Header for MCH
+  // here we use the function for DLSCH because DLSCH & MCH have the same Header structure
+  offset = generate_dlsch_header((unsigned char *) cc->MCH_pdu.payload, num_sdus, sdu_lengths, sdu_lcids, 255,  // no drx
+               31,  // no timing advance
+               NULL,  // no contention res id
+               padding, post_padding);
+
+  cc->MCH_pdu.Pdu_size = TBS;
+  cc->MCH_pdu.sync_area = i;
+  cc->MCH_pdu.msi_active = cc->msi_active;
+  cc->MCH_pdu.mcch_active = cc->mcch_active;
+  cc->MCH_pdu.mtch_active = cc->mtch_active;
+  LOG_D(MAC,
+        " MCS for this sf is %d (mcch active %d, mtch active %d)\n",
+        cc->MCH_pdu.mcs, cc->MCH_pdu.mcch_active,
+        cc->MCH_pdu.mtch_active);
+  LOG_D(MAC,
+        "[eNB %d][MBMS USER-PLANE ] CC_id %d Generate header : sdu_length_total %d, num_sdus %d, sdu_lengths[0] %d, sdu_lcids[0] %d => payload offset %d,padding %d,post_padding %d (mcs %d, TBS %d), header MTCH %d, header MCCH %d, header MSI %d\n",
+        module_idP, CC_id, sdu_length_total, num_sdus,
+        sdu_lengths[0], sdu_lcids[0], offset, padding, post_padding,
+        cc->MCH_pdu.mcs, TBS, header_len_mtch, header_len_mcch,
+        header_len_msi);
+  // copy SDU to mch_pdu after the MAC Header
+  memcpy(&cc->MCH_pdu.payload[offset], mch_buffer, sdu_length_total);
+
+  // filling remainder of MCH with random data if necessery
+  for (j = 0; j < (TBS - sdu_length_total - offset); j++) {
+      cc->MCH_pdu.payload[offset + sdu_length_total + j] =
+    (char) (taus() & 0xff);
+  }
+
+  /* Tracing of PDU is done on UE side */
+  //if (opt_enabled == 1) {
+      trace_pdu(DIRECTION_DOWNLINK, (uint8_t *) cc->MCH_pdu.payload, TBS, module_idP, WS_M_RNTI , 0xffff,  // M_RNTI = 6 in wirehsark
+          RC.mac[module_idP]->frame,
+          RC.mac[module_idP]->subframe, 0, 0);
+      LOG_D(OPT,
+      "[eNB %d][MCH] CC_id %d Frame %d : MAC PDU with size %d\n",
+      module_idP, CC_id, frameP, TBS);
+  //}
+
+  /*
+     for (j=0;j<sdu_length_total;j++)
+     printf("%2x.",RC.mac[module_idP]->MCH_pdu.payload[j+offset]);
+     printf(" \n"); */
+  return 1;
     } else {
-	cc->MCH_pdu.Pdu_size = 0;
-	cc->MCH_pdu.sync_area = 0;
-	cc->MCH_pdu.msi_active = 0;
-	cc->MCH_pdu.mcch_active = 0;
-	cc->MCH_pdu.mtch_active = 0;
-	// for testing purpose, fill with random data
-	//for (j=0;j<(TBS-sdu_length_total-offset);j++)
-	//  RC.mac[module_idP]->MCH_pdu.payload[offset+sdu_length_total+j] = (char)(taus()&0xff);
-	return 0;
+  cc->MCH_pdu.Pdu_size = 0;
+  cc->MCH_pdu.sync_area = 0;
+  cc->MCH_pdu.msi_active = 0;
+  cc->MCH_pdu.mcch_active = 0;
+  cc->MCH_pdu.mtch_active = 0;
+  // for testing purpose, fill with random data
+  //for (j=0;j<(TBS-sdu_length_total-offset);j++)
+  //  RC.mac[module_idP]->MCH_pdu.payload[offset+sdu_length_total+j] = (char)(taus()&0xff);
+  return 0;
     }
 
     //this is for testing
@@ -1856,7 +1842,7 @@ schedule_MBMS(module_id_t module_idP, uint8_t CC_id, frame_t frameP,
 }
 
 MCH_PDU *get_mch_sdu(module_id_t module_idP, int CC_id, frame_t frameP,
-		     sub_frame_t subframeP)
+         sub_frame_t subframeP)
 {
     //  RC.mac[module_idP]->MCH_pdu.mcs=0;
     //LOG_D(MAC," MCH_pdu.mcs is %d\n", RC.mac[module_idP]->MCH_pdu.mcs);
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_primitives.c b/openair2/LAYER2/MAC/eNB_scheduler_primitives.c
index bd3c428828..5ed0c19f30 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_primitives.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_primitives.c
@@ -38,6 +38,9 @@
 #include "common/utils/LOG/log.h"
 #include "nfapi/oai_integration/vendor_ext.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 #include "UTIL/OPT/opt.h"
 #include "OCG.h"
 #include "OCG_extern.h"
@@ -3980,6 +3983,9 @@ extract_harq(module_id_t mod_idP,
                     subframe_tx,
                     harq_pid,
                     sched_ctl->round[CC_idP][harq_pid]);
+#ifdef LATSEQ
+              LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d.fm%d.subfm%d", 0, UE_id, harq_pid, frame_tx, subframe_tx);
+#endif
             } else { //nack
               if (sched_ctl->round[CC_idP][harq_pid] < 8) sched_ctl->round[CC_idP][harq_pid]++;
 
@@ -3995,6 +4001,9 @@ extract_harq(module_id_t mod_idP,
                     subframe_tx,
                     harq_pid,
                     sched_ctl->round[CC_idP][harq_pid]);
+#ifdef LATSEQ
+              LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d.fm%d.subfm%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid, frame_tx, subframe_tx);
+#endif
 
               if (sched_ctl->round[CC_idP][harq_pid] == 8) {
                 for (uint8_t ra_i = 0; ra_i < NB_RA_PROC_MAX; ra_i++) {
@@ -4138,9 +4147,14 @@ extract_harq(module_id_t mod_idP,
             sched_ctl->tbcnt[CC_idP][harq_pid] = 0;
             /* CDRX: PUCCH gives an ACK, so reset corresponding HARQ RTT */
             sched_ctl->harq_rtt_timer[CC_idP][harq_pid] = 0;
+#ifdef LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", 0, UE_id, harq_pid);
+#endif
           } else if (pdu[0] == 2 || pdu[0] == 4) {  // NAK (treat DTX as NAK)
             sched_ctl->round[CC_idP][harq_pid]++; // increment round
-
+#ifdef LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
               sched_ctl->round[CC_idP][harq_pid] = 8; // release HARQ process
               sched_ctl->tbcnt[CC_idP][harq_pid] = 0;
@@ -4170,6 +4184,9 @@ extract_harq(module_id_t mod_idP,
           if (num_ack_nak == 2 && sched_ctl->round[CC_idP][harq_pid] < 8 && sched_ctl->tbcnt[CC_idP][harq_pid] == 1 && pdu[0] == 1 && pdu[1] == 1) {
             sched_ctl->round[CC_idP][harq_pid] = 8;
             sched_ctl->tbcnt[CC_idP][harq_pid] = 0;
+#ifdef LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", 0, UE_id, harq_pid);
+#endif
             /* CDRX: PUCCH gives an ACK, so reset corresponding HARQ RTT */
             sched_ctl->harq_rtt_timer[CC_idP][harq_pid] = 0;
           }
@@ -4179,6 +4196,9 @@ extract_harq(module_id_t mod_idP,
               && (sched_ctl->tbcnt[CC_idP][harq_pid] == 1)
               && (pdu[0] == 2) && (pdu[1] == 2)) {
             sched_ctl->round[CC_idP][harq_pid]++;
+#ifdef LATSEQ
+              LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
 
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
               sched_ctl->round[CC_idP][harq_pid] = 8;     // release HARQ process
@@ -4195,6 +4215,9 @@ extract_harq(module_id_t mod_idP,
                          && (sched_ctl->tbcnt[CC_idP][harq_pid] == 2)
                          && (pdu[0] == 2) && (pdu[1] == 1))) {
             sched_ctl->round[CC_idP][harq_pid]++;
+#ifdef LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
             sched_ctl->tbcnt[CC_idP][harq_pid] = 1;
 
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
@@ -4208,6 +4231,9 @@ extract_harq(module_id_t mod_idP,
                      && (sched_ctl->tbcnt[CC_idP][harq_pid] == 2)
                      && (pdu[0] == 2) && (pdu[1] == 2)) {
             sched_ctl->round[CC_idP][harq_pid]++;
+#ifdef LATSEQ
+            LATSEQ_P("I mac.harq.down", "nack%d:ue%d:harq%d", sched_ctl->round[CC_idP][harq_pid], UE_id, harq_pid);
+#endif
 
             if (sched_ctl->round[CC_idP][harq_pid] == 4) {
               sched_ctl->round[CC_idP][harq_pid] = 8;     // release HARQ process
@@ -4834,6 +4860,9 @@ extract_pusch_csi(module_id_t mod_idP,
       }
 
       sched_ctl->dl_cqi[CC_idP] = sched_ctl->aperiodic_wideband_cqi0[CC_idP];
+#ifdef LATSEQ
+      LATSEQ_P("I phy.srs", "dcqi%d:ru%d.ue%d:", sched_ctl->dl_cqi[CC_idP], CC_idP, UE_id);
+#endif
       break;
 
     case LTE_CQI_ReportModeAperiodic_rm31:
@@ -5050,6 +5079,9 @@ SR_indication(module_id_t mod_idP,
 
       UE_info->UE_template[cc_idP][UE_id].ul_SR = 1;
       UE_info->UE_template[cc_idP][UE_id].ul_active = TRUE;
+#ifdef LATSEQ
+      LATSEQ_P("I mac.ind", "sr%d:ue%d:fm%d.subfm%d", 1, UE_id, frameP, subframeP);
+#endif
       VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_SR_INDICATION, 1);
       VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_SR_INDICATION, 0);
     }
diff --git a/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c b/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c
index d4f486f761..f5eede58ca 100644
--- a/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c
+++ b/openair2/LAYER2/MAC/eNB_scheduler_ulsch.c
@@ -60,6 +60,9 @@
 #include "common/utils/lte/prach_utils.h"
 
 #include "T.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "common/ran_context.h"
 extern RAN_CONTEXT_t RC;
@@ -169,6 +172,11 @@ rx_sdu(const module_id_t enb_mod_idP,
        * lte_est_timing_advance_pusch, maybe it's not necessary?
        * maybe it's even not correct at all?
        */
+
+#ifdef LATSEQ
+      LATSEQ_P("I phy.srs", "ucqi%d:ru%d.ue%d:", ul_cqi, CC_idP, UE_id);
+#endif
+
       UE_scheduling_control->ta_update_f = ((double)UE_scheduling_control->ta_update_f * 3 + (double)timing_advance) / 4;
       UE_scheduling_control->ta_update = (int)UE_scheduling_control->ta_update_f;
       int tmp_snr = (5 * ul_cqi - 640) / 10;
@@ -444,7 +452,9 @@ rx_sdu(const module_id_t enb_mod_idP,
           if (UE_template_ptr->phr_info > 40) {
             UE_template_ptr->phr_info = 40;
           }
-
+#ifdef LATSEQ
+          LATSEQ_P("I mac.ind", "phr%d:ue%d:", UE_template_ptr->phr_info, UE_id);
+#endif
           LOG_D(MAC, "[eNB %d] CC_id %d MAC CE_LCID %d : Received PHR PH = %d (db)\n",
                 enb_mod_idP,
                 CC_idP,
@@ -594,6 +604,9 @@ rx_sdu(const module_id_t enb_mod_idP,
           int bsr = 0;
           bsr = payload_ptr[0] & 0x3f;
           lcgid_updated[lcgid] = 1;
+#ifdef LATSEQ
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr, BSR_TABLE[bsr], UE_id, lcgid);
+#endif
           /* Update buffer info */
           UE_template_ptr->ul_buffer_info[lcgid] = BSR_TABLE[bsr];
           UE_template_ptr->estimated_ul_buffer =
@@ -646,6 +659,12 @@ rx_sdu(const module_id_t enb_mod_idP,
             UE_template_ptr->ul_buffer_info[LCGID1] +
             UE_template_ptr->ul_buffer_info[LCGID2] +
             UE_template_ptr->ul_buffer_info[LCGID3];
+#ifdef LATSEQ
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr0, BSR_TABLE[bsr0], UE_id, 0);
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr1, BSR_TABLE[bsr1], UE_id, 1);
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr2, BSR_TABLE[bsr2], UE_id, 2);
+          LATSEQ_P("I mac.ind", "bsr%d.len%d:ue%d:lcgid%d", bsr3, BSR_TABLE[bsr3], UE_id, 3);
+#endif
           LOG_D(MAC, "[eNB %d] CC_id %d MAC CE_LCID %d: Received long BSR. Size is LCGID0 = %u LCGID1 = %u LCGID2 = %u LCGID3 = %u\n",
                 enb_mod_idP,
                 CC_idP,
@@ -965,6 +984,9 @@ rx_sdu(const module_id_t enb_mod_idP,
               }
             }
 
+#if LATSEQ
+              LATSEQ_P("U mac.harq.up--mac.demux", "len%d:rnti%d:ue%d.lcid%d.fm%d.subfm%d", rx_lengths[i], current_rnti, UE_id, rx_lcids[i], frameP, subframeP);
+#endif
               mac_rlc_data_ind(enb_mod_idP, current_rnti, enb_mod_idP, frameP, ENB_FLAG_YES, MBMS_FLAG_NO, rx_lcids[i], (char *) payload_ptr, rx_lengths[i], 1, NULL);
               UE_info->eNB_UE_stats[CC_idP][UE_id].num_pdu_rx[rx_lcids[i]] += 1;
               UE_info->eNB_UE_stats[CC_idP][UE_id].num_bytes_rx[rx_lcids[i]] += rx_lengths[i];
@@ -1481,8 +1503,8 @@ schedule_ulsch_rnti(module_id_t   module_idP,
                 rnti);
 
     /* Seems unused, only for debug */
-    RC.eNB[module_idP][CC_id]->pusch_stats_BO[UE_id][(frameP * 10) + subframeP] =
-        UE_template_ptr->estimated_ul_buffer;
+//    RC.eNB[module_idP][CC_id]->pusch_stats_BO[UE_id][(frameP * 10) + subframeP] = 
+//      UE_template_ptr->estimated_ul_buffer;
     VCD_SIGNAL_DUMPER_DUMP_VARIABLE_BY_NAME(VCD_SIGNAL_DUMPER_VARIABLES_UE0_BO,
                                             UE_template_ptr->estimated_ul_buffer);
 
@@ -1646,6 +1668,27 @@ schedule_ulsch_rnti(module_id_t   module_idP,
 
       UE_info->eNB_UE_stats[CC_id][UE_id].ulsch_mcs2 = mcs;
 
+      uint8_t reserved_rb = 5;
+      uint8_t available_rb = 0;
+      switch (to_prb(cc[CC_id].ul_Bandwidth)) {
+        case 25:
+          available_rb = 25 - reserved_rb;
+          break;
+
+        case 50:
+          available_rb = 50 - reserved_rb;
+          break;
+
+        case 100:
+          available_rb = 100 - reserved_rb;
+          break;
+
+        default:
+          LOG_E(MAC, "RBs setting not handled. Todo.\n");
+          exit(1);
+      }
+      while (rb_table[rb_table_index] > available_rb && rb_table_index > 0)
+        rb_table_index--;
 
       UE_template_ptr->TBS_UL[harq_pid] = get_TBS_UL(mcs, rb_table[rb_table_index]);
       UE_info->eNB_UE_stats[CC_id][UE_id].total_rbs_used_rx += rb_table[rb_table_index];
@@ -1662,6 +1705,9 @@ schedule_ulsch_rnti(module_id_t   module_idP,
         T_INT(rb_table[rb_table_index]),
         T_INT(UE_template_ptr->TBS_UL[harq_pid]),
         T_INT(ndi));
+#ifdef LATSEQ
+      LATSEQ_P("I mac.sched.up", "mcs%d.tbs%d.nrb%d:ue%d:fm%d.subfm%d", mcs, UE_info->eNB_UE_stats[CC_id][UE_id].ulsch_TBS, rb_table[rb_table_index], UE_id, frameP, subframeP);
+#endif
       /* Store information for possible retransmission */
       UE_template_ptr->nb_rb_ul[harq_pid] = rb_table[rb_table_index];
       UE_template_ptr->first_rb_ul[harq_pid] = UE_template_ptr->pre_first_nb_rb_ul;
diff --git a/openair2/LAYER2/PDCP_v10.1.0/pdcp.c b/openair2/LAYER2/PDCP_v10.1.0/pdcp.c
index cddb666bfd..5ed183814b 100644
--- a/openair2/LAYER2/PDCP_v10.1.0/pdcp.c
+++ b/openair2/LAYER2/PDCP_v10.1.0/pdcp.c
@@ -84,6 +84,11 @@ hash_table_t  *pdcp_coll_p = NULL;
   static int mbms_socket = -1;
 #endif
 
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
+
 uint32_t Pdcp_stats_tx_window_ms[MAX_eNB][MAX_MOBILES_PER_ENB];
 uint32_t Pdcp_stats_tx_bytes[MAX_eNB][MAX_MOBILES_PER_ENB][NB_RB_MAX];
 uint32_t Pdcp_stats_tx_bytes_w[MAX_eNB][MAX_MOBILES_PER_ENB][NB_RB_MAX];
@@ -116,6 +121,7 @@ int pdcp_pc5_sockfd;
 struct sockaddr_in prose_ctrl_addr;
 struct sockaddr_in prose_pdcp_addr;
 struct sockaddr_in pdcp_sin;
+
 /* pdcp module parameters and related functions*/
 static pdcp_params_t pdcp_params= {0,NULL};
 rnti_t                 pdcp_UE_UE_module_id_to_rnti[MAX_MOBILES_PER_ENB];
@@ -373,6 +379,12 @@ boolean_t pdcp_data_req(
         VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_PDCP_DATA_REQ,VCD_FUNCTION_OUT);
         return FALSE;
       }
+#if LATSEQ
+      if (!srb_flagP) {
+        LATSEQ_P("D pdcp.in--pdcp.tx","len%d:rnti%d:drb%d.gsn%d.psn%d", sdu_buffer_sizeP, ctxt_pP->rnti, rb_idP, RC.gtpv1u_data_g->tx_seq_num, current_sn);
+      }
+#endif
+
 
       LOG_D(PDCP, "Sequence number %d is assigned to current PDU\n", current_sn);
       /* Then append data... */
@@ -989,6 +1001,7 @@ pdcp_data_ind(
     return TRUE;
   }
 
+
   // XXX Decompression would be done at this point
   /*
    * After checking incoming sequence number PDCP header
@@ -1025,6 +1038,9 @@ pdcp_data_ind(
       GTPV1U_ENB_TUNNEL_DATA_REQ(message_p).rab_id       = rb_id + 4;
       itti_send_msg_to_task(TASK_VARIABLE, INSTANCE_DEFAULT, message_p);
       packet_forwarded = TRUE;
+#if LATSEQ
+      LATSEQ_P("U pdcp.rx--gtp.out","len%d:rnti%d:drb%d.psn%d",sdu_buffer_sizeP, ctxt_pP->rnti, rb_id, sequence_number);
+#endif
     }
   } else {
     packet_forwarded = FALSE;
@@ -1102,11 +1118,18 @@ pdcp_data_ind(
       memcpy(pdcpHead+1,
              &sdu_buffer_pP->data[payload_offset],
              sdu_buffer_sizeP - payload_offset);
+
       if( LOG_DEBUGFLAG(DEBUG_PDCP) )
-	log_dump(PDCP, pdcpHead+1, min(sdu_buffer_sizeP - payload_offset,30) , LOG_DUMP_CHAR,
-	         "Printing first bytes of PDCP SDU before adding it to the list: \n");
+        log_dump(PDCP, pdcpHead+1, min(sdu_buffer_sizeP - payload_offset,30) , LOG_DUMP_CHAR,
+        "Printing first bytes of PDCP SDU before adding it to the list: \n");
+#if LATSEQ
+      if (srb_flagP == FALSE) {
+        LATSEQ_P("U pdcp.rx--pdcp.out","len%d:rnti%d:drb%d.lid%d.psn%d.fm%d",(sdu_buffer_sizeP - payload_offset), ctxt_pP->rnti, rb_id, pdcpHead->destinationL2Id, sequence_number, ctxt_pP->frame);
+      }
+#endif
       pushNotifiedFIFO(&pdcp_sdu_list, new_sdu_p); 
 
+
     /* Print octets of incoming data in hexadecimal form */
       LOG_D(PDCP, "Following content has been received from RLC (%d,%d)(PDCP header has already been removed):\n",
           sdu_buffer_sizeP  - payload_offset + (int)sizeof(pdcp_data_ind_header_t),
diff --git a/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c b/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c
index cc44572abd..b8436a2d3a 100644
--- a/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c
+++ b/openair2/LAYER2/PDCP_v10.1.0/pdcp_fifo.c
@@ -57,6 +57,9 @@ extern int otg_enabled;
 #include "UTIL/OTG/otg_tx.h"
 #include "nfapi/oai_integration/vendor_ext.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 #include "platform_constants.h"
 #include "msc.h"
 #include "pdcp.h"
@@ -130,20 +133,31 @@ int pdcp_fifo_flush_sdus(const protocol_ctxt_t *const  ctxt_pP) {
         }
        else
        {
-	 if( LOG_DEBUGFLAG(DEBUG_PDCP) ) 
-	   log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
-	 ret = write(nas_sock_fd[pdcpHead->inst], pdcpData,pdcpHead->data_size );
-	 LOG_T(PDCP,"[UE PDCP_FIFOS] ret %d TRIED TO PUSH DATA TO rb_id %d handle %d sizeToWrite %d\n",
-	       ret,rb_id,nas_sock_fd[pdcpHead->inst],pdcpHead->data_size);
+    if( LOG_DEBUGFLAG(DEBUG_PDCP) ) {
+      log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
+    }
+
+      ret = write(nas_sock_fd[pdcpHead->inst], pdcpData,pdcpHead->data_size );
+      LOG_T(PDCP,"[UE PDCP_FIFOS] ret %d TRIED TO PUSH DATA TO rb_id %d handle %d sizeToWrite %d\n",
+         ret,rb_id,nas_sock_fd[pdcpHead->inst],pdcpHead->data_size);
        }
     } else if (ENB_NAS_USE_TUN) {
-      if( LOG_DEBUGFLAG(DEBUG_PDCP) ) 
-	log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
+
+      if( LOG_DEBUGFLAG(DEBUG_PDCP) ) {
+        log_dump(PDCP, pdcpData, pdcpHead->data_size, LOG_DUMP_CHAR,"PDCP output to be sent to TUN interface: \n");
+      }
+#if LATSEQ
+      LATSEQ_P("U pdcp.out.nas--ip.out", "len%d:rnti%d:drb%d.sock%d.lid%d.fm%d", pdcpHead->data_size, ctxt_pP->rnti, rb_id, nas_sock_fd[0], pdcpHead->destinationL2Id, ctxt_pP->frame);
+#endif
       ret = write(nas_sock_fd[0], pdcpData, pdcpHead->data_size);
        LOG_T(PDCP,"[NB PDCP_FIFOS] ret %d TRIED TO PUSH DATA TO rb_id %d handle %d sizeToWrite %d\n",ret,rb_id,nas_sock_fd[0],pdcpHead->data_size);
     } else if (PDCP_USE_NETLINK) {
       int sizeToWrite= sizeof (pdcp_data_ind_header_t) + pdcpHead->data_size;
+#if LATSEQ
+      LATSEQ_P("U pdcp.out.nl--ip.out", "len%d:rnti%d:drb%d.sock%d.lid%d.fm%d", sizeToWrite, ctxt_pP->rnti, rb_id, nas_sock_fd[0], pdcpHead->destinationL2Id, ctxt_pP->frame);
+#endif
       memcpy(NLMSG_DATA(nas_nlh_tx), (uint8_t *) pdcpHead,  sizeToWrite);
+
       nas_nlh_tx->nlmsg_len = sizeToWrite;
       ret = sendmsg(nas_sock_fd[0],&nas_msg_tx,0);
     }  //  PDCP_USE_NETLINK
@@ -243,7 +257,9 @@ int pdcp_fifo_read_input_sdus_fromtun (const protocol_ctxt_t *const  ctxt_pP) {
       LOG_D(PDCP, "[FRAME %5u][UE][IP][INSTANCE %ld][RB %ld][--- PDCP_DATA_REQ / %d Bytes --->][PDCP][MOD %u][UE %04x][RB %ld]\n",
             ctxt.frame, ctxt.instance, rab_id, len, ctxt.module_id,
             ctxt.rnti, rab_id);
-
+#if LATSEQ
+      LATSEQ_P("D ip.in--pdcp.in.tun", "len%d:rnti%d:drb%d", len, ctxt.rnti, rab_id);
+#endif
 #if defined  ENABLE_PDCP_PAYLOAD_DEBUG
       LOG_I(PHY, "TUN interface output received from PDCP: \n");
       for (int i = 0; i < 128; i++) {
@@ -385,7 +401,6 @@ int pdcp_fifo_read_input_sdus_fromnetlinksock (const protocol_ctxt_t *const  ctx
     VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PDCP_FIFO_READ_BUFFER, 1 );
     len = recvmsg(nas_sock_fd[0], &nas_msg_rx, 0);
     VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME( VCD_SIGNAL_DUMPER_FUNCTIONS_PDCP_FIFO_READ_BUFFER, 0 );
-
     if (len > 0) {
       for (nas_nlh_rx = (struct nlmsghdr *) nl_rx_buf;
            NLMSG_OK (nas_nlh_rx, len);
@@ -448,6 +463,9 @@ int pdcp_fifo_read_input_sdus_fromnetlinksock (const protocol_ctxt_t *const  ctx
                       ctxt.module_id,
                       ctxt.rnti,
                       rab_id);
+#if LATSEQ
+                LATSEQ_P("D ip--pdcp.in.nl", "len%d:rnti%d:drb%d", pdcp_read_header_g.data_size, ctxt.rnti, rab_id);
+#endif
                 pdcp_data_req(&ctxt,
                               SRB_FLAG_NO,
                               rab_id,
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c
index de947225bb..f95f598575 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am.c
@@ -39,6 +39,9 @@
 #include "common/utils/LOG/log.h"
 #include "LTE_UL-AM-RLC.h"
 #include "LTE_DL-AM-RLC.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 uint32_t
@@ -719,6 +722,10 @@ rlc_am_mac_data_request (
             LOG_UI(RLC,"%s\n",message_string);
           } /* LOG_DEBUGFLAG(DEBUG_RLC) */
         }
+#if LATSEQ
+    LATSEQ_P("D rlc.seg.am--mac.mux","len%d:rnti%d:drb%d.lcid%d.rsn%d.reqfm%d", tb_size_in_bytes, ctxt_pP->rnti, l_rlc_p->rb_id, l_rlc_p->channel_id, pdu_info.sn , ctxt_pP->frame);
+    //.so%d : pdu_info.so
+#endif
       } else {
         if (rlc_am_get_control_pdu_infos(rlc_am_pdu_sn_10_p, &tb_size_in_bytes, &l_rlc_p->control_pdu_info) >= 0) {
           tb_size_in_bytes   = ((struct mac_tb_req *) (tb_p->data))->tb_size; //tb_size_in_bytes modified by rlc_am_get_control_pdu_infos!
@@ -1058,7 +1065,13 @@ rlc_am_data_req (
       message_string_size += sprintf(&message_string[message_string_size], " |\n");
       LOG_UI(RLC, "%s\n", message_string);
     } /* LOG_DEBUGFLAG(RLC) */
-
+#if LATSEQ
+    // Not necessary to detect userplane, because if it is the case
+    // then a rebuilding, no user data at input point
+    // but input point may belongs to userplane only
+    uint8_t seqnum = ((uint8_t *)(&sdu_pP->data[data_offset]))[1];
+    LATSEQ_P("D pdcp.tx--rlc.tx.am","len%d:rnti%d:drb%d.psn%d.lcid%d.rsdu%d", ((struct rlc_am_data_req *) (sdu_pP->data))->data_size, ctxt_pP->rnti, l_rlc_p->rb_id, seqnum, l_rlc_p->channel_id, l_rlc_p->next_sdu_index);
+#endif
     l_rlc_p->stat_tx_pdcp_sdu   += 1;
     l_rlc_p->stat_tx_pdcp_bytes += data_size;
     l_rlc_p->input_sdus[l_rlc_p->next_sdu_index].mui      = mui;
@@ -1080,6 +1093,9 @@ rlc_am_data_req (
     l_rlc_p->input_sdus[l_rlc_p->next_sdu_index].flags.no_new_sdu_segmented_in_last_pdu = 0;
     //l_rlc_p->input_sdus[l_rlc_p->next_sdu_index].li_index_for_discard = -1;
     l_rlc_p->next_sdu_index = (l_rlc_p->next_sdu_index + 1) % RLC_AM_SDU_CONTROL_BUFFER_SIZE;
+#if LATSEQ
+    LATSEQ_P("I rlc.am.txbuf","occ%d:drb%d", l_rlc_p->sdu_buffer_occupancy, l_rlc_p->rb_id);
+#endif
 
     if (l_rlc_p->channel_id <3) {
       LOG_I(RLC, PROTOCOL_RLC_AM_CTXT_FMT" RLC_AM_DATA_REQ size %d Bytes,  NB SDU %d current_sdu_index=%d next_sdu_index=%d conf %d mui %d vtA %d vtS %d\n",
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c
index 793d0057ac..830a4d0d3d 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_reassembly.c
@@ -31,6 +31,9 @@
 //#include "LAYER2/MAC/extern.h"
 #include "common/utils/LOG/log.h"
 #include "msc.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 inline void
@@ -162,6 +165,19 @@ rlc_am_send_sdu (
         PROTOCOL_RLC_AM_MSC_ARGS(ctxt_pP,rlc_pP),
         rlc_pP->output_sdu_size_to_write
       );
+#if LATSEQ
+      //there is 2 cases for pdcp sn lenght. Put the 2 possibilities...
+      // Copied from these functions
+      // pdcp_get_sequence_number_of_pdu_with_short_sn
+      // pdcp_get_sequence_number_of_pdu_with_long_sn
+
+      uint8_t psn_short = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x7F;
+      uint16_t psn_long = 0x00;
+      psn_long = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x0F;
+      psn_long <<= 8;
+      psn_long |= (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[1] & 0xFF;
+      LATSEQ_P("U rlc.rx.am--pdcp.rx","len%d:rnti%d:drb%d.lcid%d.rsn%d.psn%d.psn%d.fm%d", rlc_pP->output_sdu_size_to_write, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->vr_r, psn_short, psn_long, ctxt_pP->frame);
+#endif
       rlc_data_ind (ctxt_pP,
                     BOOL_NOT(rlc_pP->is_data_plane),
                     MBMS_FLAG_NO,
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c
index f9a4affb6b..594eff9b75 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_receiver.c
@@ -30,6 +30,7 @@
 #include "list.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
+#include "common/utils/LATSEQ/latseq.h"
 
 
 //-----------------------------------------------------------------------------
@@ -346,6 +347,7 @@ rlc_am_receive_process_data_pdu (
             rlc_pP->vr_ms,
             rlc_pP->vr_x);
 
+
       pdu_status = rlc_am_rx_list_check_duplicate_insert_pdu(ctxt_pP, rlc_pP,tb_pP);
       if (pdu_status != RLC_AM_DATA_PDU_STATUS_OK) {
         rlc_pP->stat_rx_data_pdu_dropped     += 1;
@@ -522,7 +524,11 @@ if( (((rlc_am_rx_pdu_management_t*)(tb_pP->data))->all_segments_received) == (pd
       LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU]  PDU DISCARDED BAD HEADER FORMAT SN=%d\n",
             PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_info_p->sn);
   }
-
+#ifdef LATSEQ
+  // rlc_pP->vr_r fix pas terrible mais qui fera l'affaire pour l'instant
+  if (pdu_status == RLC_AM_DATA_PDU_STATUS_OK)
+    LATSEQ_P("U mac.demux--rlc.rx.am", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.fm%d", tb_size_in_bytesP, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->vr_r, pdu_info_p->so, ctxt_pP->frame);
+#endif
   if (pdu_status != RLC_AM_DATA_PDU_STATUS_OK) {
 	  /* Discard received block if out of window, duplicate or header error */
       free_mem_block (tb_pP, __func__);
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c
index 4a06553901..cf07a15575 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_rx_list.c
@@ -29,6 +29,9 @@
 #include "rlc_am.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 
 boolean_t rlc_am_rx_check_vr_reassemble(
@@ -453,8 +456,8 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
               LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT SN=%d SOSTART=%d] PDU SEGMENT INSERTED AFTER PDU SEGMENT WITH SOEND=%d\n",
                           PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn,so_start_segment,
 						  pdu_info_previous_cursor_p->so + pdu_info_previous_cursor_p->payload_size - 1);
-
 			  list2_insert_after_element(tb_pP, previous_cursor_p, &rlc_pP->receiver_buffer);
+
 			  return RLC_AM_DATA_PDU_STATUS_OK;
 		  }
 
@@ -538,7 +541,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
               LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT SN=%d SOSTART=%d SOEND=%d] PDU SEGMENT INSERTED BEFORE PDU SEGMENT WITH SOSTART=%d\n",
                             PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn,so_start_segment,so_end_segment,
 							pdu_info_cursor_p->so);
-
 			  list2_insert_before_element(tb_pP, cursor_p, &rlc_pP->receiver_buffer);
 			  return RLC_AM_DATA_PDU_STATUS_OK;
 		  }
@@ -606,7 +608,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
 	              LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT SN=%d SOSTART=%d] PDU SEGMENT INSERTED AFTER PDU SEGMENT WITH SOEND=%d\n",
 	                          PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn,so_start_segment,
 							  pdu_info_previous_cursor_p->so + pdu_info_previous_cursor_p->payload_size - 1);
-
 				  list2_insert_after_element(tb_pP, previous_cursor_p, &rlc_pP->receiver_buffer);
 				  return RLC_AM_DATA_PDU_STATUS_OK;
 			  }
@@ -705,7 +706,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu_segment(
 	  if (trunc_segment != NULL) {
 		  LOG_I(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU SEGMENT]  CREATE SEGMENT FROM SEGMENT OFFSET=%d DATA LENGTH=%d SN=%d\n",
 						  PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),so_start_segment - pdu_rx_info_p->so,so_end_segment - so_start_segment + 1,pdu_rx_info_p->sn);
-
 		  if (previous_cursor_p != NULL) {
 			  list2_insert_after_element(trunc_segment, previous_cursor_p, &rlc_pP->receiver_buffer);
 		  }
@@ -779,7 +779,6 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu(
                             pdu_info_cursor_p->sn);
 	          list2_insert_before_element(tb_pP, cursor_p, &rlc_pP->receiver_buffer);
 	      }
-
 		  return pdu_status;
 	  }
 
@@ -811,14 +810,12 @@ rlc_am_rx_pdu_status_t rlc_am_rx_list_handle_pdu(
 
 	      LOG_D(RLC, PROTOCOL_RLC_AM_CTXT_FMT"[PROCESS RX PDU]  PDU REPLACES STORED PDU SEGMENTS SN=%d\n",
 	              PROTOCOL_RLC_AM_CTXT_ARGS(ctxt_pP,rlc_pP),pdu_rx_info_p->sn);
-
 	      if (previous_cursor_p != NULL) {
 	          list2_insert_after_element(tb_pP, previous_cursor_p, &rlc_pP->receiver_buffer);
 	      }
 	      else {
 	          list2_insert_before_element(tb_pP, cursor_next_p, &rlc_pP->receiver_buffer);
 	      }
-
 		  return pdu_status;
 	  } // End SN != vrR or SO != 0
 	  else {
diff --git a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c
index dbe55c483d..db2d0fcbc3 100644
--- a/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c
+++ b/openair2/LAYER2/RLC/AM_v9.3.0/rlc_am_segment.c
@@ -31,6 +31,9 @@
 #include "rlc_am.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 void rlc_am_pdu_polling (
@@ -550,6 +553,11 @@ void rlc_am_segment_10 (
     pdu_mngt_p->flags.transmitted = 1;
     pdu_mngt_p->sn = RLC_AM_PREV_SN(rlc_pP->vt_s);
 
+#if LATSEQ
+    for (int i=0; i < pdu_mngt_p->nb_sdus; i++) {
+      LATSEQ_P("D rlc.tx.am--rlc.seg.am","len%d:rnti%d:drb%d.lcid%d.rsdu%d.rsn%d", pdu_mngt_p->header_and_payload_size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, pdu_mngt_p->sdus_index[i], pdu_mngt_p->sn);
+    }
+#endif
 
     //TBC: What for resetting local pointers at the end ??
     pdu_p = NULL;
diff --git a/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c b/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c
index 4e3fffe176..b98379825d 100644
--- a/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c
+++ b/openair2/LAYER2/RLC/TM_v9.3.0/rlc_tm.c
@@ -30,6 +30,9 @@
 #include "rlc_primitives.h"
 #include "list.h"
 #include "LAYER2/MAC/mac_extern.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 //-----------------------------------------------------------------------------
 void
 rlc_tm_send_sdu (
@@ -67,7 +70,20 @@ rlc_tm_send_sdu (
 #endif
 
     memcpy (&rlc_pP->output_sdu_in_construction->data[rlc_pP->output_sdu_size_to_write], srcP, length_in_bytes);
-
+#if LATSEQ
+    if (rlc_pP->is_data_plane) {
+      //there is 2 cases for pdcp sn lenght. Put the 2 possibilities...
+      // Copied from these functions
+      // pdcp_get_sequence_number_of_pdu_with_short_sn
+      // pdcp_get_sequence_number_of_pdu_with_long_sn
+      uint8_t psn_short = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x7F;
+      uint16_t psn_long = 0x00;
+      psn_long = (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[0] & 0x0F;
+      psn_long <<= 8;
+      psn_long |= (uint8_t)((unsigned char *)rlc_pP->output_sdu_in_construction->data)[1] & 0xFF;
+      LATSEQ_P("U mac.demux--pdcp.rx","len%d:rnti%d:drb%d.lcid%d.psn%d.psn%d.fm%d", length_in_bytes, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, psn_short, psn_long, ctxt_pP->frame);
+    }
+#endif
     rlc_data_ind (
       ctxt_pP,
       BOOL_NOT(rlc_pP->is_data_plane),
@@ -114,12 +130,14 @@ rlc_tm_no_segment (
     ((struct mac_tb_req *) (pdu_p->data))->first_bit = 0;
     ((struct mac_tb_req *) (pdu_p->data))->tb_size = rlc_pP->rlc_pdu_size >> 3;
     list_add_tail_eurecom (pdu_p, &rlc_pP->pdus_to_mac_layer);
-
     rlc_pP->buffer_occupancy -= (sdu_mngt_p->sdu_size >> 3);
     free_mem_block (rlc_pP->input_sdus[rlc_pP->current_sdu_index], __func__);
     rlc_pP->input_sdus[rlc_pP->current_sdu_index] = NULL;
     rlc_pP->current_sdu_index = (rlc_pP->current_sdu_index + 1) % rlc_pP->size_input_sdus_buffer;
     rlc_pP->nb_sdu -= 1;
+#if LATSEQ
+    LATSEQ_P("D rlc.tx.tm--mac.mux","len%d:rnti%d:drb%d.lcid%d.rsdu%d.fm%d", sdu_mngt_p->sdu_size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->current_sdu_index, ctxt_pP->frame);
+#endif
   }
 }
 //-----------------------------------------------------------------------------
@@ -223,7 +241,13 @@ rlc_tm_data_req (
          rlc_p->current_sdu_index,
          rlc_p->next_sdu_index);
 #endif
-
+#if LATSEQ
+  // Not necessary to detect userplane, because if it is the case
+  // then a rebuilding, no user data at input point
+  // but input point may belongs to userplane only
+  uint8_t seqnum = (uint8_t)((unsigned char *)&sdu_pP->data)[1];
+  LATSEQ_P("D pdcp.tx--rlc.tx.tm","len%d:rnti%d:drb%d.lcid%d.psn%d.rsdu%d", ((struct rlc_um_data_req *) (sdu_pP->data))->data_size, ctxt_pP->rnti, rlc_p->rb_id, rlc_p->channel_id, seqnum, rlc_p->current_sdu_index);
+#endif
   // not in 3GPP specification but the buffer may be full if not correctly configured
   if (rlc_p->input_sdus[rlc_p->next_sdu_index] == NULL) {
     ((struct rlc_tm_tx_sdu_management *) (sdu_pP->data))->sdu_size = ((struct rlc_tm_data_req *) (sdu_pP->data))->data_size;
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c
index 654ddb8da7..f638554999 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um.c
@@ -37,7 +37,9 @@
 #include "mac_primitives.h"
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
-
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #include "rlc_um_very_simple_test.h"
 
@@ -565,6 +567,9 @@ rlc_um_mac_data_request (const protocol_ctxt_t *const ctxt_pP, void *rlc_pP,cons
           message_string_size += sprintf(&message_string[message_string_size], " |\n");
           LOG_UI(RLC, "%s\n", message_string);
         } /*LOG_DEBUGFLAG(DEBUG_RLC) */
+#if LATSEQ
+        LATSEQ_P("D rlc.seg.um--mac.mux","len%d:rnti%d:drb%d.lcid%d.rsn%d.fm%d", tb_size_in_bytes, ctxt_pP->rnti, l_rlc_p->rb_id,l_rlc_p->channel_id, pdu_info.sn, ctxt_pP->frame);
+#endif
       } /* MESSAGE_CHART_GENERATOR || LOG_DEBUGFLAG(DEBUG_RLC) */
 
       tb_p = tb_p->next;
@@ -654,9 +659,21 @@ rlc_um_data_req (const protocol_ctxt_t *const ctxt_pP, void *rlc_pP, mem_block_t
 
     LOG_UI(RLC, "%s|\n", message_string);
   }
+#if LATSEQ
+  // Not necessary to detect userplane, because if it is the case
+  // then a rebuilding, no user data at input point
+  // but input point may belongs to userplane only
+  uint8_t seqnum = ((uint8_t *)(&sdu_pP->data[sizeof (struct rlc_um_data_req_alloc)]))[1];
+  uint16_t ssize = ((struct rlc_um_tx_sdu_management *) (sdu_pP->data))->sdu_size;
+  LATSEQ_P("D pdcp.tx--rlc.tx.um","len%d:rnti%d:drb%d.psn%d.lcid%d.rsdu%d", ssize, ctxt_pP->rnti, rlc_p->rb_id, seqnum, rlc_p->channel_id, ssize);
+#endif
+
 
   RLC_UM_MUTEX_LOCK(&rlc_p->lock_input_sdus, ctxt_pP, rlc_p);
   rlc_p->buffer_occupancy += ((struct rlc_um_tx_sdu_management *) (sdu_pP->data))->sdu_size;
+#if LATSEQ
+  LATSEQ_P("I rlc.um.txbuf","occ%d:drb%d", rlc_p->buffer_occupancy, rlc_p->rb_id);
+#endif
   list_add_tail_eurecom(sdu_pP, &rlc_p->input_sdus);
   RLC_UM_MUTEX_UNLOCK(&rlc_p->lock_input_sdus);
 
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c
index c8faa08358..fd6137da49 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_dar.c
@@ -32,6 +32,10 @@
 #include "list.h"
 #include "common/utils/LOG/log.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 //-----------------------------------------------------------------------------
 signed int rlc_um_get_pdu_infos(
   const protocol_ctxt_t* const ctxt_pP,
@@ -339,7 +343,10 @@ rlc_um_try_reassembly(
         }
         continue;
       }
-
+#if LATSEQ
+      if (rlc_pP->is_data_plane)
+        LATSEQ_P("U rlc.rx.um--rlc.unseg.um","len%d:rnti%d:drb%d.lcid%d.rsn%d.fm%d", size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->last_reassemblied_sn, ctxt_pP->frame);
+#endif
       if (e == RLC_E_FIXED_PART_DATA_FIELD_FOLLOW) {
         switch (fi) {
         case RLC_FI_1ST_BYTE_DATA_IS_1ST_BYTE_SDU_LAST_BYTE_DATA_IS_LAST_BYTE_SDU:
@@ -1041,6 +1048,7 @@ rlc_um_receive_process_dar (
     return;
   }
 
+
   RLC_UM_MUTEX_LOCK(&rlc_pP->lock_dar_buffer, ctxt_pP, rlc_pP);
 
   in_window = rlc_um_in_window(ctxt_pP, rlc_pP, rlc_pP->vr_uh - rlc_pP->rx_um_window_size, sn, rlc_pP->vr_ur);
@@ -1100,7 +1108,9 @@ rlc_um_receive_process_dar (
     mem_block_t *pdu = rlc_um_remove_pdu_from_dar_buffer(ctxt_pP, rlc_pP, sn);
     free_mem_block(pdu, __func__);
   }
-
+#if LATSEQ
+  LATSEQ_P("U mac.demux--rlc.rx.um","len%d:rnti%d:drb%d.lcid%d.rsn%d.fm%d", tb_sizeP, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, sn, ctxt_pP->frame);
+#endif
   rlc_um_store_pdu_in_dar_buffer(ctxt_pP, rlc_pP, pdu_mem_pP, sn);
 
 
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c
index 2eba223803..4ac31e9bcc 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_reassembly.c
@@ -36,6 +36,9 @@
 #include "LAYER2/MAC/mac_extern.h"
 #include "common/utils/LOG/log.h"
 #include "msc.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 inline void
@@ -138,6 +141,20 @@ rlc_um_send_sdu (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP)
       rlc_um_v9_3_0_test_data_ind (rlc_pP->module_id, rlc_pP->rb_id, rlc_pP->output_sdu_size_to_write, rlc_pP->output_sdu_in_construction);
 #else
       // msg("[RLC] DATA IND ON MOD_ID %d RB ID %d, size %d\n",rlc_pP->module_id, rlc_pP->rb_id, ctxt_pP->frame,rlc_pP->output_sdu_size_to_write);
+#if LATSEQ
+      //there is 2 cases for pdcp sn lenght. Put the 2 possibilities...
+      // Copied from these functions
+      // pdcp_get_sequence_number_of_pdu_with_short_sn
+      // pdcp_get_sequence_number_of_pdu_with_long_sn
+      //if (rlc_pP->is_data_plane) {
+      uint8_t psn_short = (uint8_t)((unsigned char *)(rlc_pP->output_sdu_in_construction)->data)[0] & 0x7F;
+      uint16_t psn_long = 0x00;
+      psn_long = (uint8_t)((unsigned char *)(rlc_pP->output_sdu_in_construction)->data)[0] & 0x0F;
+      psn_long <<= 8;
+      psn_long |= (uint8_t)((unsigned char *)(rlc_pP->output_sdu_in_construction)->data)[1] & 0xFF;
+      LATSEQ_P("U rlc.unseg.um--pdcp.rx","len%d:rnti%d:drb%d.lcid%d.rsn%d.psn%d.psn%d.fm%d", rlc_pP->output_sdu_size_to_write, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, rlc_pP->last_reassemblied_sn, psn_short, psn_long, ctxt_pP->frame);
+      //}
+#endif
       rlc_data_ind (
         ctxt_pP,
         BOOL_NOT(rlc_pP->is_data_plane),
diff --git a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c
index 932bb1376e..18e6d14379 100644
--- a/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c
+++ b/openair2/LAYER2/RLC/UM_v9.3.0/rlc_um_segment.c
@@ -32,6 +32,9 @@
 #include "rlc_um.h"
 #include "rlc_primitives.h"
 #include "common/utils/LOG/log.h"
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 //-----------------------------------------------------------------------------
 void
@@ -253,6 +256,9 @@ rlc_um_segment_10 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP
       }
 
       data_sdu_p = (char *) &(sdu_in_buffer->data[sizeof (struct rlc_um_tx_sdu_management) + sdu_mngt_p->sdu_segmented_size]);
+#if LATSEQ
+      LATSEQ_P("D rlc.tx.um--rlc.seg.um","len%d:rnti%d:drb%d.lcid%d.rsdu%d.rsn%d.rso%d", sdu_mngt_p->sdu_size, ctxt_pP->rnti, rlc_pP->rb_id, rlc_pP->channel_id, sdu_mngt_p->sdu_size, rlc_pP->vt_us, sdu_mngt_p->sdu_segmented_size);
+#endif
 
       if (sdu_mngt_p->sdu_remaining_size > pdu_remaining_size) {
 #if TRACE_RLC_UM_SEGMENT
@@ -368,6 +374,7 @@ rlc_um_segment_10 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP
 //#if !EXMIMO
 //        assert(1!=1);
 //#endif
+
         memcpy(data, data_sdu_p, sdu_mngt_p->sdu_remaining_size);
         // reduce the size of the PDU
         continue_fill_pdu_with_sdu = 0;
@@ -624,6 +631,7 @@ rlc_um_segment_5 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP)
       fi_first_byte_pdu_is_first_byte_sdu = 1;
     }
 
+    // While a new sdu_in_buffer (input_sdus not empty) or continue_fill_pdu_with_sdu (means we have to continue filling a mac pdu)
     while ((sdu_in_buffer) && (continue_fill_pdu_with_sdu > 0)) {
       sdu_mngt_p = ((struct rlc_um_tx_sdu_management *) (sdu_in_buffer->data));
 
@@ -646,6 +654,12 @@ rlc_um_segment_5 (const protocol_ctxt_t* const ctxt_pP, rlc_um_entity_t *rlc_pP)
 
       data_sdu_p = (char*) &(sdu_in_buffer->data[sizeof (struct rlc_um_tx_sdu_management) + sdu_mngt_p->sdu_segmented_size]);
 
+      //LATSEQ : first place for rlc.tx.um--rlc.seg.um
+
+#if LATSEQ
+      LATSEQ_P("D rlc.tx.um--rlc.seg.um","len%d:drb%d.rnti%d.fm%d:lcid%d.rsdu%d.rsn%d.rso%d", sdu_mngt_p->sdu_size, rlc_pP->rb_id, ctxt_pP->rnti, ctxt_pP->frame, rlc_pP->channel_id, sdu_mngt_p->sdu_creation_time, rlc_pP->vt_us, sdu_mngt_p->sdu_segmented_size);
+#endif
+
       if (sdu_mngt_p->sdu_remaining_size > pdu_remaining_size) {
 #if TRACE_RLC_UM_SEGMENT
         LOG_D(RLC, PROTOCOL_RLC_UM_CTXT_FMT" Filling all remaining PDU with %d bytes\n",
diff --git a/openair2/LAYER2/RLC/rlc_mac.c b/openair2/LAYER2/RLC/rlc_mac.c
index 89cbe4c406..0bc507e58d 100644
--- a/openair2/LAYER2/RLC/rlc_mac.c
+++ b/openair2/LAYER2/RLC/rlc_mac.c
@@ -37,7 +37,9 @@
 #include "hashtable.h"
 #include "assertions.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
-
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 //#define DEBUG_MAC_INTERFACE 1
 
 //-----------------------------------------------------------------------------
@@ -74,9 +76,11 @@ struct mac_data_ind mac_rlc_deserialize_tb (
       LOG_T(RLC, "[MAC-RLC] DUMP RX PDU(%d bytes):\n", tb_sizeP);
       rlc_util_print_hex_octets(RLC, ((struct mac_tb_ind *) (tb_p->data))->data_ptr, tb_sizeP);
 #endif
+
       nb_tb_read = nb_tb_read + 1;
       tbs_size   = tbs_size   + tb_sizeP;
       list_add_tail_eurecom(tb_p, &data_ind.data);
+      
     }
 
     num_tbP = num_tbP - 1;
@@ -218,6 +222,7 @@ tbs_size_t mac_rlc_data_req(
     T(T_ENB_RLC_MAC_DL, T_INT(module_idP), T_INT(rntiP), T_INT(channel_idP), T_INT(ret_tb_size));
 
 #endif
+
   VCD_SIGNAL_DUMPER_DUMP_FUNCTION_BY_NAME(VCD_SIGNAL_DUMPER_FUNCTIONS_MAC_RLC_DATA_REQ,VCD_FUNCTION_OUT);
   return ret_tb_size;
 }
@@ -282,6 +287,11 @@ void mac_rlc_data_ind     (
     rlc_mode = RLC_MODE_NONE;
     //AssertFatal (0 , "%s RLC not configured lcid %u ! (h_rc %d)\n", __FUNCTION__,channel_idP,h_rc);
   }
+/*
+#if LATSEQ
+  LATSEQ_P_TEST("U phy.in.proc--mac.demux", "drb%d.rnti%d.fm%d:lcid%d",&rlc_union_p->rlc.am->rb_id, rntiP, frameP, channel_idP);
+#endif
+*/
 
   struct mac_data_ind data_ind = mac_rlc_deserialize_tb(buffer_pP, tb_sizeP, num_tbP, crcs_pP);
 
diff --git a/openair2/LAYER2/RLC/rlc_rrc.c b/openair2/LAYER2/RLC/rlc_rrc.c
index 4313f379fe..5ba8526b00 100644
--- a/openair2/LAYER2/RLC/rlc_rrc.c
+++ b/openair2/LAYER2/RLC/rlc_rrc.c
@@ -576,7 +576,7 @@ rlc_union_t *rrc_rlc_add_rlc   (
   hash_key_t             key         = HASHTABLE_NOT_A_KEY_VALUE;
   hashtable_rc_t         h_rc;
   hash_key_t             key_lcid    = HASHTABLE_NOT_A_KEY_VALUE;
-  hashtable_rc_t         h_lcid_rc;
+  hashtable_rc_t         h_lcid_rc   = HASH_TABLE_NONE;
   rlc_union_t           *rlc_union_p = NULL;
   rlc_mbms_id_t         *mbms_id_p  = NULL;
   logical_chan_id_t      lcid            = 0;
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity.c b/openair2/LAYER2/rlc_v2/rlc_entity.c
index d774e2b7e1..a1c6c8ee4e 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity.c
+++ b/openair2/LAYER2/rlc_v2/rlc_entity.c
@@ -46,7 +46,9 @@ rlc_entity_t *new_rlc_entity_am(
     int t_poll_retransmit,
     int poll_pdu,
     int poll_byte,
-    int max_retx_threshold)
+    int max_retx_threshold,
+    unsigned int channel_id,
+    int ue_rnti)
 {
   rlc_entity_am_t *ret;
 
@@ -87,6 +89,8 @@ rlc_entity_t *new_rlc_entity_am(
   ret->poll_pdu           = poll_pdu;
   ret->poll_byte          = poll_byte;
   ret->max_retx_threshold = max_retx_threshold;
+  ret->channel_id         = channel_id;
+  ret->ue_rnti            = ue_rnti;
 
   return (rlc_entity_t *)ret;
 }
@@ -98,7 +102,9 @@ rlc_entity_t *new_rlc_entity_um(
                       char *buf, int size),
     void *deliver_sdu_data,
     int t_reordering,
-    int sn_field_length)
+    int sn_field_length,
+    unsigned int channel_id,
+    int ue_rnti)
 {
   rlc_entity_um_t *ret;
 
@@ -129,6 +135,8 @@ rlc_entity_t *new_rlc_entity_um(
   ret->rx_maxsize         = rx_maxsize;
   ret->tx_maxsize         = tx_maxsize;
   ret->t_reordering       = t_reordering;
+  ret->channel_id         = channel_id;
+  ret->ue_rnti            = ue_rnti;
 
   if (sn_field_length == 5)
     ret->sn_modulus = 32;
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity.h b/openair2/LAYER2/rlc_v2/rlc_entity.h
index c9b35204f0..50178b551a 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity.h
+++ b/openair2/LAYER2/rlc_v2/rlc_entity.h
@@ -24,6 +24,8 @@
 
 #include <stdint.h>
 
+#include "platform_types.h"
+
 #define SDU_MAX 16000   /* maximum PDCP SDU size is 8188, let's take more */
 
 typedef struct {
@@ -34,10 +36,10 @@ typedef struct {
 
 typedef struct rlc_entity_t {
   /* functions provided by the RLC module */
-  void (*recv_pdu)(struct rlc_entity_t *entity, char *buffer, int size);
+  void (*recv_pdu)(struct rlc_entity_t *entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
   rlc_entity_buffer_status_t (*buffer_status)(
       struct rlc_entity_t *entity, int maxsize);
-  int (*generate_pdu)(struct rlc_entity_t *entity, char *buffer, int size);
+  int (*generate_pdu)(struct rlc_entity_t *entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 
   void (*recv_sdu)(struct rlc_entity_t *entity, char *buffer, int size,
                    int sdu_id);
@@ -83,7 +85,9 @@ rlc_entity_t *new_rlc_entity_am(
     int t_poll_retransmit,
     int poll_pdu,
     int poll_byte,
-    int max_retx_threshold);
+    int max_retx_threshold,
+    unsigned int channel_id,
+    int ue_rnti);
 
 rlc_entity_t *new_rlc_entity_um(
     int rx_maxsize,
@@ -92,6 +96,8 @@ rlc_entity_t *new_rlc_entity_um(
                       char *buf, int size),
     void *deliver_sdu_data,
     int t_reordering,
-    int sn_field_length);
+    int sn_field_length,
+    unsigned int channel_id,
+    int ue_rnti);
 
 #endif /* _RLC_ENTITY_H_ */
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_am.c b/openair2/LAYER2/rlc_v2/rlc_entity_am.c
index 710f22855e..47d3f915c5 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_am.c
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_am.c
@@ -26,6 +26,9 @@
 #include <string.h>
 
 #include "LOG/log.h"
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 /*************************************************************************/
 /* PDU RX functions                                                      */
@@ -196,6 +199,14 @@ static void rlc_am_reassemble(rlc_entity_am_t *entity)
        */
       if (r->data_pos != r->start->size ||
           (r->fi & 1) == 0) {
+#ifdef LATSEQ
+        uint8_t psn_short = (uint8_t)r->sdu[0] & 0x7F;
+        uint16_t psn_long = 0x00;
+        psn_long = (uint8_t)r->sdu[0] & 0x0F;
+        psn_long <<= 8;
+        psn_long |= (uint8_t)r->sdu[1] & 0xFF;
+        LATSEQ_P("U rlc.reas.am--pdcp.rx", "len%d:rnti%d:drb%d.rsn%d.rso%d.psn%d.psn%d", r->sdu_pos, entity->ue_rnti, entity->channel_id, r->sn, r->so, psn_short, psn_long);
+#endif
         /* SDU is full - deliver to higher layer */
         entity->common.deliver_sdu(entity->common.deliver_sdu_data,
                                    (rlc_entity_t *)entity,
@@ -357,6 +368,9 @@ static void consider_retransmission(rlc_entity_am_t *entity,
    * for the RLC code to keep going with this segment (we only remove
    * a segment that was ACKed)
    */
+#ifdef LATSEQ
+  LATSEQ_P("D rlc.seg.am--rlc.retx.am", "len%d:rnti%d:drb%d.rsn%d.rso%d.rretx%d",cur->data_size, entity->ue_rnti, entity->channel_id, cur->sn, cur->so, cur->retx_count);
+#endif
   entity->retransmit_list = rlc_tx_pdu_list_add(sn_compare_tx, entity,
                                                 entity->retransmit_list, cur);
 }
@@ -569,7 +583,7 @@ static void finalize_ack_nack_processing(rlc_entity_am_t *entity)
   cleanup_sdu_list(entity);
 }
 
-void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
+void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
 #define R(d) do { if (rlc_pdu_decoder_in_error(&d)) goto err; } while (0)
   rlc_entity_am_t *entity = (rlc_entity_am_t *)_entity;
@@ -617,6 +631,10 @@ void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
   e  = rlc_pdu_decoder_get_bits(&decoder, 1); R(decoder);
   sn = rlc_pdu_decoder_get_bits(&decoder, 10); R(decoder);
 
+#ifdef LATSEQ
+  LATSEQ_P("I rlc.rxbuf.am", "occ%d:rnti%d:drb%d", entity->rx_size + size, entity->ue_rnti, entity->channel_id);
+#endif
+
   /* dicard PDU if rx buffer is full */
   if (entity->rx_size + size > entity->rx_maxsize) {
     LOG_D(RLC, "%s:%d:%s: warning: discard PDU, RX buffer full\n",
@@ -638,7 +656,9 @@ void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
     lsf = 1;
     so = 0;
   }
-
+#ifdef LATSEQ
+  LATSEQ_P("U mac.demux--rlc.rx.am", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.rfi%d.fm%d", size, entity->ue_rnti, entity->channel_id, channel_id, sn, so, fi, frame);
+#endif
   packet_count = 1;
 
   /* go to start of data */
@@ -693,6 +713,10 @@ void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
 
   /* put in pdu reception list */
   entity->rx_size += size;
+  //entity->rx_num += 1;
+#ifdef LATSEQ
+  LATSEQ_P("U rlc.rx.am--rlc.reas.am", "len%d:rnti%d:drb%d.rsn%d.rso%d.rfi%d", size, entity->ue_rnti, entity->channel_id, sn, so, fi);
+#endif
   pdu_segment = rlc_rx_new_pdu_segment(sn, so, size, lsf, buffer, data_start);
   entity->rx_list = rlc_rx_pdu_segment_list_add(sn_compare_rx, entity,
                                                 entity->rx_list, pdu_segment);
@@ -1268,6 +1292,9 @@ static int serialize_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize,
     li = sdu->size - sdu_start_byte;
     if (outpos + li >= pdu->data_size)
       li = pdu->data_size - outpos;
+#ifdef LATSEQ
+    LATSEQ_P("D rlc.tx.am--rlc.seg.am", "len%d:rnti%d:drb%d.sdu%d.rsn%d.rfi%d", sdu->size, entity->ue_rnti, entity->channel_id, sdu->sdu_num, pdu->sn, fi);
+#endif
     memcpy(out+outpos, sdu->data + sdu_start_byte, li);
     outpos += li;
     sdu_start_byte = 0;
@@ -1279,7 +1306,7 @@ static int serialize_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize,
   return header_size + pdu->data_size;
 }
 
-static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
+static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize, int *sn, int *so)
 {
   int                  vt_ms;
   tx_pdu_size_t        pdu_size;
@@ -1302,6 +1329,7 @@ static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
   pdu = rlc_tx_new_pdu();
 
   pdu->sn = entity->vt_s;
+  *sn = pdu->sn;
   entity->vt_s = (entity->vt_s + 1) % 1024;
 
   /* go to first SDU (skip those already fully processed) */
@@ -1321,6 +1349,7 @@ static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
    * segment goes to retransmit list)
    */
   pdu->retx_count = -1;
+  *so = pdu->so;
 
   /* reserve SDU bytes */
   cursize = 0;
@@ -1333,6 +1362,9 @@ static int generate_tx_pdu(rlc_entity_am_t *entity, char *buffer, int bufsize)
   }
 
   pdu->data_size = cursize;
+// #ifdef LATSEQ
+//   LATSEQ_P("D rlc.tx.am--rlc.seg.am", "len%d:rnti%d:drb%d.sdu%d.rsn%d.rso%d", cursize, entity->ue_rnti, entity->channel_id, ((rlc_sdu_t*)(pdu->start_sdu))->sdu_num, pdu->sn, pdu->so);
+// #endif
 
   /* put PDU at the end of the wait list */
   entity->wait_list = rlc_tx_pdu_list_append(entity->wait_list, pdu);
@@ -1409,7 +1441,7 @@ static void resegment(rlc_tx_pdu_segment_t *pdu, int size)
   pdu->next = new_pdu;
 }
 
-static int generate_retx_pdu(rlc_entity_am_t *entity, char *buffer, int size)
+static int generate_retx_pdu(rlc_entity_am_t *entity, char *buffer, int size, int *sn, int *so)
 {
   rlc_tx_pdu_segment_t *pdu;
   int orig_size;
@@ -1438,7 +1470,8 @@ static int generate_retx_pdu(rlc_entity_am_t *entity, char *buffer, int size)
     p = 1;
     entity->force_poll = 0;
   }
-
+  *sn = pdu->sn;
+  *so = pdu->so;
   return serialize_pdu(entity, buffer, orig_size, pdu, p);
 }
 
@@ -1502,10 +1535,12 @@ rlc_entity_buffer_status_t rlc_entity_am_buffer_status(
   return ret;
 }
 
-int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
+int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
   rlc_entity_am_t *entity = (rlc_entity_am_t *)_entity;
   int ret;
+  int pdu_sn=0;
+  int pdu_so=0;
 
   if (status_to_report(entity)) {
     ret = generate_status(entity, buffer, size);
@@ -1514,12 +1549,19 @@ int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
   }
 
   if (entity->retransmit_list != NULL) {
-    ret = generate_retx_pdu(entity, buffer, size);
+    ret = generate_retx_pdu(entity, buffer, size, &pdu_sn, &pdu_so);
     if (ret != 0)
+#ifdef LATSEQ
+      LATSEQ_P("D rlc.retx.am--mac.mux", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.fm%d", ret, entity->ue_rnti, entity->channel_id, channel_id, pdu_sn, pdu_so, frame);
+#endif
       return ret;
   }
 
-  return generate_tx_pdu(entity, buffer, size);
+  ret = generate_tx_pdu(entity, buffer, size, &pdu_sn, &pdu_so);
+#ifdef LATSEQ
+  LATSEQ_P("D rlc.seg.am--mac.mux", "len%d:rnti%d:drb%d.lcid%d.rsn%d.rso%d.reqfm%d", ret, entity->ue_rnti, entity->channel_id, channel_id, pdu_sn, pdu_so, frame);
+#endif
+  return ret;
 }
 
 /*************************************************************************/
@@ -1541,13 +1583,28 @@ void rlc_entity_am_recv_sdu(rlc_entity_t *_entity, char *buffer, int size,
   if (entity->tx_size + size > entity->tx_maxsize) {
     LOG_D(RLC, "%s:%d:%s: warning: SDU rejected, SDU buffer full\n",
           __FILE__, __LINE__, __FUNCTION__);
+#ifdef LATSEQ
+    uint16_t seqnum = 0x00;
+    seqnum = buffer[0] & 0x0F;
+    seqnum <<= 8;
+    seqnum |= buffer[1] & 0xFF;
+    LATSEQ_P("D pdcp.tx--rlc.drop.am", "len%d:rnti%d:drb%d.psn%d", size, entity->ue_rnti, entity->channel_id, seqnum);
+#endif
     return;
   }
 
   entity->tx_size += size;
-
-  sdu = rlc_new_sdu(buffer, size, sdu_id);
+  entity->tx_num += 1;
+  sdu = rlc_new_sdu(buffer, size, sdu_id, entity->tx_num);
   rlc_sdu_list_add(&entity->tx_list, &entity->tx_end, sdu);
+#ifdef LATSEQ
+  uint16_t seqnum = 0x00;
+  seqnum = buffer[0] & 0x0F;
+  seqnum <<= 8;
+  seqnum |= buffer[1] & 0xFF;
+  LATSEQ_P("D pdcp.tx--rlc.tx.am", "len%d:rnti%d:drb%d.psn%d.sdu%d", size, entity->ue_rnti, entity->channel_id, seqnum, entity->tx_num);
+  LATSEQ_P("I rlc.txbuf.am", "occ%d:rnti%d:drb%d", entity->tx_size, entity->ue_rnti, entity->channel_id);
+#endif
 }
 
 /*************************************************************************/
@@ -1765,6 +1822,7 @@ static void clear_entity(rlc_entity_am_t *entity)
   entity->tx_list = NULL;
   entity->tx_end = NULL;
   entity->tx_size = 0;
+  entity->tx_num = 0;
 
   free_pdu_segment_list(entity->wait_list);
   free_pdu_segment_list(entity->retransmit_list);
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_am.h b/openair2/LAYER2/rlc_v2/rlc_entity_am.h
index 0437f17ad8..9f89ef7d09 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_am.h
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_am.h
@@ -24,6 +24,7 @@
 
 #include <stdint.h>
 
+#include "platform_types.h"
 #include "rlc_entity.h"
 #include "rlc_pdu.h"
 #include "rlc_sdu.h"
@@ -226,6 +227,8 @@ typedef struct {
   int poll_pdu;              /* -1 means infinity */
   int poll_byte;             /* -1 means infinity */
   int max_retx_threshold;
+  unsigned int channel_id;
+  int ue_rnti;
 
   /* runtime rx */
   int vr_r;
@@ -255,6 +258,7 @@ typedef struct {
   rlc_rx_pdu_segment_t *rx_list;
   int                  rx_size;
   int                  rx_maxsize;
+  //int                  rx_num;
 
   /* reassembly management */
   rlc_am_reassemble_t    reassemble;
@@ -264,6 +268,7 @@ typedef struct {
   rlc_sdu_t *tx_end;
   int       tx_size;
   int       tx_maxsize;
+  int       tx_num;
 
   rlc_tx_pdu_segment_t *wait_list;
   rlc_tx_pdu_segment_t *retransmit_list;
@@ -273,10 +278,10 @@ typedef struct {
 
 void rlc_entity_am_recv_sdu(rlc_entity_t *entity, char *buffer, int size,
                             int sdu_id);
-void rlc_entity_am_recv_pdu(rlc_entity_t *entity, char *buffer, int size);
+void rlc_entity_am_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 rlc_entity_buffer_status_t rlc_entity_am_buffer_status(
     rlc_entity_t *entity, int maxsize);
-int rlc_entity_am_generate_pdu(rlc_entity_t *entity, char *buffer, int size);
+int rlc_entity_am_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 void rlc_entity_am_set_time(rlc_entity_t *entity, uint64_t now);
 void rlc_entity_am_discard_sdu(rlc_entity_t *entity, int sdu_id);
 void rlc_entity_am_reestablishment(rlc_entity_t *entity);
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_um.c b/openair2/LAYER2/rlc_v2/rlc_entity_um.c
index 54707875a0..efce33657b 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_um.c
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_um.c
@@ -26,6 +26,9 @@
 #include <string.h>
 
 #include "LOG/log.h"
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 /*************************************************************************/
 /* PDU RX functions                                                      */
@@ -228,7 +231,7 @@ static void rlc_um_reception_actions(rlc_entity_um_t *entity,
   }
 }
 
-void rlc_entity_um_recv_pdu(rlc_entity_t *_entity, char *buffer, int size)
+void rlc_entity_um_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
 #define R(d) do { if (rlc_pdu_decoder_in_error(&d)) goto err; } while (0)
   rlc_entity_um_t *entity = (rlc_entity_um_t *)_entity;
@@ -420,7 +423,7 @@ rlc_entity_buffer_status_t rlc_entity_um_buffer_status(
   return ret;
 }
 
-int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
+int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame)
 {
   rlc_entity_um_t      *entity = (rlc_entity_um_t *)_entity;
   tx_pdu_size_t        pdu_size;
@@ -537,9 +540,11 @@ int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size)
   }
   if (entity->tx_list == NULL)
     entity->tx_end = NULL;
-
   /* update VT(US) */
   entity->vt_us = (entity->vt_us + 1) % entity->sn_modulus;
+#ifdef LATSEQ
+  LATSEQ_P("D rlc.tx.um--rlc.seg.um", "len%d:rnti%d:drb%d.lcid%d.rtime%d.rsn%d", pdu_size.header_size + pdu_size.data_size, entity->ue_rnti, entity->channel_id , entity->channel_id, entity->t_current, entity->vt_us);
+#endif
 
   return pdu_size.header_size + pdu_size.data_size;
 }
@@ -567,8 +572,9 @@ void rlc_entity_um_recv_sdu(rlc_entity_t *_entity, char *buffer, int size,
   }
 
   entity->tx_size += size;
-
-  sdu = rlc_new_sdu(buffer, size, sdu_id);
+  entity->tx_num += 1;
+// no access to ctxt_pP ???
+  sdu = rlc_new_sdu(buffer, size, sdu_id, entity->tx_num);
   rlc_sdu_list_add(&entity->tx_list, &entity->tx_end, sdu);
 }
 
@@ -689,6 +695,7 @@ static void clear_entity(rlc_entity_um_t *entity)
   entity->tx_list = NULL;
   entity->tx_end = NULL;
   entity->tx_size = 0;
+  entity->tx_num = 0;
 }
 
 void rlc_entity_um_reestablishment(rlc_entity_t *_entity)
diff --git a/openair2/LAYER2/rlc_v2/rlc_entity_um.h b/openair2/LAYER2/rlc_v2/rlc_entity_um.h
index 02c5141a7a..8275a20cd3 100644
--- a/openair2/LAYER2/rlc_v2/rlc_entity_um.h
+++ b/openair2/LAYER2/rlc_v2/rlc_entity_um.h
@@ -22,6 +22,7 @@
 #ifndef _RLC_ENTITY_UM_H_
 #define _RLC_ENTITY_UM_H_
 
+#include "platform_types.h"
 #include "rlc_entity.h"
 #include "rlc_pdu.h"
 #include "rlc_sdu.h"
@@ -43,6 +44,8 @@ typedef struct {
   /* configuration */
   int t_reordering;
   int sn_field_length;
+  unsigned int channel_id;
+  int ue_rnti;
 
   int sn_modulus;        /* 1024 for sn_field_length == 10, 32 for 5 */
   int window_size;       /* 512 for sn_field_length == 10, 16 for 5 */
@@ -74,17 +77,18 @@ typedef struct {
   rlc_sdu_t *tx_end;
   int       tx_size;
   int       tx_maxsize;
+  int       tx_num;
 } rlc_entity_um_t;
 
 void rlc_entity_um_recv_sdu(rlc_entity_t *_entity, char *buffer, int size,
                             int sdu_id);
-void rlc_entity_um_recv_pdu(rlc_entity_t *entity, char *buffer, int size);
+void rlc_entity_um_recv_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 rlc_entity_buffer_status_t rlc_entity_um_buffer_status(
     rlc_entity_t *entity, int maxsize);
-int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size);
+int rlc_entity_um_generate_pdu(rlc_entity_t *_entity, char *buffer, int size, const logical_chan_id_t channel_id, const frame_t frame);
 void rlc_entity_um_set_time(rlc_entity_t *entity, uint64_t now);
 void rlc_entity_um_discard_sdu(rlc_entity_t *entity, int sdu_id);
 void rlc_entity_um_reestablishment(rlc_entity_t *entity);
 void rlc_entity_um_delete(rlc_entity_t *entity);
 
-#endif /* _RLC_ENTITY_UM_H_ */
+#endif /* _RLC_ENTITY_UM_H_ */
\ No newline at end of file
diff --git a/openair2/LAYER2/rlc_v2/rlc_oai_api.c b/openair2/LAYER2/rlc_v2/rlc_oai_api.c
index 0cf4b85fa2..63a295cb34 100644
--- a/openair2/LAYER2/rlc_v2/rlc_oai_api.c
+++ b/openair2/LAYER2/rlc_v2/rlc_oai_api.c
@@ -28,6 +28,10 @@
 #include "rlc_ue_manager.h"
 #include "rlc_entity.h"
 
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 #include <stdint.h>
 
 static rlc_ue_manager_t *rlc_ue_manager;
@@ -95,7 +99,7 @@ void mac_rlc_data_ind     (
 
   if (rb != NULL) {
     rb->set_time(rb, rlc_current_time);
-    rb->recv_pdu(rb, buffer_pP, tb_sizeP);
+    rb->recv_pdu(rb, buffer_pP, tb_sizeP, channel_idP, frameP);
   } else {
     LOG_E(RLC, "%s:%d:%s: fatal: no RB found (rnti %d channel ID %d)\n",
           __FILE__, __LINE__, __FUNCTION__, rnti, channel_id);
@@ -127,9 +131,16 @@ tbs_size_t mac_rlc_data_req(
   rlc_manager_lock(rlc_ue_manager);
   ue = rlc_manager_get_ue(rlc_ue_manager, rntiP);
 
+  logical_chan_id_t lcid;
   switch (channel_idP) {
-  case 1 ... 2: rb = ue->srb[channel_idP - 1]; break;
-  case 3 ... 7: rb = ue->drb[channel_idP - 3]; break;
+  case 1 ... 2:
+    lcid = channel_idP - 1;
+    rb = ue->srb[lcid]; 
+    break;
+  case 3 ... 7:
+    lcid = channel_idP - 3;
+    rb = ue->drb[lcid];
+    break;
   default:      rb = NULL;                     break;
   }
 
@@ -144,7 +155,7 @@ tbs_size_t mac_rlc_data_req(
   if (rb != NULL) {
     rb->set_time(rb, rlc_current_time);
     maxsize = tb_sizeP;
-    ret = rb->generate_pdu(rb, buffer_pP, maxsize);
+    ret = rb->generate_pdu(rb, buffer_pP, maxsize, channel_idP, frameP);
   } else {
     LOG_E(RLC, "%s:%d:%s: fatal: data req for unknown RB\n", __FILE__, __LINE__, __FUNCTION__);
     exit(1);
@@ -152,7 +163,6 @@ tbs_size_t mac_rlc_data_req(
   }
 
   rlc_manager_unlock(rlc_ue_manager);
-
   if (enb_flagP)
     T(T_ENB_RLC_MAC_DL, T_INT(module_idP), T_INT(rntiP),
       T_INT(channel_idP), T_INT(ret));
@@ -638,7 +648,8 @@ static void add_srb(int rnti, int module_id, struct LTE_SRB_ToAddMod *s)
                                max_retx_reached, ue,
                                t_reordering, t_status_prohibit,
                                t_poll_retransmit,
-                               poll_pdu, poll_byte, max_retx_threshold);
+                               poll_pdu, poll_byte, max_retx_threshold, srb_id,
+                               rnti);
     rlc_ue_add_srb_rlc_entity(ue, srb_id, rlc_am);
 
     LOG_D(RLC, "%s:%d:%s: added SRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, srb_id, rnti);
@@ -715,7 +726,8 @@ static void add_drb_am(int rnti, int module_id, struct LTE_DRB_ToAddMod *s)
                                max_retx_reached, ue,
                                t_reordering, t_status_prohibit,
                                t_poll_retransmit,
-                               poll_pdu, poll_byte, max_retx_threshold);
+                               poll_pdu, poll_byte, max_retx_threshold, drb_id,
+                               rnti);
     rlc_ue_add_drb_rlc_entity(ue, drb_id, rlc_am);
 
     LOG_D(RLC, "%s:%d:%s: added DRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, drb_id, rnti);
@@ -785,7 +797,9 @@ static void add_drb_um(int rnti, int module_id, struct LTE_DRB_ToAddMod *s)
                                1000000,
                                deliver_sdu, ue,
                                t_reordering,
-                               sn_field_length);
+                               sn_field_length,
+                               drb_id,
+                               rnti);
     rlc_ue_add_drb_rlc_entity(ue, drb_id, rlc_um);
 
     LOG_D(RLC, "%s:%d:%s: added DRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, drb_id, rnti);
@@ -901,8 +915,9 @@ rlc_op_status_t rrc_rlc_config_asn1_req (const protocol_ctxt_t   * const ctxt_pP
                                      1000000,
                                      deliver_sdu, ue,
                                      0,//LTE_T_Reordering_ms0,//t_reordering,
-                                     5//LTE_SN_FieldLength_size5//sn_field_length
-                                    );
+                                     5,//LTE_SN_FieldLength_size5//sn_field_length
+                                     drb_id,
+                                     mbms_rnti);
           rlc_ue_add_drb_rlc_entity(ue, drb_id, rlc_um);
 
           LOG_D(RLC, "%s:%d:%s: added DRB %d to UE RNTI %x\n", __FILE__, __LINE__, __FUNCTION__, (int)drb_id, mbms_rnti);
diff --git a/openair2/LAYER2/rlc_v2/rlc_sdu.c b/openair2/LAYER2/rlc_v2/rlc_sdu.c
index 16465a9ff1..05bcc2c6fe 100644
--- a/openair2/LAYER2/rlc_v2/rlc_sdu.c
+++ b/openair2/LAYER2/rlc_v2/rlc_sdu.c
@@ -26,13 +26,14 @@
 
 #include "LOG/log.h"
 
-rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id)
+rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id, int sdu_num)
 {
   rlc_sdu_t *ret = calloc(1, sizeof(rlc_sdu_t));
   if (ret == NULL)
     goto oom;
 
   ret->upper_layer_id = upper_layer_id;
+  ret->sdu_num = sdu_num;
 
   ret->data = malloc(size);
   if (ret->data == NULL)
diff --git a/openair2/LAYER2/rlc_v2/rlc_sdu.h b/openair2/LAYER2/rlc_v2/rlc_sdu.h
index 2c678956ee..e93701741b 100644
--- a/openair2/LAYER2/rlc_v2/rlc_sdu.h
+++ b/openair2/LAYER2/rlc_v2/rlc_sdu.h
@@ -24,6 +24,7 @@
 
 typedef struct rlc_sdu_t {
   int upper_layer_id;
+  int sdu_num;
   char *data;
   int size;
   /* next_byte indicates the starting byte to use to construct a new PDU */
@@ -32,7 +33,7 @@ typedef struct rlc_sdu_t {
   struct rlc_sdu_t *next;
 } rlc_sdu_t;
 
-rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id);
+rlc_sdu_t *rlc_new_sdu(char *buffer, int size, int upper_layer_id, int sdu_num);
 void rlc_free_sdu(rlc_sdu_t *sdu);
 void rlc_sdu_list_add(rlc_sdu_t **list, rlc_sdu_t **end, rlc_sdu_t *sdu);
 
diff --git a/openair2/LAYER2/rlc_v2/tests/test.c b/openair2/LAYER2/rlc_v2/tests/test.c
index 734e85f1f5..4469eb0c6c 100644
--- a/openair2/LAYER2/rlc_v2/tests/test.c
+++ b/openair2/LAYER2/rlc_v2/tests/test.c
@@ -213,7 +213,7 @@ int test_main(void)
                                   successful_delivery_enb, NULL,
                                   max_retx_reached_enb, NULL,
                                   test[pos+3], test[pos+4], test[pos+5],
-                                  test[pos+6], test[pos+7], test[pos+8]);
+                                  test[pos+6], test[pos+7], test[pos+8],0,0);
           pos += 9;
           break;
         case UE_AM:
@@ -222,19 +222,19 @@ int test_main(void)
                                  successful_delivery_ue, NULL,
                                  max_retx_reached_ue, NULL,
                                  test[pos+3], test[pos+4], test[pos+5],
-                                 test[pos+6], test[pos+7], test[pos+8]);
+                                 test[pos+6], test[pos+7], test[pos+8],0,0);
           pos += 9;
           break;
         case ENB_UM:
           enb = new_rlc_entity_um(test[pos+1], test[pos+2],
                                   deliver_sdu_enb_um, NULL,
-                                  test[pos+3], test[pos+4]);
+                                  test[pos+3], test[pos+4],0);
           pos += 5;
           break;
         case UE_UM:
           ue = new_rlc_entity_um(test[pos+1], test[pos+2],
                                  deliver_sdu_ue_um, NULL,
-                                 test[pos+3], test[pos+4]);
+                                 test[pos+3], test[pos+4],0);
           pos += 5;
           break;
         case ENB_SDU:
diff --git a/openair2/RRC/LTE/rrc_eNB_S1AP.c b/openair2/RRC/LTE/rrc_eNB_S1AP.c
index 1cb575d1dd..6c993fff22 100644
--- a/openair2/RRC/LTE/rrc_eNB_S1AP.c
+++ b/openair2/RRC/LTE/rrc_eNB_S1AP.c
@@ -77,6 +77,7 @@ static const uint16_t S1AP_ENCRYPTION_EEA2_MASK = 0x4000;
 /* Masks for S1AP Integrity algorithms, EIA0 is always supported (not coded) */
 static const uint16_t S1AP_INTEGRITY_EIA1_MASK = 0x8000;
 static const uint16_t S1AP_INTEGRITY_EIA2_MASK = 0x4000;
+static const uint16_t S1AP_INTEGRITY_EIA3_MASK = 0x2000;
 
 #define INTEGRITY_ALGORITHM_NONE LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia0_v920
 
@@ -416,6 +417,15 @@ static LTE_CipheringAlgorithm_r12_t rrc_eNB_select_ciphering(uint16_t algorithms
  *\return the selected algorithm.
  */
 static e_LTE_SecurityAlgorithmConfig__integrityProtAlgorithm rrc_eNB_select_integrity(uint16_t algorithms) {
+  if (algorithms & S1AP_INTEGRITY_EIA3_MASK) {  // not sure on mask
+    /* TEMPORARY patch to fallback in eia2 instead of unsupported by eNB eia3*/
+    if (algorithms & S1AP_INTEGRITY_EIA2_MASK) {
+      return LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia2;
+    }
+    else {
+      return LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia3_v1130;
+    }
+  }
   if (algorithms & S1AP_INTEGRITY_EIA2_MASK) {
     return LTE_SecurityAlgorithmConfig__integrityProtAlgorithm_eia2;
   }
diff --git a/openair3/GTPV1-U/gtpv1u_eNB.c b/openair3/GTPV1-U/gtpv1u_eNB.c
index 0fe2741d7b..52c624707b 100644
--- a/openair3/GTPV1-U/gtpv1u_eNB.c
+++ b/openair3/GTPV1-U/gtpv1u_eNB.c
@@ -52,6 +52,10 @@
 #include "gtpv1u_eNB_task.h"
 #include "rrc_eNB_GTPV1U.h"
 #include <common/utils/msc/msc.h>
+#if LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
+
 
 #undef GTP_DUMP_SOCKET
 
@@ -145,6 +149,7 @@ static int gtpv1u_eNB_send_init_udp(const Gtpv1uS1Req *req) {
   UDP_INIT(message_p).port = req->enb_port_for_S1u_S12_S4_up;
   addr.s_addr = req->enb_ip_address_for_S1u_S12_S4_up;
   UDP_INIT(message_p).address = inet_ntoa(addr);
+  {const char *s;if ((s=getenv("OAINAT"))) {UDP_INIT(message_p).address=(char *)s;LOG_W(GTPU, "Using OAINAT=%s for GTPU",s);}}
   LOG_I(GTPU, "Tx UDP_INIT IP addr %s (%x)\n", UDP_INIT(message_p).address,UDP_INIT(message_p).port);
   MSC_LOG_EVENT(
     MSC_GTPU_ENB,
@@ -232,6 +237,7 @@ NwGtpv1uRcT gtpv1u_eNB_process_stack_req(
        */
       teid = pUlpApi->apiInfo.recvMsgInfo.teid;
       pMsg = (NwGtpv1uMsgT *) pUlpApi->apiInfo.recvMsgInfo.hMsg;
+      RC.gtpv1u_data_g->tx_seq_num = pMsg->seqNum;
       msgType = pMsg->msgType;
 
       if (NW_GTPV1U_OK != nwGtpv1uMsgGetTpdu(pUlpApi->apiInfo.recvMsgInfo.hMsg,
@@ -419,7 +425,9 @@ NwGtpv1uRcT gtpv1u_eNB_process_stack_req(
             }
           }
         }
-
+#if LATSEQ
+        LATSEQ_P("D gtp.in--pdcp.in.gtp", "len%d:rnti%d:teid%u.drb%d.gsn%d.gso%d.npdu%d", buffer_len, gtpv1u_teid_data_p->ue_id, teid, gtpv1u_teid_data_p->eps_bearer_id - 4, pMsg->seqNum, pMsg->msgBufOffset, pMsg->npduNum);
+#endif
         result = pdcp_data_req(
                    &ctxt,
                    SRB_FLAG_NO,
@@ -1358,6 +1366,10 @@ void *gtpv1u_eNB_process_itti_msg(void *notUsed) {
                           enb_s1u_teid,sgw_s1u_teid,data_req_p->length);
             (void)enb_s1u_teid; /* avoid gcc warning "set but not used" */
           } else {
+#if LATSEQ
+            uint16_t ipid = data_req_p->buffer[data_req_p->offset + 4] << 8 | data_req_p->buffer[data_req_p->offset + 5];
+            LATSEQ_P("U gtp.out--ip.out","len%d:rnti%d:drb%d.psn%d.teid%d.gsn%d.ipid0x%x",data_req_p->length, data_req_p->rnti, data_req_p->rab_id - 4, data_req_p->seqnum, sgw_s1u_teid, RC.gtpv1u_data_g->seq_num, ipid);
+#endif
             rc = nwGtpv1uProcessUlpReq(RC.gtpv1u_data_g->gtpv1u_stack, &stack_req);
 
             if (rc != NW_GTPV1U_OK) {
diff --git a/openair3/GTPV1-U/gtpv1u_eNB_defs.h b/openair3/GTPV1-U/gtpv1u_eNB_defs.h
index 79d9a1dcdd..7d32f7abcf 100644
--- a/openair3/GTPV1-U/gtpv1u_eNB_defs.h
+++ b/openair3/GTPV1-U/gtpv1u_eNB_defs.h
@@ -109,6 +109,7 @@ typedef struct gtpv1u_data_s {
   //udp_data_t            udp_data;
 
   uint16_t              seq_num;
+  uint16_t              tx_seq_num;
   uint8_t               restart_counter;
 
 #ifdef GTPU_IN_KERNEL
diff --git a/openair3/GTPV1-U/gtpv1u_task.c b/openair3/GTPV1-U/gtpv1u_task.c
index 1339839cf9..f199882a54 100644
--- a/openair3/GTPV1-U/gtpv1u_task.c
+++ b/openair3/GTPV1-U/gtpv1u_task.c
@@ -429,6 +429,7 @@ static void *gtpv1u_thread(void *args)
 
     // DATA COMING FROM UDP
     case UDP_DATA_IND: {
+      // TODO: Latses point ip.in--gtp.in
       udp_data_ind_t *udp_data_ind_p;
       udp_data_ind_p = &received_message_p->ittiMsg.udp_data_ind;
       nwGtpv1uProcessUdpReq(gtpv1u_sgw_data.gtpv1u_stack,
diff --git a/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1u.c b/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1u.c
index 0d962cad7d..c5152efc28 100644
--- a/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1u.c
+++ b/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1u.c
@@ -54,6 +54,9 @@
 #include "common/utils/LOG/log.h"
 #include "common/utils/LOG/vcd_signal_dumper.h"
 #endif
+//#ifdef LATSEQ
+//  #include "common/utils/LATSEQ/latseq.h"
+//#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -242,7 +245,9 @@ nwGtpv1uCreateAndSendMsg( NwGtpv1uStackT *thiz, uint32_t peerIp, uint16_t peerPo
     *((uint8_t *) msgHdr) = (pMsg->extHdrFlag ? htons(pMsg->nextExtHdrType) : 0x00);
     msgHdr++;
   }
-
+//#if LATSEQ
+//  LATSEQ_P("U gtp.out--ip.out","len%d::teid%d.gsn%d",pMsg->msgBufLen, pMsg->teid, pMsg->seqNum);
+//#endif
   rc = thiz->udp.udpDataReqCallback(thiz->udp.hUdp,
                                     pMsg->msgBuf,
                                     pMsg->msgBufLen,
@@ -571,7 +576,6 @@ nwGtpv1uProcessGpdu( NwGtpv1uStackT *thiz,
         " G-PDU ltid %u size %u",
         tunnelEndPointKey.teid,
         gpduLen);
-
       rc = nwGtpSessionSendMsgApiToUlpEntity(pTunnelEndPoint, pMsg);
     }
   } else {
diff --git a/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1uMsg.c b/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1uMsg.c
index 365d6d23a5..e7de58479d 100644
--- a/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1uMsg.c
+++ b/openair3/GTPV1-U/nw-gtpv1u/src/NwGtpv1uMsg.c
@@ -48,6 +48,9 @@
 #if defined(ENB_MODE)
 #include "common/utils/LOG/log.h"
 #endif
+#ifdef LATSEQ
+  #include "common/utils/LATSEQ/latseq.h"
+#endif
 
 #define NW_GTPV1U_EPC_SPECIFIC_HEADER_SIZE                             (12)   /**< Size of GTPv1u EPC specific header */
 #define NW_GTPV1U_EPC_MIN_HEADER_SIZE                                  (8)
@@ -265,6 +268,7 @@ nwGtpv1uMsgFromBufferNew( NW_IN NwGtpv1uStackHandleT hGtpuStackHandle,
     pMsg->msgType       = *(pBuf);
     pBuf++;
 
+    // GPRS message length
     pBuf += 2;
 
     pMsg->teid          = ntohl(*((uint32_t *)pBuf));
@@ -285,6 +289,10 @@ nwGtpv1uMsgFromBufferNew( NW_IN NwGtpv1uStackHandleT hGtpuStackHandle,
                pMsg->msgLen, pMsg->msgBufLen, pMsg->msgBufOffset);
 #endif
     *phMsg = (NwGtpv1uMsgHandleT) pMsg;
+#ifdef LATSEQ
+    uint16_t ipid = pBuf[4] << 8 | pBuf[5];
+    LATSEQ_P("D ip.in--gtp.in", "len%d::ipid0x%x.teid%u.gsn%d.gso%d.npdu%d", pMsg->msgLen, ipid, pMsg->teid, pMsg->seqNum, pMsg->msgBufOffset, pMsg->npduNum);
+#endif
     return NW_GTPV1U_OK;
   }
 
diff --git a/openair3/NAS/UE/EMM/SecurityModeControl.c b/openair3/NAS/UE/EMM/SecurityModeControl.c
index b27270fadc..4ffb238f81 100644
--- a/openair3/NAS/UE/EMM/SecurityModeControl.c
+++ b/openair3/NAS/UE/EMM/SecurityModeControl.c
@@ -164,6 +164,7 @@ int emm_proc_security_mode_command(nas_user_t *user, int native_ksi, int ksi,
   if ( (reea != eea) || (reia != eia) ) {
     LOG_TRACE(WARNING, "EMM-PROC  - Replayed UE security capabilities "
               "rejected");
+    //printf("EMM_CAUSE_UE_SECURITY_MISMATCH : eai = %hhu reia = %hhu\n", eia, reia);
     emm_cause = EMM_CAUSE_UE_SECURITY_MISMATCH;
 
     /* XXX - For testing purpose UE always accepts EIA0
